var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, {
      get: all2[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all2[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/clean-css/lib/optimizer/level-0/optimize.js
var require_optimize = __commonJS((exports, module) => {
  var level0Optimize = function(tokens) {
    return tokens;
  };
  module.exports = level0Optimize;
});

// node_modules/clean-css/lib/utils/natural-compare.js
var require_natural_compare = __commonJS((exports, module) => {
  var naturalCompare = function(value1, value2) {
    var keys1 = ("" + value1).split(NUMBER_PATTERN).map(tryParseInt);
    var keys2 = ("" + value2).split(NUMBER_PATTERN).map(tryParseInt);
    var key1;
    var key2;
    var compareFirst = Math.min(keys1.length, keys2.length);
    var i, l;
    for (i = 0, l = compareFirst;i < l; i++) {
      key1 = keys1[i];
      key2 = keys2[i];
      if (key1 != key2) {
        return key1 > key2 ? 1 : -1;
      }
    }
    return keys1.length > keys2.length ? 1 : keys1.length == keys2.length ? 0 : -1;
  };
  var tryParseInt = function(value) {
    return "" + parseInt(value) == value ? parseInt(value) : value;
  };
  var NUMBER_PATTERN = /([0-9]+)/;
  module.exports = naturalCompare;
});

// node_modules/clean-css/lib/optimizer/level-1/sort-selectors.js
var require_sort_selectors = __commonJS((exports, module) => {
  var naturalSorter = function(scope1, scope2) {
    return naturalCompare(scope1[1], scope2[1]);
  };
  var standardSorter = function(scope1, scope2) {
    return scope1[1] > scope2[1] ? 1 : -1;
  };
  var sortSelectors = function(selectors, method) {
    switch (method) {
      case "natural":
        return selectors.sort(naturalSorter);
      case "standard":
        return selectors.sort(standardSorter);
      case "none":
      case false:
        return selectors;
    }
  };
  var naturalCompare = require_natural_compare();
  module.exports = sortSelectors;
});

// node:os
var exports_os = {};
__export(exports_os, {
  uptime: () => {
    {
      return A;
    }
  },
  type: () => {
    {
      return V;
    }
  },
  totalmem: () => {
    {
      return N;
    }
  },
  tmpdir: () => {
    {
      return U;
    }
  },
  release: () => {
    {
      return x;
    }
  },
  platform: () => {
    {
      return O;
    }
  },
  networkInterfaces: () => {
    {
      return j;
    }
  },
  loadavg: () => {
    {
      return y;
    }
  },
  hostname: () => {
    {
      return k;
    }
  },
  homedir: () => {
    {
      return _;
    }
  },
  getNetworkInterfaces: () => {
    {
      return B;
    }
  },
  freemem: () => {
    {
      return I;
    }
  },
  endianness: () => {
    {
      return L;
    }
  },
  default: () => {
    {
      return E;
    }
  },
  cpus: () => {
    {
      return b;
    }
  },
  arch: () => {
    {
      return M;
    }
  },
  EOL: () => {
    {
      return X;
    }
  }
});
var c, a, m, s, p, d, l, h, g, f, u, E, L, k, y, A, I, N, b, V, x, M, O, U, X, _, j, B;
var init_os = __esm(() => {
  c = Object.create;
  a = Object.defineProperty;
  m = Object.getOwnPropertyDescriptor;
  s = Object.getOwnPropertyNames;
  p = Object.getPrototypeOf;
  d = Object.prototype.hasOwnProperty;
  l = (r, n) => () => (n || r((n = { exports: {} }).exports, n), n.exports);
  h = (r, n, t, i) => {
    if (n && typeof n == "object" || typeof n == "function")
      for (let o of s(n))
        !d.call(r, o) && o !== t && a(r, o, { get: () => n[o], enumerable: !(i = m(n, o)) || i.enumerable });
    return r;
  };
  g = (r, n, t) => (t = r != null ? c(p(r)) : {}, h(n || !r || !r.__esModule ? a(t, "default", { value: r, enumerable: true }) : t, r));
  f = l((e) => {
    e.endianness = function() {
      return "LE";
    };
    e.hostname = function() {
      return typeof location < "u" ? location.hostname : "";
    };
    e.loadavg = function() {
      return [];
    };
    e.uptime = function() {
      return 0;
    };
    e.freemem = function() {
      return Number.MAX_VALUE;
    };
    e.totalmem = function() {
      return Number.MAX_VALUE;
    };
    e.cpus = function() {
      return [];
    };
    e.type = function() {
      return "Browser";
    };
    e.release = function() {
      return typeof navigator < "u" ? navigator.appVersion : "";
    };
    e.networkInterfaces = e.getNetworkInterfaces = function() {
      return {};
    };
    e.arch = function() {
      return "javascript";
    };
    e.platform = function() {
      return "browser";
    };
    e.tmpdir = e.tmpDir = function() {
      return "/tmp";
    };
    e.EOL = `
`;
    e.homedir = function() {
      return "/";
    };
  });
  u = g(f());
  E = u.default;
  ({ endianness: L, hostname: k, loadavg: y, uptime: A, freemem: I, totalmem: N, cpus: b, type: V, release: x, arch: M, platform: O, tmpdir: U, EOL: X, homedir: _, networkInterfaces: j, getNetworkInterfaces: B } = u.default);
});

// node_modules/clean-css/lib/utils/override.js
var require_override = __commonJS((exports, module) => {
  var override = function(source1, source2) {
    var target = {};
    var key1;
    var key2;
    var item;
    for (key1 in source1) {
      item = source1[key1];
      if (Array.isArray(item)) {
        target[key1] = item.slice(0);
      } else if (typeof item == "object" && item !== null) {
        target[key1] = override(item, {});
      } else {
        target[key1] = item;
      }
    }
    for (key2 in source2) {
      item = source2[key2];
      if (key2 in target && Array.isArray(item)) {
        target[key2] = item.slice(0);
      } else if (key2 in target && typeof item == "object" && item !== null) {
        target[key2] = override(target[key2], item);
      } else {
        target[key2] = item;
      }
    }
    return target;
  };
  module.exports = override;
});

// node_modules/clean-css/lib/options/format.js
var require_format = __commonJS((exports, module) => {
  var breaks = function(value) {
    var breakOptions = {};
    breakOptions[Breaks.AfterAtRule] = value;
    breakOptions[Breaks.AfterBlockBegins] = value;
    breakOptions[Breaks.AfterBlockEnds] = value;
    breakOptions[Breaks.AfterComment] = value;
    breakOptions[Breaks.AfterProperty] = value;
    breakOptions[Breaks.AfterRuleBegins] = value;
    breakOptions[Breaks.AfterRuleEnds] = value;
    breakOptions[Breaks.BeforeBlockEnds] = value;
    breakOptions[Breaks.BetweenSelectors] = value;
    return breakOptions;
  };
  var spaces = function(value) {
    var spaceOptions = {};
    spaceOptions[Spaces.AroundSelectorRelation] = value;
    spaceOptions[Spaces.BeforeBlockBegins] = value;
    spaceOptions[Spaces.BeforeValue] = value;
    return spaceOptions;
  };
  var formatFrom = function(source) {
    if (source === undefined || source === false) {
      return false;
    }
    if (typeof source == "object" && "breakWith" in source) {
      source = override(source, { breakWith: mapBreakWith(source.breakWith) });
    }
    if (typeof source == "object" && "indentBy" in source) {
      source = override(source, { indentBy: parseInt(source.indentBy) });
    }
    if (typeof source == "object" && "indentWith" in source) {
      source = override(source, { indentWith: mapIndentWith(source.indentWith) });
    }
    if (typeof source == "object") {
      return remapBreaks(override(DEFAULTS, source));
    }
    if (typeof source == "string" && source == BEAUTIFY_ALIAS) {
      return remapBreaks(override(DEFAULTS, {
        breaks: breaks(true),
        indentBy: 2,
        spaces: spaces(true)
      }));
    }
    if (typeof source == "string" && source == KEEP_BREAKS_ALIAS) {
      return remapBreaks(override(DEFAULTS, {
        breaks: {
          afterAtRule: true,
          afterBlockBegins: true,
          afterBlockEnds: true,
          afterComment: true,
          afterRuleEnds: true,
          beforeBlockEnds: true
        }
      }));
    }
    if (typeof source == "string") {
      return remapBreaks(override(DEFAULTS, toHash(source)));
    }
    return DEFAULTS;
  };
  var toHash = function(string) {
    return string.split(OPTION_SEPARATOR).reduce(function(accumulator, directive) {
      var parts = directive.split(OPTION_NAME_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      if (name == "breaks" || name == "spaces") {
        accumulator[name] = hashValuesToHash(value);
      } else if (name == "indentBy" || name == "wrapAt") {
        accumulator[name] = parseInt(value);
      } else if (name == "indentWith") {
        accumulator[name] = mapIndentWith(value);
      } else if (name == "breakWith") {
        accumulator[name] = mapBreakWith(value);
      }
      return accumulator;
    }, {});
  };
  var hashValuesToHash = function(string) {
    return string.split(HASH_VALUES_OPTION_SEPARATOR).reduce(function(accumulator, directive) {
      var parts = directive.split(HASH_VALUES_NAME_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      accumulator[name] = normalizeValue(value);
      return accumulator;
    }, {});
  };
  var normalizeValue = function(value) {
    switch (value) {
      case FALSE_KEYWORD_1:
      case FALSE_KEYWORD_2:
        return false;
      case TRUE_KEYWORD_1:
      case TRUE_KEYWORD_2:
        return true;
      default:
        return value;
    }
  };
  var mapBreakWith = function(value) {
    switch (value) {
      case "windows":
      case "crlf":
      case BreakWith.CarriageReturnLineFeed:
        return BreakWith.CarriageReturnLineFeed;
      case "unix":
      case "lf":
      case BreakWith.LineFeed:
        return BreakWith.LineFeed;
      default:
        return systemLineBreak;
    }
  };
  var mapIndentWith = function(value) {
    switch (value) {
      case "space":
        return IndentWith.Space;
      case "tab":
        return IndentWith.Tab;
      default:
        return value;
    }
  };
  var remapBreaks = function(source) {
    for (var key in Breaks) {
      var breakName = Breaks[key];
      var breakValue = source.breaks[breakName];
      if (breakValue === true) {
        source.breaks[breakName] = source.breakWith;
      } else if (breakValue === false) {
        source.breaks[breakName] = "";
      } else {
        source.breaks[breakName] = source.breakWith.repeat(parseInt(breakValue));
      }
    }
    return source;
  };
  var systemLineBreak = (init_os(), __toCommonJS(exports_os)).EOL;
  var override = require_override();
  var Breaks = {
    AfterAtRule: "afterAtRule",
    AfterBlockBegins: "afterBlockBegins",
    AfterBlockEnds: "afterBlockEnds",
    AfterComment: "afterComment",
    AfterProperty: "afterProperty",
    AfterRuleBegins: "afterRuleBegins",
    AfterRuleEnds: "afterRuleEnds",
    BeforeBlockEnds: "beforeBlockEnds",
    BetweenSelectors: "betweenSelectors"
  };
  var BreakWith = {
    CarriageReturnLineFeed: "\r\n",
    LineFeed: "\n",
    System: systemLineBreak
  };
  var IndentWith = {
    Space: " ",
    Tab: "\t"
  };
  var Spaces = {
    AroundSelectorRelation: "aroundSelectorRelation",
    BeforeBlockBegins: "beforeBlockBegins",
    BeforeValue: "beforeValue"
  };
  var DEFAULTS = {
    breaks: breaks(false),
    breakWith: BreakWith.System,
    indentBy: 0,
    indentWith: IndentWith.Space,
    spaces: spaces(false),
    wrapAt: false,
    semicolonAfterLastProperty: false
  };
  var BEAUTIFY_ALIAS = "beautify";
  var KEEP_BREAKS_ALIAS = "keep-breaks";
  var OPTION_SEPARATOR = ";";
  var OPTION_NAME_VALUE_SEPARATOR = ":";
  var HASH_VALUES_OPTION_SEPARATOR = ",";
  var HASH_VALUES_NAME_VALUE_SEPARATOR = "=";
  var FALSE_KEYWORD_1 = "false";
  var FALSE_KEYWORD_2 = "off";
  var TRUE_KEYWORD_1 = "true";
  var TRUE_KEYWORD_2 = "on";
  module.exports = {
    Breaks,
    Spaces,
    formatFrom
  };
});

// node_modules/clean-css/lib/tokenizer/marker.js
var require_marker = __commonJS((exports, module) => {
  var Marker = {
    ASTERISK: "*",
    AT: "@",
    BACK_SLASH: "\\",
    CARRIAGE_RETURN: "\r",
    CLOSE_CURLY_BRACKET: "}",
    CLOSE_ROUND_BRACKET: ")",
    CLOSE_SQUARE_BRACKET: "]",
    COLON: ":",
    COMMA: ",",
    DOUBLE_QUOTE: '"',
    EXCLAMATION: "!",
    FORWARD_SLASH: "/",
    INTERNAL: "-clean-css-",
    NEW_LINE_NIX: "\n",
    OPEN_CURLY_BRACKET: "{",
    OPEN_ROUND_BRACKET: "(",
    OPEN_SQUARE_BRACKET: "[",
    SEMICOLON: ";",
    SINGLE_QUOTE: "\'",
    SPACE: " ",
    TAB: "\t",
    UNDERSCORE: "_"
  };
  module.exports = Marker;
});

// node_modules/clean-css/lib/utils/format-position.js
var require_format_position = __commonJS((exports, module) => {
  var formatPosition = function(metadata) {
    var line = metadata[0];
    var column = metadata[1];
    var source = metadata[2];
    return source ? source + ":" + line + ":" + column : line + ":" + column;
  };
  module.exports = formatPosition;
});

// node_modules/clean-css/lib/optimizer/level-1/tidy-rules.js
var require_tidy_rules = __commonJS((exports, module) => {
  var hasInvalidCharacters = function(value) {
    var isEscaped;
    var isInvalid = false;
    var character;
    var isQuote = false;
    var i, l2;
    for (i = 0, l2 = value.length;i < l2; i++) {
      character = value[i];
      if (isEscaped) {
      } else if (character == Marker.SINGLE_QUOTE || character == Marker.DOUBLE_QUOTE) {
        isQuote = !isQuote;
      } else if (!isQuote && (character == Marker.CLOSE_CURLY_BRACKET || character == Marker.EXCLAMATION || character == LESS_THAN || character == Marker.SEMICOLON)) {
        isInvalid = true;
        break;
      } else if (!isQuote && i === 0 && RELATION_PATTERN.test(character)) {
        isInvalid = true;
        break;
      }
      isEscaped = character == Marker.BACK_SLASH;
    }
    return isInvalid;
  };
  var removeWhitespace = function(value, format) {
    var stripped = [];
    var character;
    var isNewLineNix;
    var isNewLineWin;
    var isEscaped;
    var wasEscaped;
    var isQuoted;
    var isSingleQuoted;
    var isDoubleQuoted;
    var isAttribute;
    var isRelation;
    var isWhitespace;
    var isSpaceAwarePseudoClass;
    var roundBracketLevel = 0;
    var wasComma = false;
    var wasRelation = false;
    var wasWhitespace = false;
    var withCaseAttribute = CASE_ATTRIBUTE_PATTERN.test(value);
    var spaceAroundRelation = format && format.spaces[Spaces.AroundSelectorRelation];
    var i, l2;
    for (i = 0, l2 = value.length;i < l2; i++) {
      character = value[i];
      isNewLineNix = character == Marker.NEW_LINE_NIX;
      isNewLineWin = character == Marker.NEW_LINE_NIX && value[i - 1] == Marker.CARRIAGE_RETURN;
      isQuoted = isSingleQuoted || isDoubleQuoted;
      isRelation = !isAttribute && !isEscaped && roundBracketLevel === 0 && RELATION_PATTERN.test(character);
      isWhitespace = WHITESPACE_PATTERN.test(character);
      isSpaceAwarePseudoClass = roundBracketLevel == 1 && character == Marker.CLOSE_ROUND_BRACKET ? false : isSpaceAwarePseudoClass || roundBracketLevel === 0 && character == Marker.COLON && isPseudoClassWithSelectors(value, i);
      if (wasEscaped && isQuoted && isNewLineWin) {
        stripped.pop();
        stripped.pop();
      } else if (isEscaped && isQuoted && isNewLineNix) {
        stripped.pop();
      } else if (isEscaped) {
        stripped.push(character);
      } else if (character == Marker.OPEN_SQUARE_BRACKET && !isQuoted) {
        stripped.push(character);
        isAttribute = true;
      } else if (character == Marker.CLOSE_SQUARE_BRACKET && !isQuoted) {
        stripped.push(character);
        isAttribute = false;
      } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted) {
        stripped.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted) {
        stripped.push(character);
        roundBracketLevel--;
      } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
        stripped.push(character);
        isSingleQuoted = true;
      } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
        stripped.push(character);
        isDoubleQuoted = true;
      } else if (character == Marker.SINGLE_QUOTE && isQuoted) {
        stripped.push(character);
        isSingleQuoted = false;
      } else if (character == Marker.DOUBLE_QUOTE && isQuoted) {
        stripped.push(character);
        isDoubleQuoted = false;
      } else if (isWhitespace && wasRelation && !spaceAroundRelation) {
        continue;
      } else if (!isWhitespace && wasRelation && spaceAroundRelation) {
        stripped.push(Marker.SPACE);
        stripped.push(character);
      } else if (isWhitespace && !wasWhitespace && wasComma && roundBracketLevel > 0 && isSpaceAwarePseudoClass) {
      } else if (isWhitespace && !wasWhitespace && roundBracketLevel > 0 && isSpaceAwarePseudoClass) {
        stripped.push(character);
      } else if (isWhitespace && (isAttribute || roundBracketLevel > 0) && !isQuoted) {
      } else if (isWhitespace && wasWhitespace && !isQuoted) {
      } else if ((isNewLineWin || isNewLineNix) && (isAttribute || roundBracketLevel > 0) && isQuoted) {
      } else if (isRelation && wasWhitespace && !spaceAroundRelation) {
        stripped.pop();
        stripped.push(character);
      } else if (isRelation && !wasWhitespace && spaceAroundRelation) {
        stripped.push(Marker.SPACE);
        stripped.push(character);
      } else if (isWhitespace) {
        stripped.push(Marker.SPACE);
      } else {
        stripped.push(character);
      }
      wasEscaped = isEscaped;
      isEscaped = character == Marker.BACK_SLASH;
      wasRelation = isRelation;
      wasWhitespace = isWhitespace;
      wasComma = character == Marker.COMMA;
    }
    return withCaseAttribute ? stripped.join("").replace(CASE_RESTORE_PATTERN, "$1 $2]") : stripped.join("");
  };
  var isPseudoClassWithSelectors = function(value, colonPosition) {
    var pseudoClass = value.substring(colonPosition, value.indexOf(Marker.OPEN_ROUND_BRACKET, colonPosition));
    return PSEUDO_CLASSES_WITH_SELECTORS.indexOf(pseudoClass) > -1;
  };
  var removeQuotes = function(value) {
    if (value.indexOf("\'") == -1 && value.indexOf('"') == -1) {
      return value;
    }
    return value.replace(SINGLE_QUOTE_CASE_PATTERN, "=$1 $2").replace(SINGLE_QUOTE_PATTERN, "=$1$2").replace(DOUBLE_QUOTE_CASE_PATTERN, "=$1 $2").replace(DOUBLE_QUOTE_PATTERN, "=$1$2");
  };
  var tidyRules = function(rules, removeUnsupported, adjacentSpace, format, warnings) {
    var list = [];
    var repeated = [];
    function removeHTMLComment(rule2, match) {
      warnings.push("HTML comment \'" + match + "\' at " + formatPosition(rule2[2][0]) + ". Removing.");
      return "";
    }
    for (var i = 0, l2 = rules.length;i < l2; i++) {
      var rule = rules[i];
      var reduced = rule[1];
      reduced = reduced.replace(HTML_COMMENT_PATTERN, removeHTMLComment.bind(null, rule));
      if (hasInvalidCharacters(reduced)) {
        warnings.push("Invalid selector \'" + rule[1] + "\' at " + formatPosition(rule[2][0]) + ". Ignoring.");
        continue;
      }
      reduced = removeWhitespace(reduced, format);
      reduced = removeQuotes(reduced);
      if (adjacentSpace && reduced.indexOf("nav") > 0) {
        reduced = reduced.replace(/\+nav(\S|$)/, "+ nav$1");
      }
      if (removeUnsupported && reduced.indexOf(ASTERISK_PLUS_HTML_HACK) > -1) {
        continue;
      }
      if (removeUnsupported && reduced.indexOf(ASTERISK_FIRST_CHILD_PLUS_HTML_HACK) > -1) {
        continue;
      }
      if (reduced.indexOf("*") > -1) {
        reduced = reduced.replace(/\*([:#\.\[])/g, "$1").replace(/^(\:first\-child)?\+html/, "*$1+html");
      }
      if (repeated.indexOf(reduced) > -1) {
        continue;
      }
      rule[1] = reduced;
      repeated.push(reduced);
      list.push(rule);
    }
    if (list.length == 1 && list[0][1].length === 0) {
      warnings.push("Empty selector \'" + list[0][1] + "\' at " + formatPosition(list[0][2][0]) + ". Ignoring.");
      list = [];
    }
    return list;
  };
  var Spaces = require_format().Spaces;
  var Marker = require_marker();
  var formatPosition = require_format_position();
  var CASE_ATTRIBUTE_PATTERN = /[\s"'][iI]\s*\]/;
  var CASE_RESTORE_PATTERN = /([\d\w])([iI])\]/g;
  var DOUBLE_QUOTE_CASE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"([iI])/g;
  var DOUBLE_QUOTE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"(\s|\])/g;
  var HTML_COMMENT_PATTERN = /^(?:(?:<!--|-->)\s*)+/;
  var SINGLE_QUOTE_CASE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'([iI])/g;
  var SINGLE_QUOTE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'(\s|\])/g;
  var RELATION_PATTERN = /[>\+~]/;
  var WHITESPACE_PATTERN = /\s/;
  var ASTERISK_PLUS_HTML_HACK = "*+html ";
  var ASTERISK_FIRST_CHILD_PLUS_HTML_HACK = "*:first-child+html ";
  var LESS_THAN = "<";
  var PSEUDO_CLASSES_WITH_SELECTORS = [
    ":current",
    ":future",
    ":has",
    ":host",
    ":host-context",
    ":is",
    ":not",
    ":past",
    ":where"
  ];
  module.exports = tidyRules;
});

// node_modules/clean-css/lib/optimizer/level-1/tidy-block.js
var require_tidy_block = __commonJS((exports, module) => {
  var tidyBlock = function(values, spaceAfterClosingBrace) {
    var withoutSpaceAfterClosingBrace;
    var withoutQuotes;
    var i;
    for (i = values.length - 1;i >= 0; i--) {
      withoutSpaceAfterClosingBrace = !spaceAfterClosingBrace && SUPPORTED_COMPACT_BLOCK_MATCHER.test(values[i][1]);
      withoutQuotes = SUPPORTED_QUOTE_REMOVAL_MATCHER.test(values[i][1]);
      values[i][1] = values[i][1].replace(/\n|\r\n/g, " ").replace(/\s+/g, " ").replace(/(,|:|\() /g, "$1").replace(/ \)/g, ")");
      if (withoutQuotes) {
        values[i][1] = values[i][1].replace(/'([a-zA-Z][a-zA-Z\d\-_]+)'/, "$1").replace(/"([a-zA-Z][a-zA-Z\d\-_]+)"/, "$1");
      }
      if (withoutSpaceAfterClosingBrace) {
        values[i][1] = values[i][1].replace(/\) /g, ")");
      }
    }
    return values;
  };
  var SUPPORTED_COMPACT_BLOCK_MATCHER = /^@media\W/;
  var SUPPORTED_QUOTE_REMOVAL_MATCHER = /^@(?:keyframes|-moz-keyframes|-o-keyframes|-webkit-keyframes)\W/;
  module.exports = tidyBlock;
});

// node_modules/clean-css/lib/optimizer/level-1/tidy-at-rule.js
var require_tidy_at_rule = __commonJS((exports, module) => {
  var tidyAtRule = function(value) {
    return value.replace(/\s+/g, " ").replace(/url\(\s+/g, "url(").replace(/\s+\)/g, ")").trim();
  };
  module.exports = tidyAtRule;
});

// node_modules/clean-css/lib/optimizer/hack.js
var require_hack = __commonJS((exports, module) => {
  var Hack = {
    ASTERISK: "asterisk",
    BANG: "bang",
    BACKSLASH: "backslash",
    UNDERSCORE: "underscore"
  };
  module.exports = Hack;
});

// node_modules/clean-css/lib/optimizer/remove-unused.js
var require_remove_unused = __commonJS((exports, module) => {
  var removeUnused = function(properties) {
    for (var i = properties.length - 1;i >= 0; i--) {
      var property = properties[i];
      if (property.unused) {
        property.all.splice(property.position, 1);
      }
    }
  };
  module.exports = removeUnused;
});

// node_modules/clean-css/lib/optimizer/restore-from-optimizing.js
var require_restore_from_optimizing = __commonJS((exports, module) => {
  var restoreFromOptimizing = function(properties, restoreCallback) {
    var property;
    var restored;
    var current;
    var i;
    for (i = properties.length - 1;i >= 0; i--) {
      property = properties[i];
      if (property.dynamic && property.important) {
        restoreImportant(property);
        continue;
      }
      if (property.dynamic) {
        continue;
      }
      if (property.unused) {
        continue;
      }
      if (!property.dirty && !property.important && !property.hack) {
        continue;
      }
      if (property.optimizable && restoreCallback) {
        restored = restoreCallback(property);
        property.value = restored;
      } else {
        restored = property.value;
      }
      if (property.important) {
        restoreImportant(property);
      }
      if (property.hack) {
        restoreHack(property);
      }
      if ("all" in property) {
        current = property.all[property.position];
        current[1][1] = property.name;
        current.splice(2, current.length - 1);
        Array.prototype.push.apply(current, restored);
      }
    }
  };
  var restoreImportant = function(property) {
    property.value[property.value.length - 1][1] += IMPORTANT_TOKEN;
  };
  var restoreHack = function(property) {
    if (property.hack[0] == Hack.UNDERSCORE) {
      property.name = UNDERSCORE_HACK + property.name;
    } else if (property.hack[0] == Hack.ASTERISK) {
      property.name = ASTERISK_HACK + property.name;
    } else if (property.hack[0] == Hack.BACKSLASH) {
      property.value[property.value.length - 1][1] += BACKSLASH_HACK + property.hack[1];
    } else if (property.hack[0] == Hack.BANG) {
      property.value[property.value.length - 1][1] += Marker.SPACE + BANG_HACK;
    }
  };
  var Hack = require_hack();
  var Marker = require_marker();
  var ASTERISK_HACK = "*";
  var BACKSLASH_HACK = "\\";
  var IMPORTANT_TOKEN = "!important";
  var UNDERSCORE_HACK = "_";
  var BANG_HACK = "!ie";
  module.exports = restoreFromOptimizing;
});

// node_modules/clean-css/lib/tokenizer/token.js
var require_token = __commonJS((exports, module) => {
  var Token = {
    AT_RULE: "at-rule",
    AT_RULE_BLOCK: "at-rule-block",
    AT_RULE_BLOCK_SCOPE: "at-rule-block-scope",
    COMMENT: "comment",
    NESTED_BLOCK: "nested-block",
    NESTED_BLOCK_SCOPE: "nested-block-scope",
    PROPERTY: "property",
    PROPERTY_BLOCK: "property-block",
    PROPERTY_NAME: "property-name",
    PROPERTY_VALUE: "property-value",
    RAW: "raw",
    RULE: "rule",
    RULE_SCOPE: "rule-scope"
  };
  module.exports = Token;
});

// node_modules/clean-css/lib/optimizer/wrap-for-optimizing.js
var require_wrap_for_optimizing = __commonJS((exports, module) => {
  var wrapAll = function(properties, skipProperties) {
    var wrapped = [];
    var single;
    var property;
    var i;
    for (i = properties.length - 1;i >= 0; i--) {
      property = properties[i];
      if (property[0] != Token.PROPERTY) {
        continue;
      }
      if (skipProperties && skipProperties.indexOf(property[1][1]) > -1) {
        continue;
      }
      single = wrapSingle(property);
      single.all = properties;
      single.position = i;
      wrapped.unshift(single);
    }
    return wrapped;
  };
  var someVariableReferences = function(property) {
    var i, l2;
    var value;
    for (i = 2, l2 = property.length;i < l2; i++) {
      value = property[i];
      if (value[0] != Token.PROPERTY_VALUE) {
        continue;
      }
      if (isVariableReference(value[1])) {
        return true;
      }
    }
    return false;
  };
  var isVariableReference = function(value) {
    return Match.VARIABLE_REFERENCE_PATTERN.test(value);
  };
  var isMultiplex = function(property) {
    var value;
    var i, l2;
    for (i = 3, l2 = property.length;i < l2; i++) {
      value = property[i];
      if (value[0] == Token.PROPERTY_VALUE && (value[1] == Marker.COMMA || value[1] == Marker.FORWARD_SLASH)) {
        return true;
      }
    }
    return false;
  };
  var hackFrom = function(property) {
    var match = false;
    var name = property[1][1];
    var lastValue = property[property.length - 1];
    if (name[0] == Match.UNDERSCORE) {
      match = [Hack.UNDERSCORE];
    } else if (name[0] == Match.ASTERISK) {
      match = [Hack.ASTERISK];
    } else if (lastValue[1][0] == Match.BANG && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN)) {
      match = [Hack.BANG];
    } else if (lastValue[1].indexOf(Match.BANG) > 0 && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN) && Match.BANG_SUFFIX_PATTERN.test(lastValue[1])) {
      match = [Hack.BANG];
    } else if (lastValue[1].indexOf(Match.BACKSLASH) > 0 && lastValue[1].indexOf(Match.BACKSLASH) == lastValue[1].length - Match.BACKSLASH.length - 1) {
      match = [Hack.BACKSLASH, lastValue[1].substring(lastValue[1].indexOf(Match.BACKSLASH) + 1)];
    } else if (lastValue[1].indexOf(Match.BACKSLASH) === 0 && lastValue[1].length == 2) {
      match = [Hack.BACKSLASH, lastValue[1].substring(1)];
    }
    return match;
  };
  var isImportant = function(property) {
    if (property.length < 3)
      return false;
    var lastValue = property[property.length - 1];
    if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
      return true;
    } else if (Match.IMPORTANT_WORD_PATTERN.test(lastValue[1]) && Match.SUFFIX_BANG_PATTERN.test(property[property.length - 2][1])) {
      return true;
    }
    return false;
  };
  var stripImportant = function(property) {
    var lastValue = property[property.length - 1];
    var oneButLastValue = property[property.length - 2];
    if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
      lastValue[1] = lastValue[1].replace(Match.IMPORTANT_TOKEN_PATTERN, "");
    } else {
      lastValue[1] = lastValue[1].replace(Match.IMPORTANT_WORD_PATTERN, "");
      oneButLastValue[1] = oneButLastValue[1].replace(Match.SUFFIX_BANG_PATTERN, "");
    }
    if (lastValue[1].length === 0) {
      property.pop();
    }
    if (oneButLastValue[1].length === 0) {
      property.pop();
    }
  };
  var stripPrefixHack = function(property) {
    property[1][1] = property[1][1].substring(1);
  };
  var stripSuffixHack = function(property, hackFrom2) {
    var lastValue = property[property.length - 1];
    lastValue[1] = lastValue[1].substring(0, lastValue[1].indexOf(hackFrom2[0] == Hack.BACKSLASH ? Match.BACKSLASH : Match.BANG)).trim();
    if (lastValue[1].length === 0) {
      property.pop();
    }
  };
  var wrapSingle = function(property) {
    var importantProperty = isImportant(property);
    if (importantProperty) {
      stripImportant(property);
    }
    var whichHack = hackFrom(property);
    if (whichHack[0] == Hack.ASTERISK || whichHack[0] == Hack.UNDERSCORE) {
      stripPrefixHack(property);
    } else if (whichHack[0] == Hack.BACKSLASH || whichHack[0] == Hack.BANG) {
      stripSuffixHack(property, whichHack);
    }
    return {
      block: property[2] && property[2][0] == Token.PROPERTY_BLOCK,
      components: [],
      dirty: false,
      dynamic: someVariableReferences(property),
      hack: whichHack,
      important: importantProperty,
      name: property[1][1],
      multiplex: property.length > 3 ? isMultiplex(property) : false,
      optimizable: true,
      position: 0,
      shorthand: false,
      unused: false,
      value: property.slice(2)
    };
  };
  var Hack = require_hack();
  var Marker = require_marker();
  var Token = require_token();
  var Match = {
    ASTERISK: "*",
    BACKSLASH: "\\",
    BANG: "!",
    BANG_SUFFIX_PATTERN: /!\w+$/,
    IMPORTANT_TOKEN: "!important",
    IMPORTANT_TOKEN_PATTERN: new RegExp("!important$", "i"),
    IMPORTANT_WORD: "important",
    IMPORTANT_WORD_PATTERN: new RegExp("important$", "i"),
    SUFFIX_BANG_PATTERN: /!$/,
    UNDERSCORE: "_",
    VARIABLE_REFERENCE_PATTERN: /var\(--.+\)$/
  };
  module.exports = {
    all: wrapAll,
    single: wrapSingle
  };
});

// node_modules/clean-css/lib/optimizer/invalid-property-error.js
var require_invalid_property_error = __commonJS((exports, module) => {
  var InvalidPropertyError = function(message) {
    this.name = "InvalidPropertyError";
    this.message = message;
    this.stack = new Error().stack;
  };
  InvalidPropertyError.prototype = Object.create(Error.prototype);
  InvalidPropertyError.prototype.constructor = InvalidPropertyError;
  module.exports = InvalidPropertyError;
});

// node_modules/clean-css/lib/optimizer/configuration/break-up.js
var require_break_up = __commonJS((exports, module) => {
  var _anyIsInherit = function(values) {
    var i, l2;
    for (i = 0, l2 = values.length;i < l2; i++) {
      if (values[i][1] == "inherit") {
        return true;
      }
    }
    return false;
  };
  var _colorFilter = function(validator) {
    return function(value) {
      return value[1] == "invert" || validator.isColor(value[1]) || validator.isPrefixed(value[1]);
    };
  };
  var _styleFilter = function(validator) {
    return function(value) {
      return value[1] != "inherit" && validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);
    };
  };
  var _wrapDefault = function(name, property, configuration) {
    var descriptor = configuration[name];
    if (descriptor.doubleValues && descriptor.defaultValue.length == 2) {
      return wrapSingle([
        Token.PROPERTY,
        [Token.PROPERTY_NAME, name],
        [Token.PROPERTY_VALUE, descriptor.defaultValue[0]],
        [Token.PROPERTY_VALUE, descriptor.defaultValue[1]]
      ]);
    } else if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
      return wrapSingle([
        Token.PROPERTY,
        [Token.PROPERTY_NAME, name],
        [Token.PROPERTY_VALUE, descriptor.defaultValue[0]]
      ]);
    } else {
      return wrapSingle([
        Token.PROPERTY,
        [Token.PROPERTY_NAME, name],
        [Token.PROPERTY_VALUE, descriptor.defaultValue]
      ]);
    }
  };
  var _widthFilter = function(validator) {
    return function(value) {
      return value[1] != "inherit" && (validator.isWidth(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1])) && !validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);
    };
  };
  var animation = function(property, configuration, validator) {
    var duration = _wrapDefault(property.name + "-duration", property, configuration);
    var timing = _wrapDefault(property.name + "-timing-function", property, configuration);
    var delay = _wrapDefault(property.name + "-delay", property, configuration);
    var iteration = _wrapDefault(property.name + "-iteration-count", property, configuration);
    var direction = _wrapDefault(property.name + "-direction", property, configuration);
    var fill = _wrapDefault(property.name + "-fill-mode", property, configuration);
    var play = _wrapDefault(property.name + "-play-state", property, configuration);
    var name = _wrapDefault(property.name + "-name", property, configuration);
    var components = [duration, timing, delay, iteration, direction, fill, play, name];
    var values = property.value;
    var value;
    var durationSet = false;
    var timingSet = false;
    var delaySet = false;
    var iterationSet = false;
    var directionSet = false;
    var fillSet = false;
    var playSet = false;
    var nameSet = false;
    var i;
    var l2;
    if (property.value.length == 1 && property.value[0][1] == "inherit") {
      duration.value = timing.value = delay.value = iteration.value = direction.value = fill.value = play.value = name.value = property.value;
      return components;
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError("Invalid animation values at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    for (i = 0, l2 = values.length;i < l2; i++) {
      value = values[i];
      if (validator.isTime(value[1]) && !durationSet) {
        duration.value = [value];
        durationSet = true;
      } else if (validator.isTime(value[1]) && !delaySet) {
        delay.value = [value];
        delaySet = true;
      } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
        timing.value = [value];
        timingSet = true;
      } else if ((validator.isAnimationIterationCountKeyword(value[1]) || validator.isPositiveNumber(value[1])) && !iterationSet) {
        iteration.value = [value];
        iterationSet = true;
      } else if (validator.isAnimationDirectionKeyword(value[1]) && !directionSet) {
        direction.value = [value];
        directionSet = true;
      } else if (validator.isAnimationFillModeKeyword(value[1]) && !fillSet) {
        fill.value = [value];
        fillSet = true;
      } else if (validator.isAnimationPlayStateKeyword(value[1]) && !playSet) {
        play.value = [value];
        playSet = true;
      } else if ((validator.isAnimationNameKeyword(value[1]) || validator.isIdentifier(value[1])) && !nameSet) {
        name.value = [value];
        nameSet = true;
      } else {
        throw new InvalidPropertyError("Invalid animation value at " + formatPosition(value[2][0]) + ". Ignoring.");
      }
    }
    return components;
  };
  var background = function(property, configuration, validator) {
    var image = _wrapDefault("background-image", property, configuration);
    var position = _wrapDefault("background-position", property, configuration);
    var size = _wrapDefault("background-size", property, configuration);
    var repeat = _wrapDefault("background-repeat", property, configuration);
    var attachment = _wrapDefault("background-attachment", property, configuration);
    var origin = _wrapDefault("background-origin", property, configuration);
    var clip = _wrapDefault("background-clip", property, configuration);
    var color = _wrapDefault("background-color", property, configuration);
    var components = [image, position, size, repeat, attachment, origin, clip, color];
    var values = property.value;
    var positionSet = false;
    var clipSet = false;
    var originSet = false;
    var repeatSet = false;
    var anyValueSet = false;
    if (property.value.length == 1 && property.value[0][1] == "inherit") {
      color.value = image.value = repeat.value = position.value = size.value = origin.value = clip.value = property.value;
      return components;
    }
    if (property.value.length == 1 && property.value[0][1] == "0 0") {
      return components;
    }
    for (var i = values.length - 1;i >= 0; i--) {
      var value = values[i];
      if (validator.isBackgroundAttachmentKeyword(value[1])) {
        attachment.value = [value];
        anyValueSet = true;
      } else if (validator.isBackgroundClipKeyword(value[1]) || validator.isBackgroundOriginKeyword(value[1])) {
        if (clipSet) {
          origin.value = [value];
          originSet = true;
        } else {
          clip.value = [value];
          clipSet = true;
        }
        anyValueSet = true;
      } else if (validator.isBackgroundRepeatKeyword(value[1])) {
        if (repeatSet) {
          repeat.value.unshift(value);
        } else {
          repeat.value = [value];
          repeatSet = true;
        }
        anyValueSet = true;
      } else if (validator.isBackgroundPositionKeyword(value[1]) || validator.isBackgroundSizeKeyword(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1])) {
        if (i > 0) {
          var previousValue = values[i - 1];
          if (previousValue[1] == Marker.FORWARD_SLASH) {
            size.value = [value];
          } else if (i > 1 && values[i - 2][1] == Marker.FORWARD_SLASH) {
            size.value = [previousValue, value];
            i -= 2;
          } else {
            if (!positionSet)
              position.value = [];
            position.value.unshift(value);
            positionSet = true;
          }
        } else {
          if (!positionSet)
            position.value = [];
          position.value.unshift(value);
          positionSet = true;
        }
        anyValueSet = true;
      } else if ((color.value[0][1] == configuration[color.name].defaultValue || color.value[0][1] == "none") && (validator.isColor(value[1]) || validator.isPrefixed(value[1]))) {
        color.value = [value];
        anyValueSet = true;
      } else if (validator.isUrl(value[1]) || validator.isFunction(value[1])) {
        image.value = [value];
        anyValueSet = true;
      }
    }
    if (clipSet && !originSet)
      origin.value = clip.value.slice(0);
    if (!anyValueSet) {
      throw new InvalidPropertyError("Invalid background value at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    return components;
  };
  var borderRadius = function(property, configuration) {
    var values = property.value;
    var splitAt = -1;
    for (var i = 0, l2 = values.length;i < l2; i++) {
      if (values[i][1] == Marker.FORWARD_SLASH) {
        splitAt = i;
        break;
      }
    }
    if (splitAt === 0 || splitAt === values.length - 1) {
      throw new InvalidPropertyError("Invalid border-radius value at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    var target = _wrapDefault(property.name, property, configuration);
    target.value = splitAt > -1 ? values.slice(0, splitAt) : values.slice(0);
    target.components = fourValues(target, configuration);
    var remainder = _wrapDefault(property.name, property, configuration);
    remainder.value = splitAt > -1 ? values.slice(splitAt + 1) : values.slice(0);
    remainder.components = fourValues(remainder, configuration);
    for (var j2 = 0;j2 < 4; j2++) {
      target.components[j2].multiplex = true;
      target.components[j2].value = target.components[j2].value.concat(remainder.components[j2].value);
    }
    return target.components;
  };
  var font = function(property, configuration, validator) {
    var style = _wrapDefault("font-style", property, configuration);
    var variant = _wrapDefault("font-variant", property, configuration);
    var weight = _wrapDefault("font-weight", property, configuration);
    var stretch = _wrapDefault("font-stretch", property, configuration);
    var size = _wrapDefault("font-size", property, configuration);
    var height = _wrapDefault("line-height", property, configuration);
    var family = _wrapDefault("font-family", property, configuration);
    var components = [style, variant, weight, stretch, size, height, family];
    var values = property.value;
    var fuzzyMatched = 4;
    var index = 0;
    var isStretchSet = false;
    var isStretchValid;
    var isStyleSet = false;
    var isStyleValid;
    var isVariantSet = false;
    var isVariantValid;
    var isWeightSet = false;
    var isWeightValid;
    var appendableFamilyName = false;
    if (!values[index]) {
      throw new InvalidPropertyError("Missing font values at " + formatPosition(property.all[property.position][1][2][0]) + ". Ignoring.");
    }
    if (values.length == 1 && values[0][1] == "inherit") {
      style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
      return components;
    }
    if (values.length == 1 && (validator.isFontKeyword(values[0][1]) || validator.isGlobal(values[0][1]) || validator.isPrefixed(values[0][1]))) {
      values[0][1] = Marker.INTERNAL + values[0][1];
      style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
      return components;
    }
    if (values.length < 2 || !_anyIsFontSize(values, validator) || !_anyIsFontFamily(values, validator)) {
      throw new InvalidPropertyError("Invalid font values at " + formatPosition(property.all[property.position][1][2][0]) + ". Ignoring.");
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError("Invalid font values at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    while (index < fuzzyMatched) {
      isStretchValid = validator.isFontStretchKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isStyleValid = validator.isFontStyleKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isVariantValid = validator.isFontVariantKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isWeightValid = validator.isFontWeightKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      if (isStyleValid && !isStyleSet) {
        style.value = [values[index]];
        isStyleSet = true;
      } else if (isVariantValid && !isVariantSet) {
        variant.value = [values[index]];
        isVariantSet = true;
      } else if (isWeightValid && !isWeightSet) {
        weight.value = [values[index]];
        isWeightSet = true;
      } else if (isStretchValid && !isStretchSet) {
        stretch.value = [values[index]];
        isStretchSet = true;
      } else if (isStyleValid && isStyleSet || isVariantValid && isVariantSet || isWeightValid && isWeightSet || isStretchValid && isStretchSet) {
        throw new InvalidPropertyError("Invalid font style / variant / weight / stretch value at " + formatPosition(values[0][2][0]) + ". Ignoring.");
      } else {
        break;
      }
      index++;
    }
    if (validator.isFontSizeKeyword(values[index][1]) || validator.isUnit(values[index][1]) && !validator.isDynamicUnit(values[index][1])) {
      size.value = [values[index]];
      index++;
    } else {
      throw new InvalidPropertyError("Missing font size at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    if (!values[index]) {
      throw new InvalidPropertyError("Missing font family at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    if (values[index] && values[index][1] == Marker.FORWARD_SLASH && values[index + 1] && (validator.isLineHeightKeyword(values[index + 1][1]) || validator.isUnit(values[index + 1][1]) || validator.isNumber(values[index + 1][1]))) {
      height.value = [values[index + 1]];
      index++;
      index++;
    }
    family.value = [];
    while (values[index]) {
      if (values[index][1] == Marker.COMMA) {
        appendableFamilyName = false;
      } else {
        if (appendableFamilyName) {
          family.value[family.value.length - 1][1] += Marker.SPACE + values[index][1];
        } else {
          family.value.push(values[index]);
        }
        appendableFamilyName = true;
      }
      index++;
    }
    if (family.value.length === 0) {
      throw new InvalidPropertyError("Missing font family at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    return components;
  };
  var _anyIsFontSize = function(values, validator) {
    var value;
    var i, l2;
    for (i = 0, l2 = values.length;i < l2; i++) {
      value = values[i];
      if (validator.isFontSizeKeyword(value[1]) || validator.isUnit(value[1]) && !validator.isDynamicUnit(value[1]) || validator.isFunction(value[1])) {
        return true;
      }
    }
    return false;
  };
  var _anyIsFontFamily = function(values, validator) {
    var value;
    var i, l2;
    for (i = 0, l2 = values.length;i < l2; i++) {
      value = values[i];
      if (validator.isIdentifier(value[1]) || validator.isQuotedText(value[1])) {
        return true;
      }
    }
    return false;
  };
  var fourValues = function(property, configuration) {
    var componentNames = configuration[property.name].components;
    var components = [];
    var value = property.value;
    if (value.length < 1)
      return [];
    if (value.length < 2)
      value[1] = value[0].slice(0);
    if (value.length < 3)
      value[2] = value[0].slice(0);
    if (value.length < 4)
      value[3] = value[1].slice(0);
    for (var i = componentNames.length - 1;i >= 0; i--) {
      var component = wrapSingle([
        Token.PROPERTY,
        [Token.PROPERTY_NAME, componentNames[i]]
      ]);
      component.value = [value[i]];
      components.unshift(component);
    }
    return components;
  };
  var multiplex = function(splitWith) {
    return function(property, configuration, validator) {
      var splitsAt = [];
      var values = property.value;
      var i, j2, l2, m2;
      for (i = 0, l2 = values.length;i < l2; i++) {
        if (values[i][1] == ",")
          splitsAt.push(i);
      }
      if (splitsAt.length === 0)
        return splitWith(property, configuration, validator);
      var splitComponents = [];
      for (i = 0, l2 = splitsAt.length;i <= l2; i++) {
        var from = i === 0 ? 0 : splitsAt[i - 1] + 1;
        var to = i < l2 ? splitsAt[i] : values.length;
        var _property = _wrapDefault(property.name, property, configuration);
        _property.value = values.slice(from, to);
        if (_property.value.length > 0) {
          splitComponents.push(splitWith(_property, configuration, validator));
        }
      }
      var components = splitComponents[0];
      for (i = 0, l2 = components.length;i < l2; i++) {
        components[i].multiplex = true;
        for (j2 = 1, m2 = splitComponents.length;j2 < m2; j2++) {
          components[i].value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
          Array.prototype.push.apply(components[i].value, splitComponents[j2][i].value);
        }
      }
      return components;
    };
  };
  var listStyle = function(property, configuration, validator) {
    var type = _wrapDefault("list-style-type", property, configuration);
    var position = _wrapDefault("list-style-position", property, configuration);
    var image = _wrapDefault("list-style-image", property, configuration);
    var components = [type, position, image];
    if (property.value.length == 1 && property.value[0][1] == "inherit") {
      type.value = position.value = image.value = [property.value[0]];
      return components;
    }
    var values = property.value.slice(0);
    var total = values.length;
    var index = 0;
    for (index = 0, total = values.length;index < total; index++) {
      if (validator.isUrl(values[index][1]) || values[index][1] == "0") {
        image.value = [values[index]];
        values.splice(index, 1);
        break;
      }
    }
    for (index = 0, total = values.length;index < total; index++) {
      if (validator.isListStylePositionKeyword(values[index][1])) {
        position.value = [values[index]];
        values.splice(index, 1);
        break;
      }
    }
    if (values.length > 0 && (validator.isListStyleTypeKeyword(values[0][1]) || validator.isIdentifier(values[0][1]))) {
      type.value = [values[0]];
    }
    return components;
  };
  var transition = function(property, configuration, validator) {
    var prop = _wrapDefault(property.name + "-property", property, configuration);
    var duration = _wrapDefault(property.name + "-duration", property, configuration);
    var timing = _wrapDefault(property.name + "-timing-function", property, configuration);
    var delay = _wrapDefault(property.name + "-delay", property, configuration);
    var components = [prop, duration, timing, delay];
    var values = property.value;
    var value;
    var durationSet = false;
    var delaySet = false;
    var propSet = false;
    var timingSet = false;
    var i;
    var l2;
    if (property.value.length == 1 && property.value[0][1] == "inherit") {
      prop.value = duration.value = timing.value = delay.value = property.value;
      return components;
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError("Invalid animation values at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    for (i = 0, l2 = values.length;i < l2; i++) {
      value = values[i];
      if (validator.isTime(value[1]) && !durationSet) {
        duration.value = [value];
        durationSet = true;
      } else if (validator.isTime(value[1]) && !delaySet) {
        delay.value = [value];
        delaySet = true;
      } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
        timing.value = [value];
        timingSet = true;
      } else if (validator.isIdentifier(value[1]) && !propSet) {
        prop.value = [value];
        propSet = true;
      } else {
        throw new InvalidPropertyError("Invalid animation value at " + formatPosition(value[2][0]) + ". Ignoring.");
      }
    }
    return components;
  };
  var widthStyleColor = function(property, configuration, validator) {
    var descriptor = configuration[property.name];
    var components = [
      _wrapDefault(descriptor.components[0], property, configuration),
      _wrapDefault(descriptor.components[1], property, configuration),
      _wrapDefault(descriptor.components[2], property, configuration)
    ];
    var color, style, width;
    for (var i = 0;i < 3; i++) {
      var component = components[i];
      if (component.name.indexOf("color") > 0)
        color = component;
      else if (component.name.indexOf("style") > 0)
        style = component;
      else
        width = component;
    }
    if (property.value.length == 1 && property.value[0][1] == "inherit" || property.value.length == 3 && property.value[0][1] == "inherit" && property.value[1][1] == "inherit" && property.value[2][1] == "inherit") {
      color.value = style.value = width.value = [property.value[0]];
      return components;
    }
    var values = property.value.slice(0);
    var match, matches;
    if (values.length > 0) {
      matches = values.filter(_widthFilter(validator));
      match = matches.length > 1 && (matches[0][1] == "none" || matches[0][1] == "auto") ? matches[1] : matches[0];
      if (match) {
        width.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    if (values.length > 0) {
      match = values.filter(_styleFilter(validator))[0];
      if (match) {
        style.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    if (values.length > 0) {
      match = values.filter(_colorFilter(validator))[0];
      if (match) {
        color.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    return components;
  };
  var InvalidPropertyError = require_invalid_property_error();
  var wrapSingle = require_wrap_for_optimizing().single;
  var Token = require_token();
  var Marker = require_marker();
  var formatPosition = require_format_position();
  module.exports = {
    animation,
    background,
    border: widthStyleColor,
    borderRadius,
    font,
    fourValues,
    listStyle,
    multiplex,
    outline: widthStyleColor,
    transition
  };
});

// node_modules/clean-css/lib/optimizer/vendor-prefixes.js
var require_vendor_prefixes = __commonJS((exports, module) => {
  var unique = function(value) {
    var prefixes = [];
    var match;
    while ((match = VENDOR_PREFIX_PATTERN.exec(value)) !== null) {
      if (prefixes.indexOf(match[0]) == -1) {
        prefixes.push(match[0]);
      }
    }
    return prefixes;
  };
  var same = function(value1, value2) {
    return unique(value1).sort().join(",") == unique(value2).sort().join(",");
  };
  var VENDOR_PREFIX_PATTERN = /(?:^|\W)(\-\w+\-)/g;
  module.exports = {
    unique,
    same
  };
});

// node_modules/clean-css/lib/optimizer/configuration/properties/understandable.js
var require_understandable = __commonJS((exports, module) => {
  var understandable = function(validator, value1, value2, _position, isPaired) {
    if (!sameVendorPrefixes(value1, value2)) {
      return false;
    }
    if (isPaired && validator.isVariable(value1) !== validator.isVariable(value2)) {
      return false;
    }
    return true;
  };
  var sameVendorPrefixes = require_vendor_prefixes().same;
  module.exports = understandable;
});

// node_modules/clean-css/lib/optimizer/configuration/can-override.js
var require_can_override = __commonJS((exports, module) => {
  var animationIterationCount = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2);
  };
  var animationName = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2);
  };
  var areSameFunction = function(validator, value1, value2) {
    if (!validator.isFunction(value1) || !validator.isFunction(value2)) {
      return false;
    }
    var function1Name = value1.substring(0, value1.indexOf("("));
    var function2Name = value2.substring(0, value2.indexOf("("));
    var function1Value = value1.substring(function1Name.length + 1, value1.length - 1);
    var function2Value = value2.substring(function2Name.length + 1, value2.length - 1);
    if (validator.isFunction(function1Value) || validator.isFunction(function2Value)) {
      return function1Name === function2Name && areSameFunction(validator, function1Value, function2Value);
    } else {
      return function1Name === function2Name;
    }
  };
  var backgroundPosition = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2)) {
      return true;
    }
    return unit(validator, value1, value2);
  };
  var backgroundSize = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2)) {
      return true;
    }
    return unit(validator, value1, value2);
  };
  var color = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isColor(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (!validator.colorOpacity && (validator.isRgbColor(value1) || validator.isHslColor(value1))) {
      return false;
    } else if (!validator.colorOpacity && (validator.isRgbColor(value2) || validator.isHslColor(value2))) {
      return false;
    } else if (!validator.colorHexAlpha && (validator.isHexAlphaColor(value1) || validator.isHexAlphaColor(value2))) {
      return false;
    } else if (validator.isColor(value1) && validator.isColor(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var components = function(overrideCheckers) {
    return function(validator, value1, value2, position) {
      return overrideCheckers[position](validator, value1, value2);
    };
  };
  var fontFamily = function(validator, value1, value2) {
    return understandable(validator, value1, value2, 0, true);
  };
  var image = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isImage(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isImage(value2)) {
      return true;
    } else if (validator.isImage(value1)) {
      return false;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var keyword = function(propertyName2) {
    return function(validator, value1, value2) {
      if (!understandable(validator, value1, value2, 0, true) && !validator.isKeyword(propertyName2)(value2)) {
        return false;
      } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
        return true;
      }
      return validator.isKeyword(propertyName2)(value2);
    };
  };
  var keywordWithGlobal = function(propertyName2) {
    return function(validator, value1, value2) {
      if (!understandable(validator, value1, value2, 0, true) && !(validator.isKeyword(propertyName2)(value2) || validator.isGlobal(value2))) {
        return false;
      } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
        return true;
      }
      return validator.isKeyword(propertyName2)(value2) || validator.isGlobal(value2);
    };
  };
  var propertyName = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isIdentifier(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isIdentifier(value2);
  };
  var sameFunctionOrValue = function(validator, value1, value2) {
    return areSameFunction(validator, value1, value2) ? true : value1 === value2;
  };
  var textShadow = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2);
  };
  var time = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isTime(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isTime(value1) && !validator.isTime(value2)) {
      return false;
    } else if (validator.isTime(value2)) {
      return true;
    } else if (validator.isTime(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var timingFunction = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isTimingFunction(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isTimingFunction(value2) || validator.isGlobal(value2);
  };
  var unit = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isUnit(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isUnit(value1) && !validator.isUnit(value2)) {
      return false;
    } else if (validator.isUnit(value2)) {
      return true;
    } else if (validator.isUnit(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var unitOrKeywordWithGlobal = function(propertyName2) {
    var byKeyword = keywordWithGlobal(propertyName2);
    return function(validator, value1, value2) {
      return unit(validator, value1, value2) || byKeyword(validator, value1, value2);
    };
  };
  var unitOrNumber = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isNumber(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if ((validator.isUnit(value1) || validator.isNumber(value1)) && !(validator.isUnit(value2) || validator.isNumber(value2))) {
      return false;
    } else if (validator.isUnit(value2) || validator.isNumber(value2)) {
      return true;
    } else if (validator.isUnit(value1) || validator.isNumber(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var zIndex = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isZIndex(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isZIndex(value2);
  };
  var understandable = require_understandable();
  module.exports = {
    generic: {
      color,
      components,
      image,
      propertyName,
      time,
      timingFunction,
      unit,
      unitOrNumber
    },
    property: {
      animationDirection: keywordWithGlobal("animation-direction"),
      animationFillMode: keyword("animation-fill-mode"),
      animationIterationCount,
      animationName,
      animationPlayState: keywordWithGlobal("animation-play-state"),
      backgroundAttachment: keyword("background-attachment"),
      backgroundClip: keywordWithGlobal("background-clip"),
      backgroundOrigin: keyword("background-origin"),
      backgroundPosition,
      backgroundRepeat: keyword("background-repeat"),
      backgroundSize,
      bottom: unitOrKeywordWithGlobal("bottom"),
      borderCollapse: keyword("border-collapse"),
      borderStyle: keywordWithGlobal("*-style"),
      clear: keywordWithGlobal("clear"),
      cursor: keywordWithGlobal("cursor"),
      display: keywordWithGlobal("display"),
      float: keywordWithGlobal("float"),
      left: unitOrKeywordWithGlobal("left"),
      fontFamily,
      fontStretch: keywordWithGlobal("font-stretch"),
      fontStyle: keywordWithGlobal("font-style"),
      fontVariant: keywordWithGlobal("font-variant"),
      fontWeight: keywordWithGlobal("font-weight"),
      listStyleType: keywordWithGlobal("list-style-type"),
      listStylePosition: keywordWithGlobal("list-style-position"),
      outlineStyle: keywordWithGlobal("*-style"),
      overflow: keywordWithGlobal("overflow"),
      position: keywordWithGlobal("position"),
      right: unitOrKeywordWithGlobal("right"),
      textAlign: keywordWithGlobal("text-align"),
      textDecoration: keywordWithGlobal("text-decoration"),
      textOverflow: keywordWithGlobal("text-overflow"),
      textShadow,
      top: unitOrKeywordWithGlobal("top"),
      transform: sameFunctionOrValue,
      verticalAlign: unitOrKeywordWithGlobal("vertical-align"),
      visibility: keywordWithGlobal("visibility"),
      whiteSpace: keywordWithGlobal("white-space"),
      zIndex
    }
  };
});

// node_modules/clean-css/lib/optimizer/clone.js
var require_clone = __commonJS((exports, module) => {
  var deep = function(property) {
    var cloned = shallow(property);
    for (var i = property.components.length - 1;i >= 0; i--) {
      var component = shallow(property.components[i]);
      component.value = property.components[i].value.slice(0);
      cloned.components.unshift(component);
    }
    cloned.dirty = true;
    cloned.value = property.value.slice(0);
    return cloned;
  };
  var shallow = function(property) {
    var cloned = wrapSingle([
      Token.PROPERTY,
      [Token.PROPERTY_NAME, property.name]
    ]);
    cloned.important = property.important;
    cloned.hack = property.hack;
    cloned.unused = false;
    return cloned;
  };
  var wrapSingle = require_wrap_for_optimizing().single;
  var Token = require_token();
  module.exports = {
    deep,
    shallow
  };
});

// node_modules/clean-css/lib/optimizer/configuration/restore.js
var require_restore = __commonJS((exports, module) => {
  var isInheritOnly = function(values) {
    for (var i = 0, l2 = values.length;i < l2; i++) {
      var value = values[i][1];
      if (value != "inherit" && value != Marker.COMMA && value != Marker.FORWARD_SLASH)
        return false;
    }
    return true;
  };
  var background = function(property, configuration, lastInMultiplex) {
    var components = property.components;
    var restored = [];
    var needsOne, needsBoth;
    function restoreValue(component2) {
      Array.prototype.unshift.apply(restored, component2.value);
    }
    function isDefaultValue(component2) {
      var descriptor = configuration[component2.name];
      if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
        return component2.value[0][1] == descriptor.defaultValue[0] && (component2.value[1] ? component2.value[1][1] == descriptor.defaultValue[0] : true);
      } else if (descriptor.doubleValues && descriptor.defaultValue.length != 1) {
        return component2.value[0][1] == descriptor.defaultValue[0] && (component2.value[1] ? component2.value[1][1] : component2.value[0][1]) == descriptor.defaultValue[1];
      } else {
        return component2.value[0][1] == descriptor.defaultValue;
      }
    }
    for (var i = components.length - 1;i >= 0; i--) {
      var component = components[i];
      var isDefault2 = isDefaultValue(component);
      if (component.name == "background-clip") {
        var originComponent = components[i - 1];
        var isOriginDefault = isDefaultValue(originComponent);
        needsOne = component.value[0][1] == originComponent.value[0][1];
        needsBoth = !needsOne && (isOriginDefault && !isDefault2 || !isOriginDefault && !isDefault2 || !isOriginDefault && isDefault2 && component.value[0][1] != originComponent.value[0][1]);
        if (needsOne) {
          restoreValue(originComponent);
        } else if (needsBoth) {
          restoreValue(component);
          restoreValue(originComponent);
        }
        i--;
      } else if (component.name == "background-size") {
        var positionComponent = components[i - 1];
        var isPositionDefault = isDefaultValue(positionComponent);
        needsOne = !isPositionDefault && isDefault2;
        needsBoth = !needsOne && (isPositionDefault && !isDefault2 || !isPositionDefault && !isDefault2);
        if (needsOne) {
          restoreValue(positionComponent);
        } else if (needsBoth) {
          restoreValue(component);
          restored.unshift([Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]);
          restoreValue(positionComponent);
        } else if (positionComponent.value.length == 1) {
          restoreValue(positionComponent);
        }
        i--;
      } else {
        if (isDefault2 || configuration[component.name].multiplexLastOnly && !lastInMultiplex)
          continue;
        restoreValue(component);
      }
    }
    if (restored.length === 0 && property.value.length == 1 && property.value[0][1] == "0")
      restored.push(property.value[0]);
    if (restored.length === 0)
      restored.push([Token.PROPERTY_VALUE, configuration[property.name].defaultValue]);
    if (isInheritOnly(restored))
      return [restored[0]];
    return restored;
  };
  var borderRadius = function(property) {
    if (property.multiplex) {
      var horizontal = shallowClone(property);
      var vertical = shallowClone(property);
      for (var i = 0;i < 4; i++) {
        var component = property.components[i];
        var horizontalComponent = shallowClone(property);
        horizontalComponent.value = [component.value[0]];
        horizontal.components.push(horizontalComponent);
        var verticalComponent = shallowClone(property);
        verticalComponent.value = [component.value[1] || component.value[0]];
        vertical.components.push(verticalComponent);
      }
      var horizontalValues = fourValues(horizontal);
      var verticalValues = fourValues(vertical);
      if (horizontalValues.length == verticalValues.length && horizontalValues[0][1] == verticalValues[0][1] && (horizontalValues.length > 1 ? horizontalValues[1][1] == verticalValues[1][1] : true) && (horizontalValues.length > 2 ? horizontalValues[2][1] == verticalValues[2][1] : true) && (horizontalValues.length > 3 ? horizontalValues[3][1] == verticalValues[3][1] : true)) {
        return horizontalValues;
      } else {
        return horizontalValues.concat([[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]).concat(verticalValues);
      }
    } else {
      return fourValues(property);
    }
  };
  var font = function(property, configuration) {
    var components = property.components;
    var restored = [];
    var component;
    var componentIndex = 0;
    var fontFamilyIndex = 0;
    if (property.value[0][1].indexOf(Marker.INTERNAL) === 0) {
      property.value[0][1] = property.value[0][1].substring(Marker.INTERNAL.length);
      return property.value;
    }
    while (componentIndex < 4) {
      component = components[componentIndex];
      if (component.value[0][1] != configuration[component.name].defaultValue) {
        Array.prototype.push.apply(restored, component.value);
      }
      componentIndex++;
    }
    Array.prototype.push.apply(restored, components[componentIndex].value);
    componentIndex++;
    if (components[componentIndex].value[0][1] != configuration[components[componentIndex].name].defaultValue) {
      Array.prototype.push.apply(restored, [[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]);
      Array.prototype.push.apply(restored, components[componentIndex].value);
    }
    componentIndex++;
    while (components[componentIndex].value[fontFamilyIndex]) {
      restored.push(components[componentIndex].value[fontFamilyIndex]);
      if (components[componentIndex].value[fontFamilyIndex + 1]) {
        restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      }
      fontFamilyIndex++;
    }
    if (isInheritOnly(restored)) {
      return [restored[0]];
    }
    return restored;
  };
  var fourValues = function(property) {
    var components = property.components;
    var value1 = components[0].value[0];
    var value2 = components[1].value[0];
    var value3 = components[2].value[0];
    var value4 = components[3].value[0];
    if (value1[1] == value2[1] && value1[1] == value3[1] && value1[1] == value4[1]) {
      return [value1];
    } else if (value1[1] == value3[1] && value2[1] == value4[1]) {
      return [value1, value2];
    } else if (value2[1] == value4[1]) {
      return [value1, value2, value3];
    } else {
      return [value1, value2, value3, value4];
    }
  };
  var multiplex = function(restoreWith) {
    return function(property, configuration) {
      if (!property.multiplex)
        return restoreWith(property, configuration, true);
      var multiplexSize = 0;
      var restored = [];
      var componentMultiplexSoFar = {};
      var i, l2;
      for (i = 0, l2 = property.components[0].value.length;i < l2; i++) {
        if (property.components[0].value[i][1] == Marker.COMMA)
          multiplexSize++;
      }
      for (i = 0;i <= multiplexSize; i++) {
        var _property = shallowClone(property);
        for (var j2 = 0, m2 = property.components.length;j2 < m2; j2++) {
          var componentToClone = property.components[j2];
          var _component = shallowClone(componentToClone);
          _property.components.push(_component);
          for (var k2 = componentMultiplexSoFar[_component.name] || 0, n = componentToClone.value.length;k2 < n; k2++) {
            if (componentToClone.value[k2][1] == Marker.COMMA) {
              componentMultiplexSoFar[_component.name] = k2 + 1;
              break;
            }
            _component.value.push(componentToClone.value[k2]);
          }
        }
        var lastInMultiplex = i == multiplexSize;
        var _restored = restoreWith(_property, configuration, lastInMultiplex);
        Array.prototype.push.apply(restored, _restored);
        if (i < multiplexSize)
          restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      }
      return restored;
    };
  };
  var withoutDefaults = function(property, configuration) {
    var components = property.components;
    var restored = [];
    for (var i = components.length - 1;i >= 0; i--) {
      var component = components[i];
      var descriptor = configuration[component.name];
      if (component.value[0][1] != descriptor.defaultValue || "keepUnlessDefault" in descriptor && !isDefault(components, configuration, descriptor.keepUnlessDefault)) {
        restored.unshift(component.value[0]);
      }
    }
    if (restored.length === 0)
      restored.push([Token.PROPERTY_VALUE, configuration[property.name].defaultValue]);
    if (isInheritOnly(restored))
      return [restored[0]];
    return restored;
  };
  var isDefault = function(components, configuration, propertyName) {
    var component;
    var i, l2;
    for (i = 0, l2 = components.length;i < l2; i++) {
      component = components[i];
      if (component.name == propertyName && component.value[0][1] == configuration[propertyName].defaultValue) {
        return true;
      }
    }
    return false;
  };
  var shallowClone = require_clone().shallow;
  var Token = require_token();
  var Marker = require_marker();
  module.exports = {
    background,
    borderRadius,
    font,
    fourValues,
    multiplex,
    withoutDefaults
  };
});

// node_modules/clean-css/lib/options/rounding-precision.js
var require_rounding_precision = __commonJS((exports, module) => {
  var roundingPrecisionFrom = function(source) {
    return override(defaults2(DEFAULT_PRECISION), buildPrecisionFrom(source));
  };
  var defaults2 = function(value) {
    return {
      ch: value,
      cm: value,
      em: value,
      ex: value,
      in: value,
      mm: value,
      pc: value,
      pt: value,
      px: value,
      q: value,
      rem: value,
      vh: value,
      vmax: value,
      vmin: value,
      vw: value,
      "%": value
    };
  };
  var buildPrecisionFrom = function(source) {
    if (source === null || source === undefined) {
      return {};
    }
    if (typeof source == "boolean") {
      return {};
    }
    if (typeof source == "number" && source == -1) {
      return defaults2(DEFAULT_PRECISION);
    }
    if (typeof source == "number") {
      return defaults2(source);
    }
    if (typeof source == "string" && INTEGER_PATTERN.test(source)) {
      return defaults2(parseInt(source));
    }
    if (typeof source == "string" && source == DEFAULT_PRECISION) {
      return defaults2(DEFAULT_PRECISION);
    }
    if (typeof source == "object") {
      return source;
    }
    return source.split(DIRECTIVES_SEPARATOR).reduce(function(accumulator, directive) {
      var directiveParts = directive.split(DIRECTIVE_VALUE_SEPARATOR);
      var name = directiveParts[0];
      var value = parseInt(directiveParts[1]);
      if (isNaN(value) || value == -1) {
        value = DEFAULT_PRECISION;
      }
      if (ALL_UNITS.indexOf(name) > -1) {
        accumulator = override(accumulator, defaults2(value));
      } else {
        accumulator[name] = value;
      }
      return accumulator;
    }, {});
  };
  var override = require_override();
  var INTEGER_PATTERN = /^\d+$/;
  var ALL_UNITS = ["*", "all"];
  var DEFAULT_PRECISION = "off";
  var DIRECTIVES_SEPARATOR = ",";
  var DIRECTIVE_VALUE_SEPARATOR = "=";
  module.exports = {
    DEFAULT: DEFAULT_PRECISION,
    roundingPrecisionFrom
  };
});

// node_modules/clean-css/lib/options/optimization-level.js
var require_optimization_level = __commonJS((exports, module) => {
  var optimizationLevelFrom = function(source) {
    var level = override(DEFAULTS, {});
    var Zero = OptimizationLevel.Zero;
    var One = OptimizationLevel.One;
    var Two = OptimizationLevel.Two;
    if (source === undefined) {
      delete level[Two];
      return level;
    }
    if (typeof source == "string") {
      source = parseInt(source);
    }
    if (typeof source == "number" && source === parseInt(Two)) {
      return level;
    }
    if (typeof source == "number" && source === parseInt(One)) {
      delete level[Two];
      return level;
    }
    if (typeof source == "number" && source === parseInt(Zero)) {
      delete level[Two];
      delete level[One];
      return level;
    }
    if (typeof source == "object") {
      source = covertValuesToHashes(source);
    }
    if (One in source && "roundingPrecision" in source[One]) {
      source[One].roundingPrecision = roundingPrecisionFrom(source[One].roundingPrecision);
    }
    if (Two in source && "skipProperties" in source[Two] && typeof source[Two].skipProperties == "string") {
      source[Two].skipProperties = source[Two].skipProperties.split(LIST_VALUE_SEPARATOR);
    }
    if (Zero in source || One in source || Two in source) {
      level[Zero] = override(level[Zero], source[Zero]);
    }
    if (One in source && ALL_KEYWORD_1 in source[One]) {
      level[One] = override(level[One], defaults2(One, normalizeValue(source[One][ALL_KEYWORD_1])));
      delete source[One][ALL_KEYWORD_1];
    }
    if (One in source && ALL_KEYWORD_2 in source[One]) {
      level[One] = override(level[One], defaults2(One, normalizeValue(source[One][ALL_KEYWORD_2])));
      delete source[One][ALL_KEYWORD_2];
    }
    if (One in source || Two in source) {
      level[One] = override(level[One], source[One]);
    } else {
      delete level[One];
    }
    if (Two in source && ALL_KEYWORD_1 in source[Two]) {
      level[Two] = override(level[Two], defaults2(Two, normalizeValue(source[Two][ALL_KEYWORD_1])));
      delete source[Two][ALL_KEYWORD_1];
    }
    if (Two in source && ALL_KEYWORD_2 in source[Two]) {
      level[Two] = override(level[Two], defaults2(Two, normalizeValue(source[Two][ALL_KEYWORD_2])));
      delete source[Two][ALL_KEYWORD_2];
    }
    if (Two in source) {
      level[Two] = override(level[Two], source[Two]);
    } else {
      delete level[Two];
    }
    return level;
  };
  var defaults2 = function(level, value) {
    var options = override(DEFAULTS[level], {});
    var key;
    for (key in options) {
      if (typeof options[key] == "boolean") {
        options[key] = value;
      }
    }
    return options;
  };
  var normalizeValue = function(value) {
    switch (value) {
      case FALSE_KEYWORD_1:
      case FALSE_KEYWORD_2:
        return false;
      case TRUE_KEYWORD_1:
      case TRUE_KEYWORD_2:
        return true;
      default:
        return value;
    }
  };
  var covertValuesToHashes = function(source) {
    var clonedSource = override(source, {});
    var level;
    var i;
    for (i = 0;i <= 2; i++) {
      level = "" + i;
      if (level in clonedSource && (clonedSource[level] === undefined || clonedSource[level] === false)) {
        delete clonedSource[level];
      }
      if (level in clonedSource && clonedSource[level] === true) {
        clonedSource[level] = {};
      }
      if (level in clonedSource && typeof clonedSource[level] == "string") {
        clonedSource[level] = covertToHash(clonedSource[level], level);
      }
    }
    return clonedSource;
  };
  var covertToHash = function(asString, level) {
    return asString.split(OPTION_SEPARATOR).reduce(function(accumulator, directive) {
      var parts = directive.split(OPTION_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      var normalizedValue = normalizeValue(value);
      if (ALL_KEYWORD_1 == name || ALL_KEYWORD_2 == name) {
        accumulator = override(accumulator, defaults2(level, normalizedValue));
      } else {
        accumulator[name] = normalizedValue;
      }
      return accumulator;
    }, {});
  };
  var roundingPrecisionFrom = require_rounding_precision().roundingPrecisionFrom;
  var override = require_override();
  var OptimizationLevel = {
    Zero: "0",
    One: "1",
    Two: "2"
  };
  var DEFAULTS = {};
  DEFAULTS[OptimizationLevel.Zero] = {};
  DEFAULTS[OptimizationLevel.One] = {
    cleanupCharsets: true,
    normalizeUrls: true,
    optimizeBackground: true,
    optimizeBorderRadius: true,
    optimizeFilter: true,
    optimizeFontWeight: true,
    optimizeOutline: true,
    removeEmpty: true,
    removeNegativePaddings: true,
    removeQuotes: true,
    removeWhitespace: true,
    replaceMultipleZeros: true,
    replaceTimeUnits: true,
    replaceZeroUnits: true,
    roundingPrecision: roundingPrecisionFrom(undefined),
    selectorsSortingMethod: "standard",
    specialComments: "all",
    tidyAtRules: true,
    tidyBlockScopes: true,
    tidySelectors: true
  };
  DEFAULTS[OptimizationLevel.Two] = {
    mergeAdjacentRules: true,
    mergeIntoShorthands: true,
    mergeMedia: true,
    mergeNonAdjacentRules: true,
    mergeSemantically: false,
    overrideProperties: true,
    removeEmpty: true,
    reduceNonAdjacentRules: true,
    removeDuplicateFontRules: true,
    removeDuplicateMediaBlocks: true,
    removeDuplicateRules: true,
    removeUnusedAtRules: false,
    restructureRules: false,
    skipProperties: []
  };
  var ALL_KEYWORD_1 = "*";
  var ALL_KEYWORD_2 = "all";
  var FALSE_KEYWORD_1 = "false";
  var FALSE_KEYWORD_2 = "off";
  var TRUE_KEYWORD_1 = "true";
  var TRUE_KEYWORD_2 = "on";
  var LIST_VALUE_SEPARATOR = ",";
  var OPTION_SEPARATOR = ";";
  var OPTION_VALUE_SEPARATOR = ":";
  module.exports = {
    OptimizationLevel,
    optimizationLevelFrom
  };
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers/background.js
var require_background = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var plugin = {
    level1: {
      property: function background(_rule, property, options) {
        var values = property.value;
        if (!options.level[OptimizationLevel.One].optimizeBackground) {
          return;
        }
        if (values.length == 1 && values[0][1] == "none") {
          values[0][1] = "0 0";
        }
        if (values.length == 1 && values[0][1] == "transparent") {
          values[0][1] = "0 0";
        }
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers/box-shadow.js
var require_box_shadow = __commonJS((exports, module) => {
  var plugin = {
    level1: {
      property: function boxShadow(_rule, property) {
        var values = property.value;
        if (values.length == 4 && values[0][1] === "0" && values[1][1] === "0" && values[2][1] === "0" && values[3][1] === "0") {
          property.value.splice(2);
          property.dirty = true;
        }
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers/border-radius.js
var require_border_radius = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var plugin = {
    level1: {
      property: function borderRadius(_rule, property, options) {
        var values = property.value;
        if (!options.level[OptimizationLevel.One].optimizeBorderRadius) {
          return;
        }
        if (values.length == 3 && values[1][1] == "/" && values[0][1] == values[2][1]) {
          property.value.splice(1);
          property.dirty = true;
        } else if (values.length == 5 && values[2][1] == "/" && values[0][1] == values[3][1] && values[1][1] == values[4][1]) {
          property.value.splice(2);
          property.dirty = true;
        } else if (values.length == 7 && values[3][1] == "/" && values[0][1] == values[4][1] && values[1][1] == values[5][1] && values[2][1] == values[6][1]) {
          property.value.splice(3);
          property.dirty = true;
        } else if (values.length == 9 && values[4][1] == "/" && values[0][1] == values[5][1] && values[1][1] == values[6][1] && values[2][1] == values[7][1] && values[3][1] == values[8][1]) {
          property.value.splice(4);
          property.dirty = true;
        }
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers/filter.js
var require_filter = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var ALPHA_OR_CHROMA_FILTER_PATTERN = /progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/;
  var NO_SPACE_AFTER_COMMA_PATTERN = /,(\S)/g;
  var WHITESPACE_AROUND_EQUALS_PATTERN = / ?= ?/g;
  var plugin = {
    level1: {
      property: function filter(_rule, property, options) {
        if (!options.compatibility.properties.ieFilters) {
          return;
        }
        if (!options.level[OptimizationLevel.One].optimizeFilter) {
          return;
        }
        if (property.value.length == 1) {
          property.value[0][1] = property.value[0][1].replace(ALPHA_OR_CHROMA_FILTER_PATTERN, function(match, filter, suffix) {
            return filter.toLowerCase() + suffix;
          });
        }
        property.value[0][1] = property.value[0][1].replace(NO_SPACE_AFTER_COMMA_PATTERN, ", $1").replace(WHITESPACE_AROUND_EQUALS_PATTERN, "=");
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers/font-weight.js
var require_font_weight = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var plugin = {
    level1: {
      property: function fontWeight(_rule, property, options) {
        var value = property.value[0][1];
        if (!options.level[OptimizationLevel.One].optimizeFontWeight) {
          return;
        }
        if (value == "normal") {
          value = "400";
        } else if (value == "bold") {
          value = "700";
        }
        property.value[0][1] = value;
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers/margin.js
var require_margin = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var plugin = {
    level1: {
      property: function margin(_rule, property, options) {
        var values = property.value;
        if (!options.level[OptimizationLevel.One].replaceMultipleZeros) {
          return;
        }
        if (values.length == 4 && values[0][1] === "0" && values[1][1] === "0" && values[2][1] === "0" && values[3][1] === "0") {
          property.value.splice(1);
          property.dirty = true;
        }
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers/outline.js
var require_outline = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var plugin = {
    level1: {
      property: function outline(_rule, property, options) {
        var values = property.value;
        if (!options.level[OptimizationLevel.One].optimizeOutline) {
          return;
        }
        if (values.length == 1 && values[0][1] == "none") {
          values[0][1] = "0";
        }
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers/padding.js
var require_padding = __commonJS((exports, module) => {
  var isNegative = function(value) {
    return value && value[1][0] == "-" && parseFloat(value[1]) < 0;
  };
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var plugin = {
    level1: {
      property: function padding(_rule, property, options) {
        var values = property.value;
        if (values.length == 4 && values[0][1] === "0" && values[1][1] === "0" && values[2][1] === "0" && values[3][1] === "0") {
          property.value.splice(1);
          property.dirty = true;
        }
        if (options.level[OptimizationLevel.One].removeNegativePaddings && (isNegative(property.value[0]) || isNegative(property.value[1]) || isNegative(property.value[2]) || isNegative(property.value[3]))) {
          property.unused = true;
        }
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/property-optimizers.js
var require_property_optimizers = __commonJS((exports, module) => {
  module.exports = {
    background: require_background().level1.property,
    boxShadow: require_box_shadow().level1.property,
    borderRadius: require_border_radius().level1.property,
    filter: require_filter().level1.property,
    fontWeight: require_font_weight().level1.property,
    margin: require_margin().level1.property,
    outline: require_outline().level1.property,
    padding: require_padding().level1.property
  };
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-hex.js
var require_shorten_hex = __commonJS((exports, module) => {
  var hexConverter = function(match, prefix, colorValue, suffix) {
    return prefix + toHex[colorValue.toLowerCase()] + suffix;
  };
  var nameConverter = function(match, colorValue, suffix) {
    return toName[colorValue.toLowerCase()] + suffix;
  };
  var shortenHex = function(value) {
    var hasHex = value.indexOf("#") > -1;
    var shortened = value.replace(toHexPattern, hexConverter);
    if (shortened != value) {
      shortened = shortened.replace(toHexPattern, hexConverter);
    }
    return hasHex ? shortened.replace(toNamePattern, nameConverter) : shortened;
  };
  var COLORS = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#0ff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000",
    blanchedalmond: "#ffebcd",
    blue: "#00f",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#0ff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#f0f",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#0f0",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#f00",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#fff",
    whitesmoke: "#f5f5f5",
    yellow: "#ff0",
    yellowgreen: "#9acd32"
  };
  var toHex = {};
  var toName = {};
  for (name in COLORS) {
    hex = COLORS[name];
    if (name.length < hex.length) {
      toName[hex] = name;
    } else {
      toHex[name] = hex;
    }
  }
  var hex;
  var name;
  var toHexPattern = new RegExp("(^| |,|\\))(" + Object.keys(toHex).join("|") + ")( |,|\\)|$)", "ig");
  var toNamePattern = new RegExp("(" + Object.keys(toName).join("|") + ")([^a-f0-9]|$)", "ig");
  module.exports = shortenHex;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-hsl.js
var require_shorten_hsl = __commonJS((exports, module) => {
  var hslToRgb = function(h2, s2, l2) {
    var r, g2, b2;
    h2 = h2 % 360;
    if (h2 < 0)
      h2 += 360;
    h2 = ~~h2 / 360;
    if (s2 < 0)
      s2 = 0;
    else if (s2 > 100)
      s2 = 100;
    s2 = ~~s2 / 100;
    if (l2 < 0)
      l2 = 0;
    else if (l2 > 100)
      l2 = 100;
    l2 = ~~l2 / 100;
    if (s2 === 0) {
      r = g2 = b2 = l2;
    } else {
      var q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      var p2 = 2 * l2 - q;
      r = hueToRgb(p2, q, h2 + 1 / 3);
      g2 = hueToRgb(p2, q, h2);
      b2 = hueToRgb(p2, q, h2 - 1 / 3);
    }
    return [~~(r * 255), ~~(g2 * 255), ~~(b2 * 255)];
  };
  var hueToRgb = function(p2, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p2 + (q - p2) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p2 + (q - p2) * (2 / 3 - t) * 6;
    return p2;
  };
  var shortenHsl = function(hue, saturation, lightness) {
    var asRgb = hslToRgb(hue, saturation, lightness);
    var redAsHex = asRgb[0].toString(16);
    var greenAsHex = asRgb[1].toString(16);
    var blueAsHex = asRgb[2].toString(16);
    return "#" + ((redAsHex.length == 1 ? "0" : "") + redAsHex) + ((greenAsHex.length == 1 ? "0" : "") + greenAsHex) + ((blueAsHex.length == 1 ? "0" : "") + blueAsHex);
  };
  module.exports = shortenHsl;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-rgb.js
var require_shorten_rgb = __commonJS((exports, module) => {
  var shortenRgb = function(red, green, blue) {
    var normalizedRed = Math.max(0, Math.min(parseInt(red), 255));
    var normalizedGreen = Math.max(0, Math.min(parseInt(green), 255));
    var normalizedBlue = Math.max(0, Math.min(parseInt(blue), 255));
    return "#" + ("00000" + (normalizedRed << 16 | normalizedGreen << 8 | normalizedBlue).toString(16)).slice(-6);
  };
  module.exports = shortenRgb;
});

// node_modules/clean-css/lib/utils/split.js
var require_split = __commonJS((exports, module) => {
  var is = function(value, separator, isSeparatorRegex) {
    return isSeparatorRegex ? separator.test(value) : value === separator;
  };
  var split = function(value, separator) {
    var openLevel = Marker.OPEN_ROUND_BRACKET;
    var closeLevel = Marker.CLOSE_ROUND_BRACKET;
    var level = 0;
    var cursor = 0;
    var lastStart = 0;
    var lastValue;
    var lastCharacter;
    var len = value.length;
    var parts = [];
    var isSeparatorRegex = typeof separator == "object" && "exec" in separator;
    if (!isSeparatorRegex && value.indexOf(separator) == -1) {
      return [value];
    }
    if (value.indexOf(openLevel) == -1) {
      return value.split(separator);
    }
    while (cursor < len) {
      if (value[cursor] == openLevel) {
        level++;
      } else if (value[cursor] == closeLevel) {
        level--;
      }
      if (level === 0 && cursor > 0 && cursor + 1 < len && is(value[cursor], separator, isSeparatorRegex)) {
        parts.push(value.substring(lastStart, cursor));
        if (isSeparatorRegex && separator.exec(value[cursor]).length > 1) {
          parts.push(value[cursor]);
        }
        lastStart = cursor + 1;
      }
      cursor++;
    }
    if (lastStart < cursor + 1) {
      lastValue = value.substring(lastStart);
      lastCharacter = lastValue[lastValue.length - 1];
      if (is(lastCharacter, separator, isSeparatorRegex)) {
        lastValue = lastValue.substring(0, lastValue.length - 1);
      }
      parts.push(lastValue);
    }
    return parts;
  };
  var Marker = require_marker();
  module.exports = split;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color.js
var require_color = __commonJS((exports, module) => {
  var shortenHex = require_shorten_hex();
  var shortenHsl = require_shorten_hsl();
  var shortenRgb = require_shorten_rgb();
  var split = require_split();
  var ANY_COLOR_FUNCTION_PATTERN = /(rgb|rgba|hsl|hsla)\(([^\(\)]+)\)/gi;
  var COLOR_PREFIX_PATTERN = /#|rgb|hsl/gi;
  var HEX_LONG_PATTERN = /(^|[^='"])#([0-9a-f]{6})/gi;
  var HEX_SHORT_PATTERN = /(^|[^='"])#([0-9a-f]{3})/gi;
  var HEX_VALUE_PATTERN = /[0-9a-f]/i;
  var HSL_PATTERN = /hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/gi;
  var RGBA_HSLA_PATTERN = /(rgb|hsl)a?\((\-?\d+),(\-?\d+\%?),(\-?\d+\%?),(0*[1-9]+[0-9]*(\.?\d*)?)\)/gi;
  var RGB_PATTERN = /rgb\((\-?\d+),(\-?\d+),(\-?\d+)\)/gi;
  var TRANSPARENT_FUNCTION_PATTERN = /(?:rgba|hsla)\(0,0%?,0%?,0\)/g;
  var plugin = {
    level1: {
      value: function color(name, value, options) {
        if (!options.compatibility.properties.colors) {
          return value;
        }
        if (!value.match(COLOR_PREFIX_PATTERN)) {
          return shortenHex(value);
        }
        value = value.replace(RGBA_HSLA_PATTERN, function(match, colorFn, p1, p2, p3, alpha) {
          return parseInt(alpha, 10) >= 1 ? colorFn + "(" + [p1, p2, p3].join(",") + ")" : match;
        }).replace(RGB_PATTERN, function(match, red, green, blue) {
          return shortenRgb(red, green, blue);
        }).replace(HSL_PATTERN, function(match, hue, saturation, lightness) {
          return shortenHsl(hue, saturation, lightness);
        }).replace(HEX_LONG_PATTERN, function(match, prefix, color, at, inputValue) {
          var suffix = inputValue[at + match.length];
          if (suffix && HEX_VALUE_PATTERN.test(suffix)) {
            return match;
          } else if (color[0] == color[1] && color[2] == color[3] && color[4] == color[5]) {
            return (prefix + "#" + color[0] + color[2] + color[4]).toLowerCase();
          } else {
            return (prefix + "#" + color).toLowerCase();
          }
        }).replace(HEX_SHORT_PATTERN, function(match, prefix, color) {
          return prefix + "#" + color.toLowerCase();
        }).replace(ANY_COLOR_FUNCTION_PATTERN, function(match, colorFunction, colorDef) {
          var tokens = colorDef.split(",");
          var colorFnLowercase = colorFunction && colorFunction.toLowerCase();
          var applies = colorFnLowercase == "hsl" && tokens.length == 3 || colorFnLowercase == "hsla" && tokens.length == 4 || colorFnLowercase == "rgb" && tokens.length === 3 && colorDef.indexOf("%") > 0 || colorFnLowercase == "rgba" && tokens.length == 4 && colorDef.indexOf("%") > 0;
          if (!applies) {
            return match;
          }
          if (tokens[1].indexOf("%") == -1) {
            tokens[1] += "%";
          }
          if (tokens[2].indexOf("%") == -1) {
            tokens[2] += "%";
          }
          return colorFunction + "(" + tokens.join(",") + ")";
        });
        if (options.compatibility.colors.opacity && name.indexOf("background") == -1) {
          value = value.replace(TRANSPARENT_FUNCTION_PATTERN, function(match) {
            if (split(value, ",").pop().indexOf("gradient(") > -1) {
              return match;
            }
            return "transparent";
          });
        }
        return shortenHex(value);
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/degrees.js
var require_degrees = __commonJS((exports, module) => {
  var ZERO_DEG_PATTERN = /\(0deg\)/g;
  var plugin = {
    level1: {
      value: function degrees(_name, value, options) {
        if (!options.compatibility.properties.zeroUnits) {
          return value;
        }
        if (value.indexOf("0deg") == -1) {
          return value;
        }
        return value.replace(ZERO_DEG_PATTERN, "(0)");
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/starts-as-url.js
var require_starts_as_url = __commonJS((exports, module) => {
  var startsAsUrl = function(value) {
    return URL_PREFIX_PATTERN.test(value);
  };
  var URL_PREFIX_PATTERN = /^url\(/i;
  module.exports = startsAsUrl;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/fraction.js
var require_fraction = __commonJS((exports, module) => {
  var startsAsUrl = require_starts_as_url();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var DOT_ZERO_PATTERN = /(^|\D)\.0+(\D|$)/g;
  var FRACTION_PATTERN = /\.([1-9]*)0+(\D|$)/g;
  var LEADING_ZERO_FRACTION_PATTERN = /(^|\D)0\.(\d)/g;
  var MINUS_ZERO_FRACTION_PATTERN = /([^\w\d\-]|^)\-0([^\.]|$)/g;
  var ZERO_PREFIXED_UNIT_PATTERN = /(^|\s)0+([1-9])/g;
  var plugin = {
    level1: {
      value: function fraction(name, value, options) {
        if (!options.level[OptimizationLevel.One].replaceZeroUnits) {
          return value;
        }
        if (startsAsUrl(value)) {
          return value;
        }
        if (value.indexOf("0") == -1) {
          return value;
        }
        if (value.indexOf("-") > -1) {
          value = value.replace(MINUS_ZERO_FRACTION_PATTERN, "$10$2").replace(MINUS_ZERO_FRACTION_PATTERN, "$10$2");
        }
        return value.replace(ZERO_PREFIXED_UNIT_PATTERN, "$1$2").replace(DOT_ZERO_PATTERN, "$10$2").replace(FRACTION_PATTERN, function(match, nonZeroPart, suffix) {
          return (nonZeroPart.length > 0 ? "." : "") + nonZeroPart + suffix;
        }).replace(LEADING_ZERO_FRACTION_PATTERN, "$1.$2");
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/precision.js
var require_precision = __commonJS((exports, module) => {
  var plugin = {
    level1: {
      value: function precision(_name, value, options) {
        if (!options.precision.enabled || value.indexOf(".") === -1) {
          return value;
        }
        return value.replace(options.precision.decimalPointMatcher, "$1$2$3").replace(options.precision.zeroMatcher, function(match, integerPart, fractionPart, unit) {
          var multiplier = options.precision.units[unit].multiplier;
          var parsedInteger = parseInt(integerPart);
          var integer = isNaN(parsedInteger) ? 0 : parsedInteger;
          var fraction = parseFloat(fractionPart);
          return Math.round((integer + fraction) * multiplier) / multiplier + unit;
        });
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/text-quotes.js
var require_text_quotes = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var LOCAL_PREFIX_PATTERN = /^local\(/i;
  var QUOTED_PATTERN = /^('.*'|".*")$/;
  var QUOTED_BUT_SAFE_PATTERN = /^['"][a-zA-Z][a-zA-Z\d\-_]+['"]$/;
  var plugin = {
    level1: {
      value: function textQuotes(_name, value, options) {
        if (!options.level[OptimizationLevel.One].removeQuotes) {
          return value;
        }
        if (!QUOTED_PATTERN.test(value) && !LOCAL_PREFIX_PATTERN.test(value)) {
          return value;
        }
        return QUOTED_BUT_SAFE_PATTERN.test(value) ? value.substring(1, value.length - 1) : value;
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/time.js
var require_time = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var TIME_VALUE = /^(\-?[\d\.]+)(m?s)$/;
  var plugin = {
    level1: {
      value: function time(name, value, options) {
        if (!options.level[OptimizationLevel.One].replaceTimeUnits) {
          return value;
        }
        if (!TIME_VALUE.test(value)) {
          return value;
        }
        return value.replace(TIME_VALUE, function(match, val, unit) {
          var newValue;
          if (unit == "ms") {
            newValue = parseInt(val) / 1000 + "s";
          } else if (unit == "s") {
            newValue = parseFloat(val) * 1000 + "ms";
          }
          return newValue.length < match.length ? newValue : match;
        });
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/unit.js
var require_unit = __commonJS((exports, module) => {
  var WHOLE_PIXEL_VALUE = /(?:^|\s|\()(-?\d+)px/;
  var plugin = {
    level1: {
      value: function unit(_name, value, options) {
        if (!WHOLE_PIXEL_VALUE.test(value)) {
          return value;
        }
        return value.replace(WHOLE_PIXEL_VALUE, function(match, val) {
          var newValue;
          var intVal = parseInt(val);
          if (intVal === 0) {
            return match;
          }
          if (options.compatibility.properties.shorterLengthUnits && options.compatibility.units.pt && intVal * 3 % 4 === 0) {
            newValue = intVal * 3 / 4 + "pt";
          }
          if (options.compatibility.properties.shorterLengthUnits && options.compatibility.units.pc && intVal % 16 === 0) {
            newValue = intVal / 16 + "pc";
          }
          if (options.compatibility.properties.shorterLengthUnits && options.compatibility.units.in && intVal % 96 === 0) {
            newValue = intVal / 96 + "in";
          }
          if (newValue) {
            newValue = match.substring(0, match.indexOf(val)) + newValue;
          }
          return newValue && newValue.length < match.length ? newValue : match;
        });
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-prefix.js
var require_url_prefix = __commonJS((exports, module) => {
  var startsAsUrl = require_starts_as_url();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var URL_PREFIX_PATTERN = /^url\(/i;
  var plugin = {
    level1: {
      value: function urlPrefix(_name, value, options) {
        if (!options.level[OptimizationLevel.One].normalizeUrls) {
          return value;
        }
        if (!startsAsUrl(value)) {
          return value;
        }
        return value.replace(URL_PREFIX_PATTERN, "url(");
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-quotes.js
var require_url_quotes = __commonJS((exports, module) => {
  var QUOTED_URL_PATTERN = /^url\(['"].+['"]\)$/;
  var QUOTED_URL_WITH_WHITESPACE_PATTERN = /^url\(['"].*[\*\s\(\)'"].*['"]\)$/;
  var QUOTES_PATTERN = /["']/g;
  var URL_DATA_PATTERN = /^url\(['"]data:[^;]+;charset/;
  var plugin = {
    level1: {
      value: function urlQuotes(_name, value, options) {
        if (options.compatibility.properties.urlQuotes) {
          return value;
        }
        return QUOTED_URL_PATTERN.test(value) && !QUOTED_URL_WITH_WHITESPACE_PATTERN.test(value) && !URL_DATA_PATTERN.test(value) ? value.replace(QUOTES_PATTERN, "") : value;
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-whitespace.js
var require_url_whitespace = __commonJS((exports, module) => {
  var startsAsUrl = require_starts_as_url();
  var WHITESPACE_PATTERN = /\\?\n|\\?\r\n/g;
  var WHITESPACE_PREFIX_PATTERN = /(\()\s+/g;
  var WHITESPACE_SUFFIX_PATTERN = /\s+(\))/g;
  var plugin = {
    level1: {
      value: function urlWhitespace(_name, value) {
        if (!startsAsUrl(value)) {
          return value;
        }
        return value.replace(WHITESPACE_PATTERN, "").replace(WHITESPACE_PREFIX_PATTERN, "$1").replace(WHITESPACE_SUFFIX_PATTERN, "$1");
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/whitespace.js
var require_whitespace = __commonJS((exports, module) => {
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var Marker = require_marker();
  var CALC_DIVISION_WHITESPACE_PATTERN = /\) ?\/ ?/g;
  var COMMA_AND_SPACE_PATTERN = /, /g;
  var LINE_BREAK_PATTERN = /\r?\n/g;
  var MULTI_WHITESPACE_PATTERN = /\s+/g;
  var FUNCTION_CLOSING_BRACE_WHITESPACE_PATTERN = /\s+(;?\))/g;
  var FUNCTION_OPENING_BRACE_WHITESPACE_PATTERN = /(\(;?)\s+/g;
  var VARIABLE_NAME_PATTERN = /^--\S+$/;
  var VARIABLE_VALUE_PATTERN = /^var\(\s*--\S+\s*\)$/;
  var plugin = {
    level1: {
      value: function whitespace(name, value, options) {
        if (!options.level[OptimizationLevel.One].removeWhitespace) {
          return value;
        }
        if (VARIABLE_NAME_PATTERN.test(name) && !VARIABLE_VALUE_PATTERN.test(value)) {
          return value;
        }
        if (value.indexOf(" ") == -1 && value.indexOf("\n") == -1 || value.indexOf("expression") === 0) {
          return value;
        }
        if (value.indexOf(Marker.SINGLE_QUOTE) > -1 || value.indexOf(Marker.DOUBLE_QUOTE) > -1) {
          return value;
        }
        value = value.replace(LINE_BREAK_PATTERN, "");
        value = value.replace(MULTI_WHITESPACE_PATTERN, " ");
        if (value.indexOf("calc") > -1) {
          value = value.replace(CALC_DIVISION_WHITESPACE_PATTERN, ")/ ");
        }
        return value.replace(FUNCTION_OPENING_BRACE_WHITESPACE_PATTERN, "$1").replace(FUNCTION_CLOSING_BRACE_WHITESPACE_PATTERN, "$1").replace(COMMA_AND_SPACE_PATTERN, ",");
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers/zero.js
var require_zero = __commonJS((exports, module) => {
  var removeRecursively = function(value, options) {
    var functionTokens;
    var tokens;
    if (SKIP_FUNCTION_PATTERN.test(value)) {
      return value;
    }
    functionTokens = ANY_FUNCTION_PATTERN.exec(value);
    if (!functionTokens) {
      return removeZeros(value, options);
    }
    tokens = split(functionTokens[2], TOKEN_SEPARATOR_PATTERN).map(function(token) {
      return removeRecursively(token, options);
    });
    return functionTokens[1] + "(" + tokens.join("") + ")";
  };
  var removeZeros = function(value, options) {
    return value.replace(options.unitsRegexp, "$10$2").replace(options.unitsRegexp, "$10$2");
  };
  var split = require_split();
  var ANY_FUNCTION_PATTERN = /^(\-(?:moz|ms|o|webkit)\-[a-z\-]+|[a-z\-]+)\((.+)\)$/;
  var SKIP_FUNCTION_PATTERN = /^(?:\-moz\-calc|\-webkit\-calc|calc|rgb|hsl|rgba|hsla|min|max|clamp|expression)\(/;
  var TOKEN_SEPARATOR_PATTERN = /([\s,\/])/;
  var plugin = {
    level1: {
      value: function zero(name, value, options) {
        if (!options.compatibility.properties.zeroUnits) {
          return value;
        }
        if (value.indexOf("%") > 0 && (name == "height" || name == "max-height" || name == "width" || name == "max-width")) {
          return value;
        }
        return removeRecursively(value, options);
      }
    }
  };
  module.exports = plugin;
});

// node_modules/clean-css/lib/optimizer/level-1/value-optimizers.js
var require_value_optimizers = __commonJS((exports, module) => {
  module.exports = {
    color: require_color().level1.value,
    degrees: require_degrees().level1.value,
    fraction: require_fraction().level1.value,
    precision: require_precision().level1.value,
    textQuotes: require_text_quotes().level1.value,
    time: require_time().level1.value,
    unit: require_unit().level1.value,
    urlPrefix: require_url_prefix().level1.value,
    urlQuotes: require_url_quotes().level1.value,
    urlWhiteSpace: require_url_whitespace().level1.value,
    whiteSpace: require_whitespace().level1.value,
    zero: require_zero().level1.value
  };
});

// node_modules/clean-css/lib/optimizer/configuration.js
var require_configuration = __commonJS((exports, module) => {
  var cloneDescriptor = function(propertyName2, prefix2) {
    var clonedDescriptor2 = override(configuration[propertyName2], {});
    if ("componentOf" in clonedDescriptor2) {
      clonedDescriptor2.componentOf = clonedDescriptor2.componentOf.map(function(shorthandName) {
        return prefix2 + shorthandName;
      });
    }
    if ("components" in clonedDescriptor2) {
      clonedDescriptor2.components = clonedDescriptor2.components.map(function(longhandName) {
        return prefix2 + longhandName;
      });
    }
    if ("keepUnlessDefault" in clonedDescriptor2) {
      clonedDescriptor2.keepUnlessDefault = prefix2 + clonedDescriptor2.keepUnlessDefault;
    }
    return clonedDescriptor2;
  };
  var breakUp = require_break_up();
  var canOverride = require_can_override();
  var restore = require_restore();
  var propertyOptimizers = require_property_optimizers();
  var valueOptimizers = require_value_optimizers();
  var override = require_override();
  var configuration = {
    animation: {
      canOverride: canOverride.generic.components([
        canOverride.generic.time,
        canOverride.generic.timingFunction,
        canOverride.generic.time,
        canOverride.property.animationIterationCount,
        canOverride.property.animationDirection,
        canOverride.property.animationFillMode,
        canOverride.property.animationPlayState,
        canOverride.property.animationName
      ]),
      components: [
        "animation-duration",
        "animation-timing-function",
        "animation-delay",
        "animation-iteration-count",
        "animation-direction",
        "animation-fill-mode",
        "animation-play-state",
        "animation-name"
      ],
      breakUp: breakUp.multiplex(breakUp.animation),
      defaultValue: "none",
      restore: restore.multiplex(restore.withoutDefaults),
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.textQuotes,
        valueOptimizers.time,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-delay": {
      canOverride: canOverride.generic.time,
      componentOf: [
        "animation"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      valueOptimizers: [
        valueOptimizers.time,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-direction": {
      canOverride: canOverride.property.animationDirection,
      componentOf: [
        "animation"
      ],
      defaultValue: "normal",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-duration": {
      canOverride: canOverride.generic.time,
      componentOf: [
        "animation"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      keepUnlessDefault: "animation-delay",
      valueOptimizers: [
        valueOptimizers.time,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-fill-mode": {
      canOverride: canOverride.property.animationFillMode,
      componentOf: [
        "animation"
      ],
      defaultValue: "none",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-iteration-count": {
      canOverride: canOverride.property.animationIterationCount,
      componentOf: [
        "animation"
      ],
      defaultValue: "1",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-name": {
      canOverride: canOverride.property.animationName,
      componentOf: [
        "animation"
      ],
      defaultValue: "none",
      intoMultiplexMode: "real",
      valueOptimizers: [
        valueOptimizers.textQuotes
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-play-state": {
      canOverride: canOverride.property.animationPlayState,
      componentOf: [
        "animation"
      ],
      defaultValue: "running",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-timing-function": {
      canOverride: canOverride.generic.timingFunction,
      componentOf: [
        "animation"
      ],
      defaultValue: "ease",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    background: {
      canOverride: canOverride.generic.components([
        canOverride.generic.image,
        canOverride.property.backgroundPosition,
        canOverride.property.backgroundSize,
        canOverride.property.backgroundRepeat,
        canOverride.property.backgroundAttachment,
        canOverride.property.backgroundOrigin,
        canOverride.property.backgroundClip,
        canOverride.generic.color
      ]),
      components: [
        "background-image",
        "background-position",
        "background-size",
        "background-repeat",
        "background-attachment",
        "background-origin",
        "background-clip",
        "background-color"
      ],
      breakUp: breakUp.multiplex(breakUp.background),
      defaultValue: "0 0",
      propertyOptimizer: propertyOptimizers.background,
      restore: restore.multiplex(restore.background),
      shortestValue: "0",
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.urlWhiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.zero,
        valueOptimizers.color,
        valueOptimizers.urlPrefix,
        valueOptimizers.urlQuotes
      ]
    },
    "background-attachment": {
      canOverride: canOverride.property.backgroundAttachment,
      componentOf: [
        "background"
      ],
      defaultValue: "scroll",
      intoMultiplexMode: "real"
    },
    "background-clip": {
      canOverride: canOverride.property.backgroundClip,
      componentOf: [
        "background"
      ],
      defaultValue: "border-box",
      intoMultiplexMode: "real",
      shortestValue: "border-box"
    },
    "background-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "background"
      ],
      defaultValue: "transparent",
      intoMultiplexMode: "real",
      multiplexLastOnly: true,
      nonMergeableValue: "none",
      shortestValue: "red",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "background-image": {
      canOverride: canOverride.generic.image,
      componentOf: [
        "background"
      ],
      defaultValue: "none",
      intoMultiplexMode: "default",
      valueOptimizers: [
        valueOptimizers.urlWhiteSpace,
        valueOptimizers.urlPrefix,
        valueOptimizers.urlQuotes,
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero,
        valueOptimizers.color
      ]
    },
    "background-origin": {
      canOverride: canOverride.property.backgroundOrigin,
      componentOf: [
        "background"
      ],
      defaultValue: "padding-box",
      intoMultiplexMode: "real",
      shortestValue: "border-box"
    },
    "background-position": {
      canOverride: canOverride.property.backgroundPosition,
      componentOf: [
        "background"
      ],
      defaultValue: ["0", "0"],
      doubleValues: true,
      intoMultiplexMode: "real",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "background-repeat": {
      canOverride: canOverride.property.backgroundRepeat,
      componentOf: [
        "background"
      ],
      defaultValue: ["repeat"],
      doubleValues: true,
      intoMultiplexMode: "real"
    },
    "background-size": {
      canOverride: canOverride.property.backgroundSize,
      componentOf: [
        "background"
      ],
      defaultValue: ["auto"],
      doubleValues: true,
      intoMultiplexMode: "real",
      shortestValue: "0 0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    bottom: {
      canOverride: canOverride.property.bottom,
      defaultValue: "auto",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    border: {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-width",
        "border-style",
        "border-color"
      ],
      defaultValue: "none",
      overridesShorthands: [
        "border-bottom",
        "border-left",
        "border-right",
        "border-top"
      ],
      restore: restore.withoutDefaults,
      shorthand: true,
      shorthandComponents: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.zero,
        valueOptimizers.color
      ]
    },
    "border-bottom": {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-bottom-width",
        "border-bottom-style",
        "border-bottom-color"
      ],
      defaultValue: "none",
      restore: restore.withoutDefaults,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.zero,
        valueOptimizers.color
      ]
    },
    "border-bottom-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "border-bottom",
        "border-color"
      ],
      defaultValue: "none",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "border-bottom-left-radius": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: propertyOptimizers.borderRadius,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-bottom-right-radius": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: propertyOptimizers.borderRadius,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-bottom-style": {
      canOverride: canOverride.property.borderStyle,
      componentOf: [
        "border-bottom",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-bottom-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-bottom",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-top-width",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "border-collapse": {
      canOverride: canOverride.property.borderCollapse,
      defaultValue: "separate"
    },
    "border-color": {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.generic.color,
        canOverride.generic.color,
        canOverride.generic.color,
        canOverride.generic.color
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-color",
        "border-right-color",
        "border-bottom-color",
        "border-left-color"
      ],
      defaultValue: "none",
      restore: restore.fourValues,
      shortestValue: "red",
      shorthand: true,
      singleTypeComponents: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "border-left": {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-left-width",
        "border-left-style",
        "border-left-color"
      ],
      defaultValue: "none",
      restore: restore.withoutDefaults,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.zero,
        valueOptimizers.color
      ]
    },
    "border-left-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "border-color",
        "border-left"
      ],
      defaultValue: "none",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "border-left-style": {
      canOverride: canOverride.property.borderStyle,
      componentOf: [
        "border-left",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-left-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-left",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-right-width",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "border-radius": {
      breakUp: breakUp.borderRadius,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit
      ]),
      components: [
        "border-top-left-radius",
        "border-top-right-radius",
        "border-bottom-right-radius",
        "border-bottom-left-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: propertyOptimizers.borderRadius,
      restore: restore.borderRadius,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-right": {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-right-width",
        "border-right-style",
        "border-right-color"
      ],
      defaultValue: "none",
      restore: restore.withoutDefaults,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "border-right-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "border-color",
        "border-right"
      ],
      defaultValue: "none",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "border-right-style": {
      canOverride: canOverride.property.borderStyle,
      componentOf: [
        "border-right",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-right-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-right",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-left-width",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "border-style": {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.property.borderStyle,
        canOverride.property.borderStyle,
        canOverride.property.borderStyle,
        canOverride.property.borderStyle
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style"
      ],
      defaultValue: "none",
      restore: restore.fourValues,
      shorthand: true,
      singleTypeComponents: true
    },
    "border-top": {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      defaultValue: "none",
      restore: restore.withoutDefaults,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.zero,
        valueOptimizers.color,
        valueOptimizers.unit
      ]
    },
    "border-top-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "border-color",
        "border-top"
      ],
      defaultValue: "none",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "border-top-left-radius": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: propertyOptimizers.borderRadius,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-top-right-radius": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: propertyOptimizers.borderRadius,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-top-style": {
      canOverride: canOverride.property.borderStyle,
      componentOf: [
        "border-style",
        "border-top"
      ],
      defaultValue: "none"
    },
    "border-top-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-top",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-bottom-width",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "border-width": {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width"
      ],
      defaultValue: "medium",
      restore: restore.fourValues,
      shortestValue: "0",
      shorthand: true,
      singleTypeComponents: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "box-shadow": {
      propertyOptimizer: propertyOptimizers.boxShadow,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero,
        valueOptimizers.color
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    clear: {
      canOverride: canOverride.property.clear,
      defaultValue: "none"
    },
    clip: {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    color: {
      canOverride: canOverride.generic.color,
      defaultValue: "transparent",
      shortestValue: "red",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "column-gap": {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    cursor: {
      canOverride: canOverride.property.cursor,
      defaultValue: "auto"
    },
    display: {
      canOverride: canOverride.property.display
    },
    filter: {
      propertyOptimizer: propertyOptimizers.filter,
      valueOptimizers: [
        valueOptimizers.fraction
      ]
    },
    float: {
      canOverride: canOverride.property.float,
      defaultValue: "none"
    },
    font: {
      breakUp: breakUp.font,
      canOverride: canOverride.generic.components([
        canOverride.property.fontStyle,
        canOverride.property.fontVariant,
        canOverride.property.fontWeight,
        canOverride.property.fontStretch,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.property.fontFamily
      ]),
      components: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      restore: restore.font,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.textQuotes
      ]
    },
    "font-family": {
      canOverride: canOverride.property.fontFamily,
      defaultValue: "user|agent|specific",
      valueOptimizers: [
        valueOptimizers.textQuotes
      ]
    },
    "font-size": {
      canOverride: canOverride.generic.unit,
      defaultValue: "medium",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.fraction
      ]
    },
    "font-stretch": {
      canOverride: canOverride.property.fontStretch,
      defaultValue: "normal"
    },
    "font-style": {
      canOverride: canOverride.property.fontStyle,
      defaultValue: "normal"
    },
    "font-variant": {
      canOverride: canOverride.property.fontVariant,
      defaultValue: "normal"
    },
    "font-weight": {
      canOverride: canOverride.property.fontWeight,
      defaultValue: "normal",
      propertyOptimizer: propertyOptimizers.fontWeight,
      shortestValue: "400"
    },
    gap: {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    height: {
      canOverride: canOverride.generic.unit,
      defaultValue: "auto",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    left: {
      canOverride: canOverride.property.left,
      defaultValue: "auto",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "letter-spacing": {
      valueOptimizers: [
        valueOptimizers.fraction,
        valueOptimizers.zero
      ]
    },
    "line-height": {
      canOverride: canOverride.generic.unitOrNumber,
      defaultValue: "normal",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.fraction,
        valueOptimizers.zero
      ]
    },
    "list-style": {
      canOverride: canOverride.generic.components([
        canOverride.property.listStyleType,
        canOverride.property.listStylePosition,
        canOverride.property.listStyleImage
      ]),
      components: [
        "list-style-type",
        "list-style-position",
        "list-style-image"
      ],
      breakUp: breakUp.listStyle,
      restore: restore.withoutDefaults,
      defaultValue: "outside",
      shortestValue: "none",
      shorthand: true
    },
    "list-style-image": {
      canOverride: canOverride.generic.image,
      componentOf: [
        "list-style"
      ],
      defaultValue: "none"
    },
    "list-style-position": {
      canOverride: canOverride.property.listStylePosition,
      componentOf: [
        "list-style"
      ],
      defaultValue: "outside",
      shortestValue: "inside"
    },
    "list-style-type": {
      canOverride: canOverride.property.listStyleType,
      componentOf: [
        "list-style"
      ],
      defaultValue: "decimal|disc",
      shortestValue: "none"
    },
    margin: {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit
      ]),
      components: [
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left"
      ],
      defaultValue: "0",
      propertyOptimizer: propertyOptimizers.margin,
      restore: restore.fourValues,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "margin-bottom": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-top",
      propertyOptimizer: propertyOptimizers.margin,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "margin-inline-end": {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "margin-inline-start": {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "margin-left": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-right",
      propertyOptimizer: propertyOptimizers.margin,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "margin-right": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-left",
      propertyOptimizer: propertyOptimizers.margin,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "margin-top": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-bottom",
      propertyOptimizer: propertyOptimizers.margin,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "max-height": {
      canOverride: canOverride.generic.unit,
      defaultValue: "none",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "max-width": {
      canOverride: canOverride.generic.unit,
      defaultValue: "none",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "min-height": {
      canOverride: canOverride.generic.unit,
      defaultValue: "0",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "min-width": {
      canOverride: canOverride.generic.unit,
      defaultValue: "0",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    opacity: {
      valueOptimizers: [
        valueOptimizers.fraction,
        valueOptimizers.precision
      ]
    },
    outline: {
      canOverride: canOverride.generic.components([
        canOverride.generic.color,
        canOverride.property.outlineStyle,
        canOverride.generic.unit
      ]),
      components: [
        "outline-color",
        "outline-style",
        "outline-width"
      ],
      breakUp: breakUp.outline,
      restore: restore.withoutDefaults,
      defaultValue: "0",
      propertyOptimizer: propertyOptimizers.outline,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "outline-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "outline"
      ],
      defaultValue: "invert",
      shortestValue: "red",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.color
      ]
    },
    "outline-style": {
      canOverride: canOverride.property.outlineStyle,
      componentOf: [
        "outline"
      ],
      defaultValue: "none"
    },
    "outline-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "outline"
      ],
      defaultValue: "medium",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    overflow: {
      canOverride: canOverride.property.overflow,
      defaultValue: "visible"
    },
    "overflow-x": {
      canOverride: canOverride.property.overflow,
      defaultValue: "visible"
    },
    "overflow-y": {
      canOverride: canOverride.property.overflow,
      defaultValue: "visible"
    },
    padding: {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit
      ]),
      components: [
        "padding-top",
        "padding-right",
        "padding-bottom",
        "padding-left"
      ],
      defaultValue: "0",
      propertyOptimizer: propertyOptimizers.padding,
      restore: restore.fourValues,
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "padding-bottom": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-top",
      propertyOptimizer: propertyOptimizers.padding,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "padding-left": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-right",
      propertyOptimizer: propertyOptimizers.padding,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "padding-right": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-left",
      propertyOptimizer: propertyOptimizers.padding,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "padding-top": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-bottom",
      propertyOptimizer: propertyOptimizers.padding,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    position: {
      canOverride: canOverride.property.position,
      defaultValue: "static"
    },
    right: {
      canOverride: canOverride.property.right,
      defaultValue: "auto",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "row-gap": {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    src: {
      valueOptimizers: [
        valueOptimizers.urlWhiteSpace,
        valueOptimizers.urlPrefix,
        valueOptimizers.urlQuotes
      ]
    },
    "stroke-width": {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "text-align": {
      canOverride: canOverride.property.textAlign,
      defaultValue: "left|right"
    },
    "text-decoration": {
      canOverride: canOverride.property.textDecoration,
      defaultValue: "none"
    },
    "text-indent": {
      canOverride: canOverride.property.textOverflow,
      defaultValue: "none",
      valueOptimizers: [
        valueOptimizers.fraction,
        valueOptimizers.zero
      ]
    },
    "text-overflow": {
      canOverride: canOverride.property.textOverflow,
      defaultValue: "none"
    },
    "text-shadow": {
      canOverride: canOverride.property.textShadow,
      defaultValue: "none",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.zero,
        valueOptimizers.color
      ]
    },
    top: {
      canOverride: canOverride.property.top,
      defaultValue: "auto",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    transform: {
      canOverride: canOverride.property.transform,
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.degrees,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    transition: {
      breakUp: breakUp.multiplex(breakUp.transition),
      canOverride: canOverride.generic.components([
        canOverride.property.transitionProperty,
        canOverride.generic.time,
        canOverride.generic.timingFunction,
        canOverride.generic.time
      ]),
      components: [
        "transition-property",
        "transition-duration",
        "transition-timing-function",
        "transition-delay"
      ],
      defaultValue: "none",
      restore: restore.multiplex(restore.withoutDefaults),
      shorthand: true,
      valueOptimizers: [
        valueOptimizers.time,
        valueOptimizers.fraction
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-delay": {
      canOverride: canOverride.generic.time,
      componentOf: [
        "transition"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      valueOptimizers: [
        valueOptimizers.time
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-duration": {
      canOverride: canOverride.generic.time,
      componentOf: [
        "transition"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      keepUnlessDefault: "transition-delay",
      valueOptimizers: [
        valueOptimizers.time,
        valueOptimizers.fraction
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-property": {
      canOverride: canOverride.generic.propertyName,
      componentOf: [
        "transition"
      ],
      defaultValue: "all",
      intoMultiplexMode: "placeholder",
      placeholderValue: "_",
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-timing-function": {
      canOverride: canOverride.generic.timingFunction,
      componentOf: [
        "transition"
      ],
      defaultValue: "ease",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "vertical-align": {
      canOverride: canOverride.property.verticalAlign,
      defaultValue: "baseline",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    visibility: {
      canOverride: canOverride.property.visibility,
      defaultValue: "visible"
    },
    "-webkit-tap-highlight-color": {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.color
      ]
    },
    "-webkit-margin-end": {
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "white-space": {
      canOverride: canOverride.property.whiteSpace,
      defaultValue: "normal"
    },
    width: {
      canOverride: canOverride.generic.unit,
      defaultValue: "auto",
      shortestValue: "0",
      valueOptimizers: [
        valueOptimizers.whiteSpace,
        valueOptimizers.fraction,
        valueOptimizers.precision,
        valueOptimizers.unit,
        valueOptimizers.zero
      ]
    },
    "z-index": {
      canOverride: canOverride.property.zIndex,
      defaultValue: "auto"
    }
  };
  var vendorPrefixedConfiguration = {};
  var vendorPrefixedConfiguration = {};
  for (propertyName in configuration) {
    descriptor = configuration[propertyName];
    if (!("vendorPrefixes" in descriptor)) {
      continue;
    }
    for (i = 0;i < descriptor.vendorPrefixes.length; i++) {
      prefix = descriptor.vendorPrefixes[i];
      clonedDescriptor = cloneDescriptor(propertyName, prefix);
      delete clonedDescriptor.vendorPrefixes;
      vendorPrefixedConfiguration[prefix + propertyName] = clonedDescriptor;
    }
    delete descriptor.vendorPrefixes;
  }
  var descriptor;
  var prefix;
  var clonedDescriptor;
  var i;
  var propertyName;
  module.exports = override(configuration, vendorPrefixedConfiguration);
});

// node_modules/clean-css/lib/writer/helpers.js
var require_helpers = __commonJS((exports, module) => {
  var supportsAfterClosingBrace = function(token) {
    return token[1][1] == "background" || token[1][1] == "transform" || token[1][1] == "src";
  };
  var afterClosingBrace = function(token, valueIndex) {
    return token[valueIndex][1][token[valueIndex][1].length - 1] == Marker.CLOSE_ROUND_BRACKET;
  };
  var afterComma = function(token, valueIndex) {
    return token[valueIndex][1] == Marker.COMMA;
  };
  var afterSlash = function(token, valueIndex) {
    return token[valueIndex][1] == Marker.FORWARD_SLASH;
  };
  var beforeComma = function(token, valueIndex) {
    return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.COMMA;
  };
  var beforeSlash = function(token, valueIndex) {
    return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.FORWARD_SLASH;
  };
  var inFilter = function(token) {
    return token[1][1] == "filter" || token[1][1] == "-ms-filter";
  };
  var disallowsSpace = function(context, token, valueIndex) {
    return !context.spaceAfterClosingBrace && supportsAfterClosingBrace(token) && afterClosingBrace(token, valueIndex) || beforeSlash(token, valueIndex) || afterSlash(token, valueIndex) || beforeComma(token, valueIndex) || afterComma(token, valueIndex);
  };
  var rules = function(context, tokens) {
    var store = context.store;
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      store(context, tokens[i]);
      if (i < l2 - 1) {
        store(context, comma(context));
      }
    }
  };
  var body = function(context, tokens) {
    var lastPropertyAt = lastPropertyIndex(tokens);
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      property(context, tokens, i, lastPropertyAt);
    }
  };
  var lastPropertyIndex = function(tokens) {
    var index = tokens.length - 1;
    for (;index >= 0; index--) {
      if (tokens[index][0] != Token.COMMENT) {
        break;
      }
    }
    return index;
  };
  var property = function(context, tokens, position, lastPropertyAt) {
    var store = context.store;
    var token = tokens[position];
    var propertyValue = token[2];
    var isPropertyBlock = propertyValue && propertyValue[0] === Token.PROPERTY_BLOCK;
    var needsSemicolon;
    if (context.format) {
      if (context.format.semicolonAfterLastProperty || isPropertyBlock) {
        needsSemicolon = true;
      } else if (position < lastPropertyAt) {
        needsSemicolon = true;
      } else {
        needsSemicolon = false;
      }
    } else {
      needsSemicolon = position < lastPropertyAt || isPropertyBlock;
    }
    var isLast = position === lastPropertyAt;
    switch (token[0]) {
      case Token.AT_RULE:
        store(context, token);
        store(context, semicolon(context, Breaks.AfterProperty, false));
        break;
      case Token.AT_RULE_BLOCK:
        rules(context, token[1]);
        store(context, openBrace(context, Breaks.AfterRuleBegins, true));
        body(context, token[2]);
        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
        break;
      case Token.COMMENT:
        store(context, token);
        store(context, breakFor(context, Breaks.AfterComment) + context.indentWith);
        break;
      case Token.PROPERTY:
        store(context, token[1]);
        store(context, colon(context));
        if (propertyValue) {
          value(context, token);
        }
        store(context, needsSemicolon ? semicolon(context, Breaks.AfterProperty, isLast) : emptyCharacter);
        break;
      case Token.RAW:
        store(context, token);
    }
  };
  var value = function(context, token) {
    var store = context.store;
    var j2, m2;
    if (token[2][0] == Token.PROPERTY_BLOCK) {
      store(context, openBrace(context, Breaks.AfterBlockBegins, false));
      body(context, token[2][1]);
      store(context, closeBrace(context, Breaks.AfterBlockEnds, false, true));
    } else {
      for (j2 = 2, m2 = token.length;j2 < m2; j2++) {
        store(context, token[j2]);
        if (j2 < m2 - 1 && (inFilter(token) || !disallowsSpace(context, token, j2))) {
          store(context, Marker.SPACE);
        }
      }
    }
  };
  var breakFor = function(context, where) {
    return context.format ? context.format.breaks[where] : emptyCharacter;
  };
  var allowsSpace = function(context, where) {
    return context.format && context.format.spaces[where];
  };
  var openBrace = function(context, where, needsPrefixSpace) {
    if (context.format) {
      context.indentBy += context.format.indentBy;
      context.indentWith = context.format.indentWith.repeat(context.indentBy);
      return (needsPrefixSpace && allowsSpace(context, Spaces.BeforeBlockBegins) ? Marker.SPACE : emptyCharacter) + Marker.OPEN_CURLY_BRACKET + breakFor(context, where) + context.indentWith;
    } else {
      return Marker.OPEN_CURLY_BRACKET;
    }
  };
  var closeBrace = function(context, where, beforeBlockEnd, isLast) {
    if (context.format) {
      context.indentBy -= context.format.indentBy;
      context.indentWith = context.format.indentWith.repeat(context.indentBy);
      return (beforeBlockEnd ? breakFor(context, Breaks.BeforeBlockEnds) : breakFor(context, Breaks.AfterProperty)) + context.indentWith + Marker.CLOSE_CURLY_BRACKET + (isLast ? emptyCharacter : breakFor(context, where) + context.indentWith);
    } else {
      return Marker.CLOSE_CURLY_BRACKET;
    }
  };
  var colon = function(context) {
    return context.format ? Marker.COLON + (allowsSpace(context, Spaces.BeforeValue) ? Marker.SPACE : emptyCharacter) : Marker.COLON;
  };
  var semicolon = function(context, where, isLast) {
    return context.format ? Marker.SEMICOLON + (isLast ? emptyCharacter : breakFor(context, where) + context.indentWith) : Marker.SEMICOLON;
  };
  var comma = function(context) {
    return context.format ? Marker.COMMA + breakFor(context, Breaks.BetweenSelectors) + context.indentWith : Marker.COMMA;
  };
  var all2 = function(context, tokens) {
    var store = context.store;
    var token;
    var isLast;
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      token = tokens[i];
      isLast = i == l2 - 1;
      switch (token[0]) {
        case Token.AT_RULE:
          store(context, token);
          store(context, semicolon(context, Breaks.AfterAtRule, isLast));
          break;
        case Token.AT_RULE_BLOCK:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterRuleBegins, true));
          body(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
          break;
        case Token.NESTED_BLOCK:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterBlockBegins, true));
          all2(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterBlockEnds, true, isLast));
          break;
        case Token.COMMENT:
          store(context, token);
          store(context, breakFor(context, Breaks.AfterComment) + context.indentWith);
          break;
        case Token.RAW:
          store(context, token);
          break;
        case Token.RULE:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterRuleBegins, true));
          body(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
          break;
      }
    }
  };
  var emptyCharacter = "";
  var Breaks = require_format().Breaks;
  var Spaces = require_format().Spaces;
  var Marker = require_marker();
  var Token = require_token();
  module.exports = {
    all: all2,
    body,
    property,
    rules,
    value
  };
});

// node_modules/clean-css/lib/writer/one-time.js
var require_one_time = __commonJS((exports, module) => {
  var store = function(serializeContext, token) {
    serializeContext.output.push(typeof token == "string" ? token : token[1]);
  };
  var context = function() {
    var newContext = {
      output: [],
      store
    };
    return newContext;
  };
  var all2 = function(tokens) {
    var oneTimeContext = context();
    helpers.all(oneTimeContext, tokens);
    return oneTimeContext.output.join("");
  };
  var body = function(tokens) {
    var oneTimeContext = context();
    helpers.body(oneTimeContext, tokens);
    return oneTimeContext.output.join("");
  };
  var property = function(tokens, position) {
    var oneTimeContext = context();
    helpers.property(oneTimeContext, tokens, position, true);
    return oneTimeContext.output.join("");
  };
  var rules = function(tokens) {
    var oneTimeContext = context();
    helpers.rules(oneTimeContext, tokens);
    return oneTimeContext.output.join("");
  };
  var value = function(tokens) {
    var oneTimeContext = context();
    helpers.value(oneTimeContext, tokens);
    return oneTimeContext.output.join("");
  };
  var helpers = require_helpers();
  module.exports = {
    all: all2,
    body,
    property,
    rules,
    value
  };
});

// node_modules/clean-css/lib/optimizer/level-1/optimize.js
var require_optimize2 = __commonJS((exports, module) => {
  var startsAsUrl = function(value) {
    return URL_PREFIX_PATTERN.test(value);
  };
  var isImport = function(token) {
    return IMPORT_PREFIX_PATTERN.test(token[1]);
  };
  var isLegacyFilter = function(property) {
    var value;
    if (property.name == "filter" || property.name == "-ms-filter") {
      value = property.value[0][1];
      return value.indexOf("progid") > -1 || value.indexOf("alpha") === 0 || value.indexOf("chroma") === 0;
    } else {
      return false;
    }
  };
  var noop2 = function() {
  };
  var optimizeBody = function(rule, properties, context) {
    var options = context.options;
    var valueOptimizers;
    var property, name, type, value;
    var propertyToken;
    var propertyOptimizer;
    var serializedRule = serializeRules(rule);
    var _properties = wrapForOptimizing(properties);
    var pluginValueOptimizers = context.options.plugins.level1Value;
    var pluginPropertyOptimizers = context.options.plugins.level1Property;
    var i, l2;
    propertyLoop:
      for (i = 0, l2 = _properties.length;i < l2; i++) {
        var j2, k2, m2, n;
        property = _properties[i];
        name = property.name;
        propertyOptimizer = configuration[name] && configuration[name].propertyOptimizer || noop2;
        valueOptimizers = configuration[name] && configuration[name].valueOptimizers || [optimizers.whiteSpace];
        if (!PROPERTY_NAME_PATTERN.test(name)) {
          propertyToken = property.all[property.position];
          context.warnings.push("Invalid property name \'" + name + "\' at " + formatPosition(propertyToken[1][2][0]) + ". Ignoring.");
          property.unused = true;
          continue;
        }
        if (property.value.length === 0) {
          propertyToken = property.all[property.position];
          context.warnings.push("Empty property \'" + name + "\' at " + formatPosition(propertyToken[1][2][0]) + ". Ignoring.");
          property.unused = true;
          continue;
        }
        if (property.hack && ((property.hack[0] == Hack.ASTERISK || property.hack[0] == Hack.UNDERSCORE) && !options.compatibility.properties.iePrefixHack || property.hack[0] == Hack.BACKSLASH && !options.compatibility.properties.ieSuffixHack || property.hack[0] == Hack.BANG && !options.compatibility.properties.ieBangHack)) {
          property.unused = true;
          continue;
        }
        if (!options.compatibility.properties.ieFilters && isLegacyFilter(property)) {
          property.unused = true;
          continue;
        }
        if (property.block) {
          optimizeBody(rule, property.value[0][1], context);
          continue;
        }
        valuesLoop:
          for (j2 = 0, m2 = property.value.length;j2 < m2; j2++) {
            type = property.value[j2][0];
            value = property.value[j2][1];
            if (type == Token.PROPERTY_BLOCK) {
              property.unused = true;
              context.warnings.push("Invalid value token at " + formatPosition(value[0][1][2][0]) + ". Ignoring.");
              break;
            }
            if (startsAsUrl(value) && !context.validator.isUrl(value)) {
              property.unused = true;
              context.warnings.push("Broken URL \'" + value + "\' at " + formatPosition(property.value[j2][2][0]) + ". Ignoring.");
              break;
            }
            for (k2 = 0, n = valueOptimizers.length;k2 < n; k2++) {
              value = valueOptimizers[k2](name, value, options);
            }
            for (k2 = 0, n = pluginValueOptimizers.length;k2 < n; k2++) {
              value = pluginValueOptimizers[k2](name, value, options);
            }
            property.value[j2][1] = value;
          }
        propertyOptimizer(serializedRule, property, options);
        for (j2 = 0, m2 = pluginPropertyOptimizers.length;j2 < m2; j2++) {
          pluginPropertyOptimizers[j2](serializedRule, property, options);
        }
      }
    restoreFromOptimizing(_properties);
    removeUnused(_properties);
    removeComments(properties, options);
  };
  var removeComments = function(tokens, options) {
    var token;
    var i;
    for (i = 0;i < tokens.length; i++) {
      token = tokens[i];
      if (token[0] != Token.COMMENT) {
        continue;
      }
      optimizeComment(token, options);
      if (token[1].length === 0) {
        tokens.splice(i, 1);
        i--;
      }
    }
  };
  var optimizeComment = function(token, options) {
    if (token[1][2] == Marker.EXCLAMATION && (options.level[OptimizationLevel.One].specialComments == "all" || options.commentsKept < options.level[OptimizationLevel.One].specialComments)) {
      options.commentsKept++;
      return;
    }
    token[1] = [];
  };
  var cleanupCharsets = function(tokens) {
    var hasCharset = false;
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      var token = tokens[i];
      if (token[0] != Token.AT_RULE)
        continue;
      if (!CHARSET_REGEXP.test(token[1]))
        continue;
      if (hasCharset || token[1].indexOf(CHARSET_TOKEN) == -1) {
        tokens.splice(i, 1);
        i--;
        l2--;
      } else {
        hasCharset = true;
        tokens.splice(i, 1);
        tokens.unshift([Token.AT_RULE, token[1].replace(CHARSET_REGEXP, CHARSET_TOKEN)]);
      }
    }
  };
  var buildUnitRegexp = function(options) {
    var units = ["px", "em", "ex", "cm", "mm", "in", "pt", "pc", "%"];
    var otherUnits = ["ch", "rem", "vh", "vm", "vmax", "vmin", "vw"];
    otherUnits.forEach(function(unit) {
      if (options.compatibility.units[unit]) {
        units.push(unit);
      }
    });
    return new RegExp("(^|\\s|\\(|,)0(?:" + units.join("|") + ")(\\W|$)", "g");
  };
  var buildPrecisionOptions = function(roundingPrecision) {
    var precisionOptions = {
      matcher: null,
      units: {}
    };
    var optimizable = [];
    var unit;
    var value;
    for (unit in roundingPrecision) {
      value = roundingPrecision[unit];
      if (value != DEFAULT_ROUNDING_PRECISION) {
        precisionOptions.units[unit] = {};
        precisionOptions.units[unit].value = value;
        precisionOptions.units[unit].multiplier = Math.pow(10, value);
        optimizable.push(unit);
      }
    }
    if (optimizable.length > 0) {
      precisionOptions.enabled = true;
      precisionOptions.decimalPointMatcher = new RegExp("(\\d)\\.($|" + optimizable.join("|") + ")($|\\W)", "g");
      precisionOptions.zeroMatcher = new RegExp("(\\d*)(\\.\\d+)(" + optimizable.join("|") + ")", "g");
    }
    return precisionOptions;
  };
  var level1Optimize = function(tokens, context) {
    var options = context.options;
    var levelOptions = options.level[OptimizationLevel.One];
    var ie7Hack = options.compatibility.selectors.ie7Hack;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;
    var format = options.format;
    var mayHaveCharset = false;
    var afterRules = false;
    options.unitsRegexp = options.unitsRegexp || buildUnitRegexp(options);
    options.precision = options.precision || buildPrecisionOptions(levelOptions.roundingPrecision);
    options.commentsKept = options.commentsKept || 0;
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      var token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          token[1] = isImport(token) && afterRules ? "" : token[1];
          token[1] = levelOptions.tidyAtRules ? tidyAtRule(token[1]) : token[1];
          mayHaveCharset = true;
          break;
        case Token.AT_RULE_BLOCK:
          optimizeBody(token[1], token[2], context);
          afterRules = true;
          break;
        case Token.NESTED_BLOCK:
          token[1] = levelOptions.tidyBlockScopes ? tidyBlock(token[1], spaceAfterClosingBrace) : token[1];
          level1Optimize(token[2], context);
          afterRules = true;
          break;
        case Token.COMMENT:
          optimizeComment(token, options);
          break;
        case Token.RULE:
          token[1] = levelOptions.tidySelectors ? tidyRules(token[1], !ie7Hack, adjacentSpace, format, context.warnings) : token[1];
          token[1] = token[1].length > 1 ? sortSelectors(token[1], levelOptions.selectorsSortingMethod) : token[1];
          optimizeBody(token[1], token[2], context);
          afterRules = true;
          break;
      }
      if (token[0] == Token.COMMENT && token[1].length === 0 || levelOptions.removeEmpty && (token[1].length === 0 || token[2] && token[2].length === 0)) {
        tokens.splice(i, 1);
        i--;
        l2--;
      }
    }
    if (levelOptions.cleanupCharsets && mayHaveCharset) {
      cleanupCharsets(tokens);
    }
    return tokens;
  };
  var sortSelectors = require_sort_selectors();
  var tidyRules = require_tidy_rules();
  var tidyBlock = require_tidy_block();
  var tidyAtRule = require_tidy_at_rule();
  var Hack = require_hack();
  var removeUnused = require_remove_unused();
  var restoreFromOptimizing = require_restore_from_optimizing();
  var wrapForOptimizing = require_wrap_for_optimizing().all;
  var configuration = require_configuration();
  var optimizers = require_value_optimizers();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var Token = require_token();
  var Marker = require_marker();
  var formatPosition = require_format_position();
  var serializeRules = require_one_time().rules;
  var CHARSET_TOKEN = "@charset";
  var CHARSET_REGEXP = new RegExp("^" + CHARSET_TOKEN, "i");
  var DEFAULT_ROUNDING_PRECISION = require_rounding_precision().DEFAULT;
  var PROPERTY_NAME_PATTERN = /^(?:\-chrome\-|\-[\w\-]+\w|\w[\w\-]+\w|\w{1,}|\-\-\S+)$/;
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  var URL_PREFIX_PATTERN = /^url\(/i;
  module.exports = level1Optimize;
});

// node_modules/clean-css/lib/optimizer/level-2/is-mergeable.js
var require_is_mergeable = __commonJS((exports, module) => {
  var isMergeable = function(selector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
    var singleSelectors = split(selector, Marker.COMMA);
    var singleSelector;
    var i, l2;
    for (i = 0, l2 = singleSelectors.length;i < l2; i++) {
      singleSelector = singleSelectors[i];
      if (singleSelector.length === 0 || isDeepSelector(singleSelector) || isVendorPrefixed(singleSelector) || singleSelector.indexOf(Marker.COLON) > -1 && !areMergeable(singleSelector, extractPseudoFrom(singleSelector), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
        return false;
      }
    }
    return true;
  };
  var isDeepSelector = function(selector) {
    return DEEP_SELECTOR_PATTERN.test(selector);
  };
  var isVendorPrefixed = function(selector) {
    return VENDOR_PREFIXED_PATTERN.test(selector);
  };
  var extractPseudoFrom = function(selector) {
    var list = [];
    var character;
    var buffer = [];
    var level = Level.ROOT;
    var roundBracketLevel = 0;
    var isQuoted;
    var isEscaped;
    var isPseudo = false;
    var isRelation;
    var wasColon = false;
    var index;
    var len;
    for (index = 0, len = selector.length;index < len; index++) {
      character = selector[index];
      isRelation = !isEscaped && RELATION_PATTERN.test(character);
      isQuoted = level == Level.DOUBLE_QUOTE || level == Level.SINGLE_QUOTE;
      if (isEscaped) {
        buffer.push(character);
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.ROOT) {
        buffer.push(character);
        level = Level.DOUBLE_QUOTE;
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
        buffer.push(character);
        level = Level.ROOT;
      } else if (character == Marker.SINGLE_QUOTE && level == Level.ROOT) {
        buffer.push(character);
        level = Level.SINGLE_QUOTE;
      } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
        buffer.push(character);
        level = Level.ROOT;
      } else if (isQuoted) {
        buffer.push(character);
      } else if (character == Marker.OPEN_ROUND_BRACKET) {
        buffer.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1 && isPseudo) {
        buffer.push(character);
        list.push(buffer.join(""));
        roundBracketLevel--;
        buffer = [];
        isPseudo = false;
      } else if (character == Marker.CLOSE_ROUND_BRACKET) {
        buffer.push(character);
        roundBracketLevel--;
      } else if (character == Marker.COLON && roundBracketLevel === 0 && isPseudo && !wasColon) {
        list.push(buffer.join(""));
        buffer = [];
        buffer.push(character);
      } else if (character == Marker.COLON && roundBracketLevel === 0 && !wasColon) {
        buffer = [];
        buffer.push(character);
        isPseudo = true;
      } else if (character == Marker.SPACE && roundBracketLevel === 0 && isPseudo) {
        list.push(buffer.join(""));
        buffer = [];
        isPseudo = false;
      } else if (isRelation && roundBracketLevel === 0 && isPseudo) {
        list.push(buffer.join(""));
        buffer = [];
        isPseudo = false;
      } else {
        buffer.push(character);
      }
      isEscaped = character == Marker.BACK_SLASH;
      wasColon = character == Marker.COLON;
    }
    if (buffer.length > 0 && isPseudo) {
      list.push(buffer.join(""));
    }
    return list;
  };
  var areMergeable = function(selector, matches, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
    return areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) && needArguments(matches) && (matches.length < 2 || !someIncorrectlyChained(selector, matches)) && (matches.length < 2 || multiplePseudoMerging && allMixable(matches));
  };
  var areAllowed = function(matches, mergeablePseudoClasses, mergeablePseudoElements) {
    var match;
    var name;
    var i, l2;
    for (i = 0, l2 = matches.length;i < l2; i++) {
      match = matches[i];
      name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) : match;
      if (mergeablePseudoClasses.indexOf(name) === -1 && mergeablePseudoElements.indexOf(name) === -1) {
        return false;
      }
    }
    return true;
  };
  var needArguments = function(matches) {
    var match;
    var name;
    var bracketOpensAt;
    var hasArguments;
    var i, l2;
    for (i = 0, l2 = matches.length;i < l2; i++) {
      match = matches[i];
      bracketOpensAt = match.indexOf(Marker.OPEN_ROUND_BRACKET);
      hasArguments = bracketOpensAt > -1;
      name = hasArguments ? match.substring(0, bracketOpensAt) : match;
      if (hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) == -1) {
        return false;
      }
      if (!hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) > -1) {
        return false;
      }
    }
    return true;
  };
  var someIncorrectlyChained = function(selector, matches) {
    var positionInSelector = 0;
    var match;
    var matchAt;
    var nextMatch;
    var nextMatchAt;
    var name;
    var nextName;
    var areChained;
    var i, l2;
    for (i = 0, l2 = matches.length;i < l2; i++) {
      match = matches[i];
      nextMatch = matches[i + 1];
      if (!nextMatch) {
        break;
      }
      matchAt = selector.indexOf(match, positionInSelector);
      nextMatchAt = selector.indexOf(match, matchAt + 1);
      positionInSelector = nextMatchAt;
      areChained = matchAt + match.length == nextMatchAt;
      if (areChained) {
        name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) : match;
        nextName = nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? nextMatch.substring(0, nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET)) : nextMatch;
        if (name != NOT_PSEUDO || nextName != NOT_PSEUDO) {
          return true;
        }
      }
    }
    return false;
  };
  var allMixable = function(matches) {
    var unmixableMatches = 0;
    var match;
    var i, l2;
    for (i = 0, l2 = matches.length;i < l2; i++) {
      match = matches[i];
      if (isPseudoElement(match)) {
        unmixableMatches += UNMIXABLE_PSEUDO_ELEMENTS.indexOf(match) > -1 ? 1 : 0;
      } else {
        unmixableMatches += UNMIXABLE_PSEUDO_CLASSES.indexOf(match) > -1 ? 1 : 0;
      }
      if (unmixableMatches > 1) {
        return false;
      }
    }
    return true;
  };
  var isPseudoElement = function(pseudo) {
    return DOUBLE_COLON_PATTERN.test(pseudo);
  };
  var Marker = require_marker();
  var split = require_split();
  var DEEP_SELECTOR_PATTERN = /\/deep\//;
  var DOUBLE_COLON_PATTERN = /^::/;
  var VENDOR_PREFIXED_PATTERN = /:(-moz-|-ms-|-o-|-webkit-)/;
  var NOT_PSEUDO = ":not";
  var PSEUDO_CLASSES_WITH_ARGUMENTS = [
    ":dir",
    ":lang",
    ":not",
    ":nth-child",
    ":nth-last-child",
    ":nth-last-of-type",
    ":nth-of-type"
  ];
  var RELATION_PATTERN = /[>\+~]/;
  var UNMIXABLE_PSEUDO_CLASSES = [
    ":after",
    ":before",
    ":first-letter",
    ":first-line",
    ":lang"
  ];
  var UNMIXABLE_PSEUDO_ELEMENTS = [
    "::after",
    "::before",
    "::first-letter",
    "::first-line"
  ];
  var Level = {
    DOUBLE_QUOTE: "double-quote",
    SINGLE_QUOTE: "single-quote",
    ROOT: "root"
  };
  module.exports = isMergeable;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/every-values-pair.js
var require_every_values_pair = __commonJS((exports, module) => {
  var everyValuesPair = function(fn, left, right) {
    var leftSize = left.value.length;
    var rightSize = right.value.length;
    var total = Math.max(leftSize, rightSize);
    var lowerBound = Math.min(leftSize, rightSize) - 1;
    var leftValue;
    var rightValue;
    var position;
    for (position = 0;position < total; position++) {
      leftValue = left.value[position] && left.value[position][1] || leftValue;
      rightValue = right.value[position] && right.value[position][1] || rightValue;
      if (leftValue == Marker.COMMA || rightValue == Marker.COMMA) {
        continue;
      }
      if (!fn(leftValue, rightValue, position, position <= lowerBound)) {
        return false;
      }
    }
    return true;
  };
  var Marker = require_marker();
  module.exports = everyValuesPair;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/has-inherit.js
var require_has_inherit = __commonJS((exports, module) => {
  var hasInherit = function(property) {
    for (var i = property.value.length - 1;i >= 0; i--) {
      if (property.value[i][1] == "inherit")
        return true;
    }
    return false;
  };
  module.exports = hasInherit;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/has-same-values.js
var require_has_same_values = __commonJS((exports, module) => {
  var hasSameValues = function(property) {
    var firstValue = property.value[0][1];
    var i, l2;
    for (i = 1, l2 = property.value.length;i < l2; i++) {
      if (property.value[i][1] != firstValue) {
        return false;
      }
    }
    return true;
  };
  module.exports = hasSameValues;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/populate-components.js
var require_populate_components = __commonJS((exports, module) => {
  var populateComponents = function(properties, validator, warnings) {
    var component;
    var j2, m2;
    for (var i = properties.length - 1;i >= 0; i--) {
      var property = properties[i];
      var descriptor = configuration[property.name];
      if (!property.dynamic && descriptor && descriptor.shorthand) {
        if (onlyValueIsVariable(property, validator) || moreThanOneValueIsVariable(property, validator)) {
          property.optimizable = false;
          continue;
        }
        property.shorthand = true;
        property.dirty = true;
        try {
          property.components = descriptor.breakUp(property, configuration, validator);
          if (descriptor.shorthandComponents) {
            for (j2 = 0, m2 = property.components.length;j2 < m2; j2++) {
              component = property.components[j2];
              component.components = configuration[component.name].breakUp(component, configuration, validator);
            }
          }
        } catch (e) {
          if (e instanceof InvalidPropertyError) {
            property.components = [];
            warnings.push(e.message);
          } else {
            throw e;
          }
        }
        if (property.components.length > 0)
          property.multiplex = property.components[0].multiplex;
        else
          property.unused = true;
      }
    }
  };
  var onlyValueIsVariable = function(property, validator) {
    return property.value.length == 1 && validator.isVariable(property.value[0][1]);
  };
  var moreThanOneValueIsVariable = function(property, validator) {
    return property.value.length > 1 && property.value.filter(function(value) {
      return validator.isVariable(value[1]);
    }).length > 1;
  };
  var configuration = require_configuration();
  var InvalidPropertyError = require_invalid_property_error();
  module.exports = populateComponents;
});

// node_modules/clean-css/lib/optimizer/level-2/restore-with-components.js
var require_restore_with_components = __commonJS((exports, module) => {
  var restoreWithComponents = function(property) {
    var descriptor = configuration[property.name];
    if (descriptor && descriptor.shorthand) {
      return descriptor.restore(property, configuration);
    } else {
      return property.value;
    }
  };
  var configuration = require_configuration();
  module.exports = restoreWithComponents;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/merge-into-shorthands.js
var require_merge_into_shorthands = __commonJS((exports, module) => {
  var mergeIntoShorthands = function(properties, validator) {
    var candidates = {};
    var descriptor;
    var componentOf;
    var property;
    var i, l2;
    var j2, m2;
    if (properties.length < 3) {
      return;
    }
    for (i = 0, l2 = properties.length;i < l2; i++) {
      property = properties[i];
      descriptor = configuration[property.name];
      if (property.dynamic) {
        continue;
      }
      if (property.unused) {
        continue;
      }
      if (property.hack) {
        continue;
      }
      if (property.block) {
        continue;
      }
      if (descriptor && descriptor.singleTypeComponents && !hasSameValues(property)) {
        continue;
      }
      invalidateOrCompact(properties, i, candidates, validator);
      if (descriptor && descriptor.componentOf) {
        for (j2 = 0, m2 = descriptor.componentOf.length;j2 < m2; j2++) {
          componentOf = descriptor.componentOf[j2];
          candidates[componentOf] = candidates[componentOf] || {};
          candidates[componentOf][property.name] = property;
        }
      }
    }
    invalidateOrCompact(properties, i, candidates, validator);
  };
  var invalidateOrCompact = function(properties, position, candidates, validator) {
    var invalidatedBy = properties[position];
    var shorthandName;
    var shorthandDescriptor;
    var candidateComponents;
    var replacedCandidates = [];
    var i;
    for (shorthandName in candidates) {
      if (invalidatedBy !== undefined && shorthandName == invalidatedBy.name) {
        continue;
      }
      shorthandDescriptor = configuration[shorthandName];
      candidateComponents = candidates[shorthandName];
      if (invalidatedBy && invalidates(candidates, shorthandName, invalidatedBy)) {
        delete candidates[shorthandName];
        continue;
      }
      if (shorthandDescriptor.components.length > Object.keys(candidateComponents).length) {
        continue;
      }
      if (mixedImportance(candidateComponents)) {
        continue;
      }
      if (!overridable(candidateComponents, shorthandName, validator)) {
        continue;
      }
      if (!mergeable(candidateComponents)) {
        continue;
      }
      if (mixedInherit(candidateComponents)) {
        replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator);
      } else {
        replaceWithShorthand(properties, candidateComponents, shorthandName, validator);
      }
      replacedCandidates.push(shorthandName);
    }
    for (i = replacedCandidates.length - 1;i >= 0; i--) {
      delete candidates[replacedCandidates[i]];
    }
  };
  var invalidates = function(candidates, shorthandName, invalidatedBy) {
    var shorthandDescriptor = configuration[shorthandName];
    var invalidatedByDescriptor = configuration[invalidatedBy.name];
    var componentName;
    if ("overridesShorthands" in shorthandDescriptor && shorthandDescriptor.overridesShorthands.indexOf(invalidatedBy.name) > -1) {
      return true;
    }
    if (invalidatedByDescriptor && "componentOf" in invalidatedByDescriptor) {
      for (componentName in candidates[shorthandName]) {
        if (invalidatedByDescriptor.componentOf.indexOf(componentName) > -1) {
          return true;
        }
      }
    }
    return false;
  };
  var mixedImportance = function(components) {
    var important;
    var componentName;
    for (componentName in components) {
      if (important !== undefined && components[componentName].important != important) {
        return true;
      }
      important = components[componentName].important;
    }
    return false;
  };
  var overridable = function(components, shorthandName, validator) {
    var descriptor = configuration[shorthandName];
    var newValuePlaceholder = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, shorthandName],
      [Token.PROPERTY_VALUE, descriptor.defaultValue]
    ];
    var newProperty = wrapSingle(newValuePlaceholder);
    var component;
    var mayOverride;
    var i, l2;
    populateComponents([newProperty], validator, []);
    for (i = 0, l2 = descriptor.components.length;i < l2; i++) {
      component = components[descriptor.components[i]];
      mayOverride = configuration[component.name].canOverride || sameValue;
      if (!everyValuesPair(mayOverride.bind(null, validator), newProperty.components[i], component)) {
        return false;
      }
    }
    return true;
  };
  var sameValue = function(_validator, value1, value2) {
    return value1 === value2;
  };
  var mergeable = function(components) {
    var lastCount = null;
    var currentCount;
    var componentName;
    var component;
    var descriptor;
    var values;
    for (componentName in components) {
      component = components[componentName];
      descriptor = configuration[componentName];
      if (!("restore" in descriptor)) {
        continue;
      }
      restoreFromOptimizing([component.all[component.position]], restoreWithComponents);
      values = descriptor.restore(component, configuration);
      currentCount = values.length;
      if (lastCount !== null && currentCount !== lastCount) {
        return false;
      }
      lastCount = currentCount;
    }
    return true;
  };
  var mixedInherit = function(components) {
    var componentName;
    var lastValue = null;
    var currentValue;
    for (componentName in components) {
      currentValue = hasInherit(components[componentName]);
      if (lastValue !== null && lastValue !== currentValue) {
        return true;
      }
      lastValue = currentValue;
    }
    return false;
  };
  var replaceWithInheritBestFit = function(properties, candidateComponents, shorthandName, validator) {
    var viaLonghands = buildSequenceWithInheritLonghands(candidateComponents, shorthandName, validator);
    var viaShorthand = buildSequenceWithInheritShorthand(candidateComponents, shorthandName, validator);
    var longhandTokensSequence = viaLonghands[0];
    var shorthandTokensSequence = viaShorthand[0];
    var isLonghandsShorter = serializeBody(longhandTokensSequence).length < serializeBody(shorthandTokensSequence).length;
    var newTokensSequence = isLonghandsShorter ? longhandTokensSequence : shorthandTokensSequence;
    var newProperty = isLonghandsShorter ? viaLonghands[1] : viaShorthand[1];
    var newComponents = isLonghandsShorter ? viaLonghands[2] : viaShorthand[2];
    var lastComponent = candidateComponents[Object.keys(candidateComponents).pop()];
    var all2 = lastComponent.all;
    var insertAt = lastComponent.position;
    var componentName;
    var oldComponent;
    var newComponent;
    var newToken;
    newProperty.position = insertAt;
    newProperty.shorthand = true;
    newProperty.important = lastComponent.important;
    newProperty.multiplex = false;
    newProperty.dirty = true;
    newProperty.all = all2;
    newProperty.all[insertAt] = newTokensSequence[0];
    properties.splice(insertAt, 1, newProperty);
    for (componentName in candidateComponents) {
      oldComponent = candidateComponents[componentName];
      oldComponent.unused = true;
      newProperty.multiplex = newProperty.multiplex || oldComponent.multiplex;
      if (oldComponent.name in newComponents) {
        newComponent = newComponents[oldComponent.name];
        newToken = findTokenIn(newTokensSequence, componentName);
        newComponent.position = all2.length;
        newComponent.all = all2;
        newComponent.all.push(newToken);
        properties.push(newComponent);
      }
    }
  };
  var buildSequenceWithInheritLonghands = function(components, shorthandName, validator) {
    var tokensSequence = [];
    var inheritComponents = {};
    var nonInheritComponents = {};
    var descriptor = configuration[shorthandName];
    var shorthandToken = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, shorthandName],
      [Token.PROPERTY_VALUE, descriptor.defaultValue]
    ];
    var newProperty = wrapSingle(shorthandToken);
    var component;
    var longhandToken;
    var newComponent;
    var nameMetadata;
    var i, l2;
    populateComponents([newProperty], validator, []);
    for (i = 0, l2 = descriptor.components.length;i < l2; i++) {
      component = components[descriptor.components[i]];
      if (hasInherit(component)) {
        longhandToken = component.all[component.position].slice(0, 2);
        Array.prototype.push.apply(longhandToken, component.value);
        tokensSequence.push(longhandToken);
        newComponent = deepClone(component);
        newComponent.value = inferComponentValue(components, newComponent.name);
        newProperty.components[i] = newComponent;
        inheritComponents[component.name] = deepClone(component);
      } else {
        newComponent = deepClone(component);
        newComponent.all = component.all;
        newProperty.components[i] = newComponent;
        nonInheritComponents[component.name] = component;
      }
    }
    newProperty.important = components[Object.keys(components).pop()].important;
    nameMetadata = joinMetadata(nonInheritComponents, 1);
    shorthandToken[1].push(nameMetadata);
    restoreFromOptimizing([newProperty], restoreWithComponents);
    shorthandToken = shorthandToken.slice(0, 2);
    Array.prototype.push.apply(shorthandToken, newProperty.value);
    tokensSequence.unshift(shorthandToken);
    return [tokensSequence, newProperty, inheritComponents];
  };
  var inferComponentValue = function(components, propertyName) {
    var descriptor = configuration[propertyName];
    if ("oppositeTo" in descriptor) {
      return components[descriptor.oppositeTo].value;
    } else {
      return [[Token.PROPERTY_VALUE, descriptor.defaultValue]];
    }
  };
  var joinMetadata = function(components, at) {
    var metadata = [];
    var component;
    var originalValue;
    var componentMetadata;
    var componentName;
    for (componentName in components) {
      component = components[componentName];
      originalValue = component.all[component.position];
      componentMetadata = originalValue[at][originalValue[at].length - 1];
      Array.prototype.push.apply(metadata, componentMetadata);
    }
    return metadata.sort(metadataSorter);
  };
  var metadataSorter = function(metadata1, metadata2) {
    var line1 = metadata1[0];
    var line2 = metadata2[0];
    var column1 = metadata1[1];
    var column2 = metadata2[1];
    if (line1 < line2) {
      return -1;
    } else if (line1 === line2) {
      return column1 < column2 ? -1 : 1;
    } else {
      return 1;
    }
  };
  var buildSequenceWithInheritShorthand = function(components, shorthandName, validator) {
    var tokensSequence = [];
    var inheritComponents = {};
    var nonInheritComponents = {};
    var descriptor = configuration[shorthandName];
    var shorthandToken = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, shorthandName],
      [Token.PROPERTY_VALUE, "inherit"]
    ];
    var newProperty = wrapSingle(shorthandToken);
    var component;
    var longhandToken;
    var nameMetadata;
    var valueMetadata;
    var i, l2;
    populateComponents([newProperty], validator, []);
    for (i = 0, l2 = descriptor.components.length;i < l2; i++) {
      component = components[descriptor.components[i]];
      if (hasInherit(component)) {
        inheritComponents[component.name] = component;
      } else {
        longhandToken = component.all[component.position].slice(0, 2);
        Array.prototype.push.apply(longhandToken, component.value);
        tokensSequence.push(longhandToken);
        nonInheritComponents[component.name] = deepClone(component);
      }
    }
    nameMetadata = joinMetadata(inheritComponents, 1);
    shorthandToken[1].push(nameMetadata);
    valueMetadata = joinMetadata(inheritComponents, 2);
    shorthandToken[2].push(valueMetadata);
    tokensSequence.unshift(shorthandToken);
    return [tokensSequence, newProperty, nonInheritComponents];
  };
  var findTokenIn = function(tokens, componentName) {
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      if (tokens[i][1][1] == componentName) {
        return tokens[i];
      }
    }
  };
  var replaceWithShorthand = function(properties, candidateComponents, shorthandName, validator) {
    var descriptor = configuration[shorthandName];
    var nameMetadata;
    var valueMetadata;
    var newValuePlaceholder = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, shorthandName],
      [Token.PROPERTY_VALUE, descriptor.defaultValue]
    ];
    var all2;
    var insertAt = inferInsertAtFrom(properties, candidateComponents, shorthandName);
    var newProperty = wrapSingle(newValuePlaceholder);
    newProperty.shorthand = true;
    newProperty.dirty = true;
    newProperty.multiplex = false;
    populateComponents([newProperty], validator, []);
    for (var i = 0, l2 = descriptor.components.length;i < l2; i++) {
      var component = candidateComponents[descriptor.components[i]];
      newProperty.components[i] = deepClone(component);
      newProperty.important = component.important;
      newProperty.multiplex = newProperty.multiplex || component.multiplex;
      all2 = component.all;
    }
    for (var componentName in candidateComponents) {
      candidateComponents[componentName].unused = true;
    }
    nameMetadata = joinMetadata(candidateComponents, 1);
    newValuePlaceholder[1].push(nameMetadata);
    valueMetadata = joinMetadata(candidateComponents, 2);
    newValuePlaceholder[2].push(valueMetadata);
    newProperty.position = insertAt;
    newProperty.all = all2;
    newProperty.all[insertAt] = newValuePlaceholder;
    properties.splice(insertAt, 1, newProperty);
  };
  var inferInsertAtFrom = function(properties, candidateComponents, shorthandName) {
    var candidateComponentNames = Object.keys(candidateComponents);
    var firstCandidatePosition = candidateComponents[candidateComponentNames[0]].position;
    var lastCandidatePosition = candidateComponents[candidateComponentNames[candidateComponentNames.length - 1]].position;
    if (shorthandName == "border" && traversesVia(properties.slice(firstCandidatePosition, lastCandidatePosition), "border-image")) {
      return firstCandidatePosition;
    } else {
      return lastCandidatePosition;
    }
  };
  var traversesVia = function(properties, propertyName) {
    for (var i = properties.length - 1;i >= 0; i--) {
      if (properties[i].name == propertyName) {
        return true;
      }
    }
    return false;
  };
  var everyValuesPair = require_every_values_pair();
  var hasInherit = require_has_inherit();
  var hasSameValues = require_has_same_values();
  var populateComponents = require_populate_components();
  var configuration = require_configuration();
  var deepClone = require_clone().deep;
  var restoreWithComponents = require_restore_with_components();
  var restoreFromOptimizing = require_restore_from_optimizing();
  var wrapSingle = require_wrap_for_optimizing().single;
  var serializeBody = require_one_time().body;
  var Token = require_token();
  module.exports = mergeIntoShorthands;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/has-unset.js
var require_has_unset = __commonJS((exports, module) => {
  var hasUnset = function(property) {
    for (var i = property.value.length - 1;i >= 0; i--) {
      if (property.value[i][1] == "unset")
        return true;
    }
    return false;
  };
  module.exports = hasUnset;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/find-component-in.js
var require_find_component_in = __commonJS((exports, module) => {
  var findComponentIn = function(shorthand, longhand) {
    var comparator = nameComparator(longhand);
    return findInDirectComponents(shorthand, comparator) || findInSubComponents(shorthand, comparator);
  };
  var nameComparator = function(to) {
    return function(property) {
      return to.name === property.name;
    };
  };
  var findInDirectComponents = function(shorthand, comparator) {
    return shorthand.components.filter(comparator)[0];
  };
  var findInSubComponents = function(shorthand, comparator) {
    var shorthandComponent;
    var longhandMatch;
    var i, l2;
    if (!configuration[shorthand.name].shorthandComponents) {
      return;
    }
    for (i = 0, l2 = shorthand.components.length;i < l2; i++) {
      shorthandComponent = shorthand.components[i];
      longhandMatch = findInDirectComponents(shorthandComponent, comparator);
      if (longhandMatch) {
        return longhandMatch;
      }
    }
    return;
  };
  var configuration = require_configuration();
  module.exports = findComponentIn;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/is-component-of.js
var require_is_component_of = __commonJS((exports, module) => {
  var isComponentOf = function(property1, property2, shallow) {
    return isDirectComponentOf(property1, property2) || !shallow && !!configuration[property1.name].shorthandComponents && isSubComponentOf(property1, property2);
  };
  var isDirectComponentOf = function(property1, property2) {
    var descriptor = configuration[property1.name];
    return "components" in descriptor && descriptor.components.indexOf(property2.name) > -1;
  };
  var isSubComponentOf = function(property1, property2) {
    return property1.components.some(function(component) {
      return isDirectComponentOf(component, property2);
    });
  };
  var configuration = require_configuration();
  module.exports = isComponentOf;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/is-mergeable-shorthand.js
var require_is_mergeable_shorthand = __commonJS((exports, module) => {
  var isMergeableShorthand = function(shorthand) {
    if (shorthand.name != "font") {
      return true;
    }
    return shorthand.value[0][1].indexOf(Marker.INTERNAL) == -1;
  };
  var Marker = require_marker();
  module.exports = isMergeableShorthand;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/overrides-non-component-shorthand.js
var require_overrides_non_component_shorthand = __commonJS((exports, module) => {
  var overridesNonComponentShorthand = function(property1, property2) {
    return property1.name in configuration && "overridesShorthands" in configuration[property1.name] && configuration[property1.name].overridesShorthands.indexOf(property2.name) > -1;
  };
  var configuration = require_configuration();
  module.exports = overridesNonComponentShorthand;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/override-properties.js
var require_override_properties = __commonJS((exports, module) => {
  var sameValue = function(_validator, value1, value2) {
    return value1 === value2;
  };
  var wouldBreakCompatibility = function(property, validator) {
    for (var i = 0;i < property.components.length; i++) {
      var component = property.components[i];
      var descriptor = configuration[component.name];
      var canOverride = descriptor && descriptor.canOverride || sameValue;
      var _component = shallowClone(component);
      _component.value = [[Token.PROPERTY_VALUE, descriptor.defaultValue]];
      if (!everyValuesPair(canOverride.bind(null, validator), _component, component)) {
        return true;
      }
    }
    return false;
  };
  var overrideIntoMultiplex = function(property, by) {
    by.unused = true;
    turnIntoMultiplex(by, multiplexSize(property));
    property.value = by.value;
  };
  var overrideByMultiplex = function(property, by) {
    by.unused = true;
    property.multiplex = true;
    property.value = by.value;
  };
  var overrideSimple = function(property, by) {
    by.unused = true;
    property.value = by.value;
  };
  var override = function(property, by) {
    if (by.multiplex)
      overrideByMultiplex(property, by);
    else if (property.multiplex)
      overrideIntoMultiplex(property, by);
    else
      overrideSimple(property, by);
  };
  var overrideShorthand = function(property, by) {
    by.unused = true;
    for (var i = 0, l2 = property.components.length;i < l2; i++) {
      override(property.components[i], by.components[i]);
    }
  };
  var turnIntoMultiplex = function(property, size) {
    property.multiplex = true;
    if (configuration[property.name].shorthand) {
      turnShorthandValueIntoMultiplex(property, size);
    } else {
      turnLonghandValueIntoMultiplex(property, size);
    }
  };
  var turnShorthandValueIntoMultiplex = function(property, size) {
    var component;
    var i, l2;
    for (i = 0, l2 = property.components.length;i < l2; i++) {
      component = property.components[i];
      if (!component.multiplex) {
        turnLonghandValueIntoMultiplex(component, size);
      }
    }
  };
  var turnLonghandValueIntoMultiplex = function(property, size) {
    var descriptor = configuration[property.name];
    var withRealValue = descriptor.intoMultiplexMode == "real";
    var withValue = descriptor.intoMultiplexMode == "real" ? property.value.slice(0) : descriptor.intoMultiplexMode == "placeholder" ? descriptor.placeholderValue : descriptor.defaultValue;
    var i = multiplexSize(property);
    var j2;
    var m2 = withValue.length;
    for (;i < size; i++) {
      property.value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      if (Array.isArray(withValue)) {
        for (j2 = 0;j2 < m2; j2++) {
          property.value.push(withRealValue ? withValue[j2] : [Token.PROPERTY_VALUE, withValue[j2]]);
        }
      } else {
        property.value.push(withRealValue ? withValue : [Token.PROPERTY_VALUE, withValue]);
      }
    }
  };
  var multiplexSize = function(component) {
    var size = 0;
    for (var i = 0, l2 = component.value.length;i < l2; i++) {
      if (component.value[i][1] == Marker.COMMA)
        size++;
    }
    return size + 1;
  };
  var lengthOf = function(property) {
    var fakeAsArray = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, property.name]
    ].concat(property.value);
    return serializeProperty([fakeAsArray], 0).length;
  };
  var moreSameShorthands = function(properties, startAt, name) {
    var count = 0;
    for (var i = startAt;i >= 0; i--) {
      if (properties[i].name == name && !properties[i].unused)
        count++;
      if (count > 1)
        break;
    }
    return count > 1;
  };
  var overridingFunction = function(shorthand, validator) {
    for (var i = 0, l2 = shorthand.components.length;i < l2; i++) {
      if (!anyValue(validator.isUrl, shorthand.components[i]) && anyValue(validator.isFunction, shorthand.components[i])) {
        return true;
      }
    }
    return false;
  };
  var anyValue = function(fn, property) {
    for (var i = 0, l2 = property.value.length;i < l2; i++) {
      if (property.value[i][1] == Marker.COMMA)
        continue;
      if (fn(property.value[i][1]))
        return true;
    }
    return false;
  };
  var wouldResultInLongerValue = function(left, right) {
    if (!left.multiplex && !right.multiplex || left.multiplex && right.multiplex)
      return false;
    var multiplex = left.multiplex ? left : right;
    var simple = left.multiplex ? right : left;
    var component;
    var multiplexClone = deepClone(multiplex);
    restoreFromOptimizing([multiplexClone], restoreWithComponents);
    var simpleClone = deepClone(simple);
    restoreFromOptimizing([simpleClone], restoreWithComponents);
    var lengthBefore = lengthOf(multiplexClone) + 1 + lengthOf(simpleClone);
    if (left.multiplex) {
      component = findComponentIn(multiplexClone, simpleClone);
      overrideIntoMultiplex(component, simpleClone);
    } else {
      component = findComponentIn(simpleClone, multiplexClone);
      turnIntoMultiplex(simpleClone, multiplexSize(multiplexClone));
      overrideByMultiplex(component, multiplexClone);
    }
    restoreFromOptimizing([simpleClone], restoreWithComponents);
    var lengthAfter = lengthOf(simpleClone);
    return lengthBefore <= lengthAfter;
  };
  var isCompactable = function(property) {
    return property.name in configuration;
  };
  var noneOverrideHack = function(left, right) {
    return !left.multiplex && (left.name == "background" || left.name == "background-image") && right.multiplex && (right.name == "background" || right.name == "background-image") && anyLayerIsNone(right.value);
  };
  var anyLayerIsNone = function(values) {
    var layers = intoLayers(values);
    for (var i = 0, l2 = layers.length;i < l2; i++) {
      if (layers[i].length == 1 && layers[i][0][1] == "none")
        return true;
    }
    return false;
  };
  var intoLayers = function(values) {
    var layers = [];
    for (var i = 0, layer = [], l2 = values.length;i < l2; i++) {
      var value = values[i];
      if (value[1] == Marker.COMMA) {
        layers.push(layer);
        layer = [];
      } else {
        layer.push(value);
      }
    }
    layers.push(layer);
    return layers;
  };
  var overrideProperties = function(properties, withMerging, compatibility, validator) {
    var mayOverride, right, left, component;
    var overriddenComponents;
    var overriddenComponent;
    var overridingComponent;
    var overridable;
    var i, j2, k2;
    propertyLoop:
      for (i = properties.length - 1;i >= 0; i--) {
        right = properties[i];
        if (!isCompactable(right))
          continue;
        if (right.block)
          continue;
        mayOverride = configuration[right.name].canOverride || sameValue;
        traverseLoop:
          for (j2 = i - 1;j2 >= 0; j2--) {
            left = properties[j2];
            if (!isCompactable(left))
              continue;
            if (left.block)
              continue;
            if (left.dynamic || right.dynamic)
              continue;
            if (left.unused || right.unused)
              continue;
            if (left.hack && !right.hack && !right.important || !left.hack && !left.important && right.hack)
              continue;
            if (left.important == right.important && left.hack[0] != right.hack[0])
              continue;
            if (left.important == right.important && (left.hack[0] != right.hack[0] || left.hack[1] && left.hack[1] != right.hack[1]))
              continue;
            if (hasInherit(right))
              continue;
            if (noneOverrideHack(left, right))
              continue;
            if (right.shorthand && isComponentOf(right, left)) {
              if (!right.important && left.important)
                continue;
              if (!sameVendorPrefixesIn([left], right.components))
                continue;
              if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator))
                continue;
              if (!isMergeableShorthand(right)) {
                left.unused = true;
                continue;
              }
              component = findComponentIn(right, left);
              mayOverride = configuration[left.name].canOverride || sameValue;
              if (everyValuesPair(mayOverride.bind(null, validator), left, component)) {
                left.unused = true;
              }
            } else if (right.shorthand && overridesNonComponentShorthand(right, left)) {
              if (!right.important && left.important) {
                continue;
              }
              if (!sameVendorPrefixesIn([left], right.components)) {
                continue;
              }
              if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) {
                continue;
              }
              overriddenComponents = left.shorthand ? left.components : [left];
              for (k2 = overriddenComponents.length - 1;k2 >= 0; k2--) {
                overriddenComponent = overriddenComponents[k2];
                overridingComponent = findComponentIn(right, overriddenComponent);
                mayOverride = configuration[overriddenComponent.name].canOverride || sameValue;
                if (!everyValuesPair(mayOverride.bind(null, validator), left, overridingComponent)) {
                  continue traverseLoop;
                }
              }
              left.unused = true;
            } else if (withMerging && left.shorthand && !right.shorthand && isComponentOf(left, right, true)) {
              if (right.important && !left.important)
                continue;
              if (!right.important && left.important) {
                right.unused = true;
                continue;
              }
              if (moreSameShorthands(properties, i - 1, left.name))
                continue;
              if (overridingFunction(left, validator))
                continue;
              if (!isMergeableShorthand(left))
                continue;
              if (hasUnset(left) || hasUnset(right))
                continue;
              component = findComponentIn(left, right);
              if (everyValuesPair(mayOverride.bind(null, validator), component, right)) {
                var disabledBackgroundMerging = !compatibility.properties.backgroundClipMerging && component.name.indexOf("background-clip") > -1 || !compatibility.properties.backgroundOriginMerging && component.name.indexOf("background-origin") > -1 || !compatibility.properties.backgroundSizeMerging && component.name.indexOf("background-size") > -1;
                var nonMergeableValue = configuration[right.name].nonMergeableValue === right.value[0][1];
                if (disabledBackgroundMerging || nonMergeableValue)
                  continue;
                if (!compatibility.properties.merging && wouldBreakCompatibility(left, validator))
                  continue;
                if (component.value[0][1] != right.value[0][1] && (hasInherit(left) || hasInherit(right)))
                  continue;
                if (wouldResultInLongerValue(left, right))
                  continue;
                if (!left.multiplex && right.multiplex)
                  turnIntoMultiplex(left, multiplexSize(right));
                override(component, right);
                left.dirty = true;
              }
            } else if (withMerging && left.shorthand && right.shorthand && left.name == right.name) {
              if (!left.multiplex && right.multiplex)
                continue;
              if (!right.important && left.important) {
                right.unused = true;
                continue propertyLoop;
              }
              if (right.important && !left.important) {
                left.unused = true;
                continue;
              }
              if (!isMergeableShorthand(right)) {
                left.unused = true;
                continue;
              }
              for (k2 = left.components.length - 1;k2 >= 0; k2--) {
                var leftComponent = left.components[k2];
                var rightComponent = right.components[k2];
                mayOverride = configuration[leftComponent.name].canOverride || sameValue;
                if (!everyValuesPair(mayOverride.bind(null, validator), leftComponent, rightComponent))
                  continue propertyLoop;
              }
              overrideShorthand(left, right);
              left.dirty = true;
            } else if (withMerging && left.shorthand && right.shorthand && isComponentOf(left, right)) {
              if (!left.important && right.important)
                continue;
              component = findComponentIn(left, right);
              mayOverride = configuration[right.name].canOverride || sameValue;
              if (!everyValuesPair(mayOverride.bind(null, validator), component, right))
                continue;
              if (left.important && !right.important) {
                right.unused = true;
                continue;
              }
              var rightRestored = configuration[right.name].restore(right, configuration);
              if (rightRestored.length > 1)
                continue;
              component = findComponentIn(left, right);
              override(component, right);
              right.dirty = true;
            } else if (left.name == right.name) {
              overridable = true;
              if (right.shorthand) {
                for (k2 = right.components.length - 1;k2 >= 0 && overridable; k2--) {
                  overriddenComponent = left.components[k2];
                  overridingComponent = right.components[k2];
                  mayOverride = configuration[overridingComponent.name].canOverride || sameValue;
                  overridable = everyValuesPair(mayOverride.bind(null, validator), overriddenComponent, overridingComponent);
                }
              } else {
                mayOverride = configuration[right.name].canOverride || sameValue;
                overridable = everyValuesPair(mayOverride.bind(null, validator), left, right);
              }
              if (left.important && !right.important && overridable) {
                right.unused = true;
                continue;
              }
              if (!left.important && right.important && overridable) {
                left.unused = true;
                continue;
              }
              if (!overridable) {
                continue;
              }
              left.unused = true;
            }
          }
      }
  };
  var hasInherit = require_has_inherit();
  var hasUnset = require_has_unset();
  var everyValuesPair = require_every_values_pair();
  var findComponentIn = require_find_component_in();
  var isComponentOf = require_is_component_of();
  var isMergeableShorthand = require_is_mergeable_shorthand();
  var overridesNonComponentShorthand = require_overrides_non_component_shorthand();
  var sameVendorPrefixesIn = require_vendor_prefixes().same;
  var configuration = require_configuration();
  var deepClone = require_clone().deep;
  var restoreWithComponents = require_restore_with_components();
  var shallowClone = require_clone().shallow;
  var restoreFromOptimizing = require_restore_from_optimizing();
  var Token = require_token();
  var Marker = require_marker();
  var serializeProperty = require_one_time().property;
  module.exports = overrideProperties;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/optimize.js
var require_optimize3 = __commonJS((exports, module) => {
  var optimizeProperties = function(properties, withOverriding, withMerging, context) {
    var levelOptions = context.options.level[OptimizationLevel.Two];
    var _properties = wrapForOptimizing(properties, levelOptions.skipProperties);
    var _property;
    var i, l2;
    populateComponents(_properties, context.validator, context.warnings);
    for (i = 0, l2 = _properties.length;i < l2; i++) {
      _property = _properties[i];
      if (_property.block) {
        optimizeProperties(_property.value[0][1], withOverriding, withMerging, context);
      }
    }
    if (withMerging && levelOptions.mergeIntoShorthands) {
      mergeIntoShorthands(_properties, context.validator);
    }
    if (withOverriding && levelOptions.overrideProperties) {
      overrideProperties(_properties, withMerging, context.options.compatibility, context.validator);
    }
    restoreFromOptimizing(_properties, restoreWithComponents);
    removeUnused(_properties);
  };
  var mergeIntoShorthands = require_merge_into_shorthands();
  var overrideProperties = require_override_properties();
  var populateComponents = require_populate_components();
  var restoreWithComponents = require_restore_with_components();
  var wrapForOptimizing = require_wrap_for_optimizing().all;
  var removeUnused = require_remove_unused();
  var restoreFromOptimizing = require_restore_from_optimizing();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  module.exports = optimizeProperties;
});

// node_modules/clean-css/lib/optimizer/level-2/merge-adjacent.js
var require_merge_adjacent = __commonJS((exports, module) => {
  var mergeAdjacent = function(tokens, context) {
    var lastToken = [null, [], []];
    var options = context.options;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var mergeLimit = options.compatibility.selectors.mergeLimit;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      var token = tokens[i];
      if (token[0] != Token.RULE) {
        lastToken = [null, [], []];
        continue;
      }
      if (lastToken[0] == Token.RULE && serializeRules(token[1]) == serializeRules(lastToken[1])) {
        Array.prototype.push.apply(lastToken[2], token[2]);
        optimizeProperties(lastToken[2], true, true, context);
        token[2] = [];
      } else if (lastToken[0] == Token.RULE && serializeBody(token[2]) == serializeBody(lastToken[2]) && isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && isMergeable(serializeRules(lastToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && lastToken[1].length < mergeLimit) {
        lastToken[1] = tidyRules(lastToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
        lastToken[1] = lastToken.length > 1 ? sortSelectors(lastToken[1], selectorsSortingMethod) : lastToken[1];
        token[2] = [];
      } else {
        lastToken = token;
      }
    }
  };
  var isMergeable = require_is_mergeable();
  var optimizeProperties = require_optimize3();
  var sortSelectors = require_sort_selectors();
  var tidyRules = require_tidy_rules();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  var Token = require_token();
  module.exports = mergeAdjacent;
});

// node_modules/clean-css/lib/optimizer/level-2/rules-overlap.js
var require_rules_overlap = __commonJS((exports, module) => {
  var rulesOverlap = function(rule1, rule2, bemMode) {
    var scope1;
    var scope2;
    var i, l2;
    var j2, m2;
    for (i = 0, l2 = rule1.length;i < l2; i++) {
      scope1 = rule1[i][1];
      for (j2 = 0, m2 = rule2.length;j2 < m2; j2++) {
        scope2 = rule2[j2][1];
        if (scope1 == scope2) {
          return true;
        }
        if (bemMode && withoutModifiers(scope1) == withoutModifiers(scope2)) {
          return true;
        }
      }
    }
    return false;
  };
  var withoutModifiers = function(scope) {
    return scope.replace(MODIFIER_PATTERN, "");
  };
  var MODIFIER_PATTERN = /\-\-.+$/;
  module.exports = rulesOverlap;
});

// node_modules/clean-css/lib/optimizer/level-2/specificity.js
var require_specificity = __commonJS((exports, module) => {
  var specificity = function(selector) {
    var result = [0, 0, 0];
    var character;
    var isEscaped;
    var isSingleQuoted;
    var isDoubleQuoted;
    var roundBracketLevel = 0;
    var couldIntroduceNewTypeSelector;
    var withinNotPseudoClass = false;
    var wasPseudoClass = false;
    var i, l2;
    for (i = 0, l2 = selector.length;i < l2; i++) {
      character = selector[i];
      if (isEscaped) {
      } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
        isSingleQuoted = true;
      } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && isSingleQuoted) {
        isSingleQuoted = false;
      } else if (character == Marker.DOUBLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
        isDoubleQuoted = true;
      } else if (character == Marker.DOUBLE_QUOTE && isDoubleQuoted && !isSingleQuoted) {
        isDoubleQuoted = false;
      } else if (isSingleQuoted || isDoubleQuoted) {
        continue;
      } else if (roundBracketLevel > 0 && !withinNotPseudoClass) {
      } else if (character == Marker.OPEN_ROUND_BRACKET) {
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1) {
        roundBracketLevel--;
        withinNotPseudoClass = false;
      } else if (character == Marker.CLOSE_ROUND_BRACKET) {
        roundBracketLevel--;
      } else if (character == Selector.HASH) {
        result[0]++;
      } else if (character == Selector.DOT || character == Marker.OPEN_SQUARE_BRACKET) {
        result[1]++;
      } else if (character == Selector.PSEUDO && !wasPseudoClass && !isNotPseudoClass(selector, i)) {
        result[1]++;
        withinNotPseudoClass = false;
      } else if (character == Selector.PSEUDO) {
        withinNotPseudoClass = true;
      } else if ((i === 0 || couldIntroduceNewTypeSelector) && LETTER_PATTERN.test(character)) {
        result[2]++;
      }
      isEscaped = character == Marker.BACK_SLASH;
      wasPseudoClass = character == Selector.PSEUDO;
      couldIntroduceNewTypeSelector = !isEscaped && SEPARATOR_PATTERN.test(character);
    }
    return result;
  };
  var isNotPseudoClass = function(selector, index) {
    return selector.indexOf(NOT_PREFIX, index) === index;
  };
  var Marker = require_marker();
  var Selector = {
    ADJACENT_SIBLING: "+",
    DESCENDANT: ">",
    DOT: ".",
    HASH: "#",
    NON_ADJACENT_SIBLING: "~",
    PSEUDO: ":"
  };
  var LETTER_PATTERN = /[a-zA-Z]/;
  var NOT_PREFIX = ":not(";
  var SEPARATOR_PATTERN = /[\s,\(>~\+]/;
  module.exports = specificity;
});

// node_modules/clean-css/lib/optimizer/level-2/specificities-overlap.js
var require_specificities_overlap = __commonJS((exports, module) => {
  var specificitiesOverlap = function(selector1, selector2, cache) {
    var specificity1;
    var specificity2;
    var i, l2;
    var j2, m2;
    for (i = 0, l2 = selector1.length;i < l2; i++) {
      specificity1 = findSpecificity(selector1[i][1], cache);
      for (j2 = 0, m2 = selector2.length;j2 < m2; j2++) {
        specificity2 = findSpecificity(selector2[j2][1], cache);
        if (specificity1[0] === specificity2[0] && specificity1[1] === specificity2[1] && specificity1[2] === specificity2[2]) {
          return true;
        }
      }
    }
    return false;
  };
  var findSpecificity = function(selector, cache) {
    var value;
    if (!(selector in cache)) {
      cache[selector] = value = specificity(selector);
    }
    return value || cache[selector];
  };
  var specificity = require_specificity();
  module.exports = specificitiesOverlap;
});

// node_modules/clean-css/lib/optimizer/level-2/reorderable.js
var require_reorderable = __commonJS((exports, module) => {
  var canReorder = function(left, right, cache) {
    for (var i = right.length - 1;i >= 0; i--) {
      for (var j2 = left.length - 1;j2 >= 0; j2--) {
        if (!canReorderSingle(left[j2], right[i], cache))
          return false;
      }
    }
    return true;
  };
  var canReorderSingle = function(left, right, cache) {
    var leftName = left[0];
    var leftValue = left[1];
    var leftNameRoot = left[2];
    var leftSelector = left[5];
    var leftInSpecificSelector = left[6];
    var rightName = right[0];
    var rightValue = right[1];
    var rightNameRoot = right[2];
    var rightSelector = right[5];
    var rightInSpecificSelector = right[6];
    if (leftName == "font" && rightName == "line-height" || rightName == "font" && leftName == "line-height")
      return false;
    if (FLEX_PROPERTIES.test(leftName) && FLEX_PROPERTIES.test(rightName))
      return false;
    if (leftNameRoot == rightNameRoot && unprefixed(leftName) == unprefixed(rightName) && vendorPrefixed(leftName) ^ vendorPrefixed(rightName))
      return false;
    if (leftNameRoot == "border" && BORDER_PROPERTIES.test(rightNameRoot) && (leftName == "border" || leftName == rightNameRoot || leftValue != rightValue && sameBorderComponent(leftName, rightName)))
      return false;
    if (rightNameRoot == "border" && BORDER_PROPERTIES.test(leftNameRoot) && (rightName == "border" || rightName == leftNameRoot || leftValue != rightValue && sameBorderComponent(leftName, rightName)))
      return false;
    if (leftNameRoot == "border" && rightNameRoot == "border" && leftName != rightName && (isSideBorder(leftName) && isStyleBorder(rightName) || isStyleBorder(leftName) && isSideBorder(rightName)))
      return false;
    if (leftNameRoot != rightNameRoot)
      return true;
    if (leftName == rightName && leftNameRoot == rightNameRoot && (leftValue == rightValue || withDifferentVendorPrefix(leftValue, rightValue)))
      return true;
    if (leftName != rightName && leftNameRoot == rightNameRoot && leftName != leftNameRoot && rightName != rightNameRoot)
      return true;
    if (leftName != rightName && leftNameRoot == rightNameRoot && leftValue == rightValue)
      return true;
    if (rightInSpecificSelector && leftInSpecificSelector && !inheritable(leftNameRoot) && !inheritable(rightNameRoot) && !rulesOverlap(rightSelector, leftSelector, false))
      return true;
    if (!specificitiesOverlap(leftSelector, rightSelector, cache))
      return true;
    return false;
  };
  var vendorPrefixed = function(name) {
    return /^\-(?:moz|webkit|ms|o)\-/.test(name);
  };
  var unprefixed = function(name) {
    return name.replace(/^\-(?:moz|webkit|ms|o)\-/, "");
  };
  var sameBorderComponent = function(name1, name2) {
    return name1.split("-").pop() == name2.split("-").pop();
  };
  var isSideBorder = function(name) {
    return name == "border-top" || name == "border-right" || name == "border-bottom" || name == "border-left";
  };
  var isStyleBorder = function(name) {
    return name == "border-color" || name == "border-style" || name == "border-width";
  };
  var withDifferentVendorPrefix = function(value1, value2) {
    return vendorPrefixed(value1) && vendorPrefixed(value2) && value1.split("-")[1] != value2.split("-")[2];
  };
  var inheritable = function(name) {
    return name == "font" || name == "line-height" || name == "list-style";
  };
  var rulesOverlap = require_rules_overlap();
  var specificitiesOverlap = require_specificities_overlap();
  var FLEX_PROPERTIES = /align\-items|box\-align|box\-pack|flex|justify/;
  var BORDER_PROPERTIES = /^border\-(top|right|bottom|left|color|style|width|radius)/;
  module.exports = {
    canReorder,
    canReorderSingle
  };
});

// node_modules/clean-css/lib/optimizer/level-2/extract-properties.js
var require_extract_properties = __commonJS((exports, module) => {
  var extractProperties = function(token) {
    var properties = [];
    var inSpecificSelector;
    var property;
    var name;
    var value;
    var i, l2;
    if (token[0] == Token.RULE) {
      inSpecificSelector = !/[\.\+>~]/.test(serializeRules(token[1]));
      for (i = 0, l2 = token[2].length;i < l2; i++) {
        property = token[2][i];
        if (property[0] != Token.PROPERTY)
          continue;
        name = property[1][1];
        if (name.length === 0)
          continue;
        value = serializeValue(property, i);
        properties.push([
          name,
          value,
          findNameRoot(name),
          token[2][i],
          name + ":" + value,
          token[1],
          inSpecificSelector
        ]);
      }
    } else if (token[0] == Token.NESTED_BLOCK) {
      for (i = 0, l2 = token[2].length;i < l2; i++) {
        properties = properties.concat(extractProperties(token[2][i]));
      }
    }
    return properties;
  };
  var findNameRoot = function(name) {
    if (name == "list-style")
      return name;
    if (name.indexOf("-radius") > 0)
      return "border-radius";
    if (name == "border-collapse" || name == "border-spacing" || name == "border-image")
      return name;
    if (name.indexOf("border-") === 0 && /^border\-\w+\-\w+$/.test(name))
      return name.match(/border\-\w+/)[0];
    if (name.indexOf("border-") === 0 && /^border\-\w+$/.test(name))
      return "border";
    if (name.indexOf("text-") === 0)
      return name;
    if (name == "-chrome-")
      return name;
    return name.replace(/^\-\w+\-/, "").match(/([a-zA-Z]+)/)[0].toLowerCase();
  };
  var Token = require_token();
  var serializeRules = require_one_time().rules;
  var serializeValue = require_one_time().value;
  module.exports = extractProperties;
});

// node_modules/clean-css/lib/optimizer/level-2/merge-media-queries.js
var require_merge_media_queries = __commonJS((exports, module) => {
  var mergeMediaQueries = function(tokens, context) {
    var mergeSemantically = context.options.level[OptimizationLevel.Two].mergeSemantically;
    var specificityCache = context.cache.specificity;
    var candidates = {};
    var reduced = [];
    for (var i = tokens.length - 1;i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.NESTED_BLOCK) {
        continue;
      }
      var key = serializeRules(token[1]);
      var candidate = candidates[key];
      if (!candidate) {
        candidate = [];
        candidates[key] = candidate;
      }
      candidate.push(i);
    }
    for (var name in candidates) {
      var positions = candidates[name];
      positionLoop:
        for (var j2 = positions.length - 1;j2 > 0; j2--) {
          var positionOne = positions[j2];
          var tokenOne = tokens[positionOne];
          var positionTwo = positions[j2 - 1];
          var tokenTwo = tokens[positionTwo];
          directionLoop:
            for (var direction = 1;direction >= -1; direction -= 2) {
              var topToBottom = direction == 1;
              var from = topToBottom ? positionOne + 1 : positionTwo - 1;
              var to = topToBottom ? positionTwo : positionOne;
              var delta = topToBottom ? 1 : -1;
              var source = topToBottom ? tokenOne : tokenTwo;
              var target = topToBottom ? tokenTwo : tokenOne;
              var movedProperties = extractProperties(source);
              while (from != to) {
                var traversedProperties = extractProperties(tokens[from]);
                from += delta;
                if (mergeSemantically && allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache)) {
                  continue;
                }
                if (!canReorder(movedProperties, traversedProperties, specificityCache))
                  continue directionLoop;
              }
              target[2] = topToBottom ? source[2].concat(target[2]) : target[2].concat(source[2]);
              source[2] = [];
              reduced.push(target);
              continue positionLoop;
            }
        }
    }
    return reduced;
  };
  var allSameRulePropertiesCanBeReordered = function(movedProperties, traversedProperties, specificityCache) {
    var movedProperty;
    var movedRule;
    var traversedProperty;
    var traversedRule;
    var i, l2;
    var j2, m2;
    for (i = 0, l2 = movedProperties.length;i < l2; i++) {
      movedProperty = movedProperties[i];
      movedRule = movedProperty[5];
      for (j2 = 0, m2 = traversedProperties.length;j2 < m2; j2++) {
        traversedProperty = traversedProperties[j2];
        traversedRule = traversedProperty[5];
        if (rulesOverlap(movedRule, traversedRule, true) && !canReorderSingle(movedProperty, traversedProperty, specificityCache)) {
          return false;
        }
      }
    }
    return true;
  };
  var canReorder = require_reorderable().canReorder;
  var canReorderSingle = require_reorderable().canReorderSingle;
  var extractProperties = require_extract_properties();
  var rulesOverlap = require_rules_overlap();
  var serializeRules = require_one_time().rules;
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var Token = require_token();
  module.exports = mergeMediaQueries;
});

// node_modules/clean-css/lib/optimizer/level-2/merge-non-adjacent-by-body.js
var require_merge_non_adjacent_by_body = __commonJS((exports, module) => {
  var unsafeSelector = function(value) {
    return /\.|\*| :/.test(value);
  };
  var isBemElement = function(token) {
    var asString = serializeRules(token[1]);
    return asString.indexOf("__") > -1 || asString.indexOf("--") > -1;
  };
  var withoutModifier = function(selector) {
    return selector.replace(/--[^ ,>\+~:]+/g, "");
  };
  var removeAnyUnsafeElements = function(left, candidates) {
    var leftSelector = withoutModifier(serializeRules(left[1]));
    for (var body in candidates) {
      var right = candidates[body];
      var rightSelector = withoutModifier(serializeRules(right[1]));
      if (rightSelector.indexOf(leftSelector) > -1 || leftSelector.indexOf(rightSelector) > -1)
        delete candidates[body];
    }
  };
  var mergeNonAdjacentByBody = function(tokens, context) {
    var options = context.options;
    var mergeSemantically = options.level[OptimizationLevel.Two].mergeSemantically;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var candidates = {};
    for (var i = tokens.length - 1;i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.RULE)
        continue;
      if (token[2].length > 0 && (!mergeSemantically && unsafeSelector(serializeRules(token[1]))))
        candidates = {};
      if (token[2].length > 0 && mergeSemantically && isBemElement(token))
        removeAnyUnsafeElements(token, candidates);
      var candidateBody = serializeBody(token[2]);
      var oldToken = candidates[candidateBody];
      if (oldToken && isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && isMergeable(serializeRules(oldToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
        if (token[2].length > 0) {
          token[1] = tidyRules(oldToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
          token[1] = token[1].length > 1 ? sortSelectors(token[1], selectorsSortingMethod) : token[1];
        } else {
          token[1] = oldToken[1].concat(token[1]);
        }
        oldToken[2] = [];
        candidates[candidateBody] = null;
      }
      candidates[serializeBody(token[2])] = token;
    }
  };
  var isMergeable = require_is_mergeable();
  var sortSelectors = require_sort_selectors();
  var tidyRules = require_tidy_rules();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  var Token = require_token();
  module.exports = mergeNonAdjacentByBody;
});

// node_modules/clean-css/lib/optimizer/level-2/merge-non-adjacent-by-selector.js
var require_merge_non_adjacent_by_selector = __commonJS((exports, module) => {
  var mergeNonAdjacentBySelector = function(tokens, context) {
    var specificityCache = context.cache.specificity;
    var allSelectors = {};
    var repeatedSelectors = [];
    var i;
    for (i = tokens.length - 1;i >= 0; i--) {
      if (tokens[i][0] != Token.RULE)
        continue;
      if (tokens[i][2].length === 0)
        continue;
      var selector = serializeRules(tokens[i][1]);
      allSelectors[selector] = [i].concat(allSelectors[selector] || []);
      if (allSelectors[selector].length == 2)
        repeatedSelectors.push(selector);
    }
    for (i = repeatedSelectors.length - 1;i >= 0; i--) {
      var positions = allSelectors[repeatedSelectors[i]];
      selectorIterator:
        for (var j2 = positions.length - 1;j2 > 0; j2--) {
          var positionOne = positions[j2 - 1];
          var tokenOne = tokens[positionOne];
          var positionTwo = positions[j2];
          var tokenTwo = tokens[positionTwo];
          directionIterator:
            for (var direction = 1;direction >= -1; direction -= 2) {
              var topToBottom = direction == 1;
              var from = topToBottom ? positionOne + 1 : positionTwo - 1;
              var to = topToBottom ? positionTwo : positionOne;
              var delta = topToBottom ? 1 : -1;
              var moved = topToBottom ? tokenOne : tokenTwo;
              var target = topToBottom ? tokenTwo : tokenOne;
              var movedProperties = extractProperties(moved);
              while (from != to) {
                var traversedProperties = extractProperties(tokens[from]);
                from += delta;
                var reorderable = topToBottom ? canReorder(movedProperties, traversedProperties, specificityCache) : canReorder(traversedProperties, movedProperties, specificityCache);
                if (!reorderable && !topToBottom)
                  continue selectorIterator;
                if (!reorderable && topToBottom)
                  continue directionIterator;
              }
              if (topToBottom) {
                Array.prototype.push.apply(moved[2], target[2]);
                target[2] = moved[2];
              } else {
                Array.prototype.push.apply(target[2], moved[2]);
              }
              optimizeProperties(target[2], true, true, context);
              moved[2] = [];
            }
        }
    }
  };
  var canReorder = require_reorderable().canReorder;
  var extractProperties = require_extract_properties();
  var optimizeProperties = require_optimize3();
  var serializeRules = require_one_time().rules;
  var Token = require_token();
  module.exports = mergeNonAdjacentBySelector;
});

// node_modules/clean-css/lib/utils/clone-array.js
var require_clone_array = __commonJS((exports, module) => {
  var cloneArray = function(array) {
    var cloned = array.slice(0);
    for (var i = 0, l2 = cloned.length;i < l2; i++) {
      if (Array.isArray(cloned[i]))
        cloned[i] = cloneArray(cloned[i]);
    }
    return cloned;
  };
  module.exports = cloneArray;
});

// node_modules/clean-css/lib/optimizer/level-2/reduce-non-adjacent.js
var require_reduce_non_adjacent = __commonJS((exports, module) => {
  var reduceNonAdjacent = function(tokens, context) {
    var options = context.options;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var candidates = {};
    var repeated = [];
    for (var i = tokens.length - 1;i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.RULE) {
        continue;
      } else if (token[2].length === 0) {
        continue;
      }
      var selectorAsString = serializeRules(token[1]);
      var isComplexAndNotSpecial = token[1].length > 1 && isMergeable(selectorAsString, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging);
      var wrappedSelectors = wrappedSelectorsFrom(token[1]);
      var selectors = isComplexAndNotSpecial ? [selectorAsString].concat(wrappedSelectors) : [selectorAsString];
      for (var j2 = 0, m2 = selectors.length;j2 < m2; j2++) {
        var selector = selectors[j2];
        if (!candidates[selector])
          candidates[selector] = [];
        else
          repeated.push(selector);
        candidates[selector].push({
          where: i,
          list: wrappedSelectors,
          isPartial: isComplexAndNotSpecial && j2 > 0,
          isComplex: isComplexAndNotSpecial && j2 === 0
        });
      }
    }
    reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context);
    reduceComplexNonAdjacentCases(tokens, candidates, options, context);
  };
  var wrappedSelectorsFrom = function(list) {
    var wrapped = [];
    for (var i = 0;i < list.length; i++) {
      wrapped.push([list[i][1]]);
    }
    return wrapped;
  };
  var reduceSimpleNonAdjacentCases = function(tokens, repeated, candidates, options, context) {
    function filterOut(idx, bodies) {
      return data[idx].isPartial && bodies.length === 0;
    }
    function reduceBody(token, newBody, processedCount, tokenIdx) {
      if (!data[processedCount - tokenIdx - 1].isPartial)
        token[2] = newBody;
    }
    for (var i = 0, l2 = repeated.length;i < l2; i++) {
      var selector = repeated[i];
      var data = candidates[selector];
      reduceSelector(tokens, data, {
        filterOut,
        callback: reduceBody
      }, options, context);
    }
  };
  var reduceComplexNonAdjacentCases = function(tokens, candidates, options, context) {
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var localContext = {};
    function filterOut(idx) {
      return localContext.data[idx].where < localContext.intoPosition;
    }
    function collectReducedBodies(token, newBody, processedCount, tokenIdx) {
      if (tokenIdx === 0)
        localContext.reducedBodies.push(newBody);
    }
    allSelectors:
      for (var complexSelector in candidates) {
        var into = candidates[complexSelector];
        if (!into[0].isComplex)
          continue;
        var intoPosition = into[into.length - 1].where;
        var intoToken = tokens[intoPosition];
        var reducedBodies = [];
        var selectors = isMergeable(complexSelector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) ? into[0].list : [complexSelector];
        localContext.intoPosition = intoPosition;
        localContext.reducedBodies = reducedBodies;
        for (var j2 = 0, m2 = selectors.length;j2 < m2; j2++) {
          var selector = selectors[j2];
          var data = candidates[selector];
          if (data.length < 2)
            continue allSelectors;
          localContext.data = data;
          reduceSelector(tokens, data, {
            filterOut,
            callback: collectReducedBodies
          }, options, context);
          if (serializeBody(reducedBodies[reducedBodies.length - 1]) != serializeBody(reducedBodies[0]))
            continue allSelectors;
        }
        intoToken[2] = reducedBodies[0];
      }
  };
  var reduceSelector = function(tokens, data, context, options, outerContext) {
    var bodies = [];
    var bodiesAsList = [];
    var processedTokens = [];
    for (var j2 = data.length - 1;j2 >= 0; j2--) {
      if (context.filterOut(j2, bodies))
        continue;
      var where = data[j2].where;
      var token = tokens[where];
      var clonedBody = cloneArray(token[2]);
      bodies = bodies.concat(clonedBody);
      bodiesAsList.push(clonedBody);
      processedTokens.push(where);
    }
    optimizeProperties(bodies, true, false, outerContext);
    var processedCount = processedTokens.length;
    var propertyIdx = bodies.length - 1;
    var tokenIdx = processedCount - 1;
    while (tokenIdx >= 0) {
      if ((tokenIdx === 0 || bodies[propertyIdx] && bodiesAsList[tokenIdx].indexOf(bodies[propertyIdx]) > -1) && propertyIdx > -1) {
        propertyIdx--;
        continue;
      }
      var newBody = bodies.splice(propertyIdx + 1);
      context.callback(tokens[processedTokens[tokenIdx]], newBody, processedCount, tokenIdx);
      tokenIdx--;
    }
  };
  var isMergeable = require_is_mergeable();
  var optimizeProperties = require_optimize3();
  var cloneArray = require_clone_array();
  var Token = require_token();
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  module.exports = reduceNonAdjacent;
});

// node_modules/clean-css/lib/optimizer/level-2/remove-duplicate-font-at-rules.js
var require_remove_duplicate_font_at_rules = __commonJS((exports, module) => {
  var removeDuplicateFontAtRules = function(tokens) {
    var fontAtRules = [];
    var token;
    var key;
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      token = tokens[i];
      if (token[0] != Token.AT_RULE_BLOCK && token[1][0][1] != FONT_FACE_SCOPE) {
        continue;
      }
      key = serializeAll([token]);
      if (fontAtRules.indexOf(key) > -1) {
        token[2] = [];
      } else {
        fontAtRules.push(key);
      }
    }
  };
  var Token = require_token();
  var serializeAll = require_one_time().all;
  var FONT_FACE_SCOPE = "@font-face";
  module.exports = removeDuplicateFontAtRules;
});

// node_modules/clean-css/lib/optimizer/level-2/remove-duplicate-media-queries.js
var require_remove_duplicate_media_queries = __commonJS((exports, module) => {
  var removeDuplicateMediaQueries = function(tokens) {
    var candidates = {};
    var candidate;
    var token;
    var key;
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      token = tokens[i];
      if (token[0] != Token.NESTED_BLOCK) {
        continue;
      }
      key = serializeRules(token[1]) + "%" + serializeAll(token[2]);
      candidate = candidates[key];
      if (candidate) {
        candidate[2] = [];
      }
      candidates[key] = token;
    }
  };
  var Token = require_token();
  var serializeAll = require_one_time().all;
  var serializeRules = require_one_time().rules;
  module.exports = removeDuplicateMediaQueries;
});

// node_modules/clean-css/lib/optimizer/level-2/remove-duplicates.js
var require_remove_duplicates = __commonJS((exports, module) => {
  var removeDuplicates = function(tokens) {
    var matched = {};
    var moreThanOnce = [];
    var id, token;
    var body, bodies;
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      token = tokens[i];
      if (token[0] != Token.RULE)
        continue;
      id = serializeRules(token[1]);
      if (matched[id] && matched[id].length == 1)
        moreThanOnce.push(id);
      else
        matched[id] = matched[id] || [];
      matched[id].push(i);
    }
    for (i = 0, l2 = moreThanOnce.length;i < l2; i++) {
      id = moreThanOnce[i];
      bodies = [];
      for (var j2 = matched[id].length - 1;j2 >= 0; j2--) {
        token = tokens[matched[id][j2]];
        body = serializeBody(token[2]);
        if (bodies.indexOf(body) > -1)
          token[2] = [];
        else
          bodies.push(body);
      }
    }
  };
  var Token = require_token();
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  module.exports = removeDuplicates;
});

// node_modules/clean-css/lib/optimizer/level-2/remove-unused-at-rules.js
var require_remove_unused_at_rules = __commonJS((exports, module) => {
  var normalize = function(value) {
    return value.replace(optionalMatchingQuotesRegex, "$2").replace(importantRegex, "");
  };
  var removeUnusedAtRules = function(tokens, context) {
    removeUnusedAtRule(tokens, matchCounterStyle, markCounterStylesAsUsed, context);
    removeUnusedAtRule(tokens, matchFontFace, markFontFacesAsUsed, context);
    removeUnusedAtRule(tokens, matchKeyframe, markKeyframesAsUsed, context);
    removeUnusedAtRule(tokens, matchNamespace, markNamespacesAsUsed, context);
  };
  var removeUnusedAtRule = function(tokens, matchCallback, markCallback, context) {
    var atRules = {};
    var atRule;
    var atRuleTokens;
    var atRuleToken;
    var zeroAt;
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      matchCallback(tokens[i], atRules);
    }
    if (Object.keys(atRules).length === 0) {
      return;
    }
    markUsedAtRules(tokens, markCallback, atRules, context);
    for (atRule in atRules) {
      atRuleTokens = atRules[atRule];
      for (i = 0, l2 = atRuleTokens.length;i < l2; i++) {
        atRuleToken = atRuleTokens[i];
        zeroAt = atRuleToken[0] == Token.AT_RULE ? 1 : 2;
        atRuleToken[zeroAt] = [];
      }
    }
  };
  var markUsedAtRules = function(tokens, markCallback, atRules, context) {
    var boundMarkCallback = markCallback(atRules);
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      switch (tokens[i][0]) {
        case Token.RULE:
          boundMarkCallback(tokens[i], context);
          break;
        case Token.NESTED_BLOCK:
          markUsedAtRules(tokens[i][2], markCallback, atRules, context);
      }
    }
  };
  var matchCounterStyle = function(token, atRules) {
    var match;
    if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1].indexOf("@counter-style") === 0) {
      match = token[1][0][1].split(" ")[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  };
  var markCounterStylesAsUsed = function(atRules) {
    return function(token, context) {
      var property;
      var wrappedProperty;
      var i, l2;
      for (i = 0, l2 = token[2].length;i < l2; i++) {
        property = token[2][i];
        if (property[1][1] == "list-style") {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          if (wrappedProperty.components[0].value[0][1] in atRules) {
            delete atRules[property[2][1]];
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (property[1][1] == "list-style-type" && property[2][1] in atRules) {
          delete atRules[property[2][1]];
        }
      }
    };
  };
  var matchFontFace = function(token, atRules) {
    var property;
    var match;
    var i, l2;
    if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1] == "@font-face") {
      for (i = 0, l2 = token[2].length;i < l2; i++) {
        property = token[2][i];
        if (property[1][1] == "font-family") {
          match = normalize(property[2][1].toLowerCase());
          atRules[match] = atRules[match] || [];
          atRules[match].push(token);
          break;
        }
      }
    }
  };
  var markFontFacesAsUsed = function(atRules) {
    return function(token, context) {
      var property;
      var wrappedProperty;
      var component;
      var normalizedMatch;
      var i, l2;
      var j2, m2;
      for (i = 0, l2 = token[2].length;i < l2; i++) {
        property = token[2][i];
        if (property[1][1] == "font") {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          component = wrappedProperty.components[6];
          for (j2 = 0, m2 = component.value.length;j2 < m2; j2++) {
            normalizedMatch = normalize(component.value[j2][1].toLowerCase());
            if (normalizedMatch in atRules) {
              delete atRules[normalizedMatch];
            }
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (property[1][1] == "font-family") {
          for (j2 = 2, m2 = property.length;j2 < m2; j2++) {
            normalizedMatch = normalize(property[j2][1].toLowerCase());
            if (normalizedMatch in atRules) {
              delete atRules[normalizedMatch];
            }
          }
        }
      }
    };
  };
  var matchKeyframe = function(token, atRules) {
    var match;
    if (token[0] == Token.NESTED_BLOCK && keyframeRegex.test(token[1][0][1])) {
      match = token[1][0][1].split(" ")[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  };
  var markKeyframesAsUsed = function(atRules) {
    return function(token, context) {
      var property;
      var wrappedProperty;
      var component;
      var i, l2;
      var j2, m2;
      for (i = 0, l2 = token[2].length;i < l2; i++) {
        property = token[2][i];
        if (animationRegex.test(property[1][1])) {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          component = wrappedProperty.components[7];
          for (j2 = 0, m2 = component.value.length;j2 < m2; j2++) {
            if (component.value[j2][1] in atRules) {
              delete atRules[component.value[j2][1]];
            }
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (animationNameRegex.test(property[1][1])) {
          for (j2 = 2, m2 = property.length;j2 < m2; j2++) {
            if (property[j2][1] in atRules) {
              delete atRules[property[j2][1]];
            }
          }
        }
      }
    };
  };
  var matchNamespace = function(token, atRules) {
    var match;
    if (token[0] == Token.AT_RULE && token[1].indexOf("@namespace") === 0) {
      match = token[1].split(" ")[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  };
  var markNamespacesAsUsed = function(atRules) {
    var namespaceRegex = new RegExp(Object.keys(atRules).join("\\||") + "\\|", "g");
    return function(token) {
      var match;
      var scope;
      var normalizedMatch;
      var i, l2;
      var j2, m2;
      for (i = 0, l2 = token[1].length;i < l2; i++) {
        scope = token[1][i];
        match = scope[1].match(namespaceRegex);
        for (j2 = 0, m2 = match.length;j2 < m2; j2++) {
          normalizedMatch = match[j2].substring(0, match[j2].length - 1);
          if (normalizedMatch in atRules) {
            delete atRules[normalizedMatch];
          }
        }
      }
    };
  };
  var populateComponents = require_populate_components();
  var wrapForOptimizing = require_wrap_for_optimizing().single;
  var restoreFromOptimizing = require_restore_from_optimizing();
  var Token = require_token();
  var animationNameRegex = /^(\-moz\-|\-o\-|\-webkit\-)?animation-name$/;
  var animationRegex = /^(\-moz\-|\-o\-|\-webkit\-)?animation$/;
  var keyframeRegex = /^@(\-moz\-|\-o\-|\-webkit\-)?keyframes /;
  var importantRegex = /\s{0,31}!important$/;
  var optionalMatchingQuotesRegex = /^(['"]?)(.*)\1$/;
  module.exports = removeUnusedAtRules;
});

// node_modules/clean-css/lib/optimizer/level-2/tidy-rule-duplicates.js
var require_tidy_rule_duplicates = __commonJS((exports, module) => {
  var ruleSorter = function(s1, s2) {
    return s1[1] > s2[1] ? 1 : -1;
  };
  var tidyRuleDuplicates = function(rules) {
    var list = [];
    var repeated = [];
    for (var i = 0, l2 = rules.length;i < l2; i++) {
      var rule = rules[i];
      if (repeated.indexOf(rule[1]) == -1) {
        repeated.push(rule[1]);
        list.push(rule);
      }
    }
    return list.sort(ruleSorter);
  };
  module.exports = tidyRuleDuplicates;
});

// node_modules/clean-css/lib/optimizer/level-2/restructure.js
var require_restructure = __commonJS((exports, module) => {
  var naturalSorter = function(a2, b2) {
    return a2 > b2 ? 1 : -1;
  };
  var cloneAndMergeSelectors = function(propertyA, propertyB) {
    var cloned = cloneArray(propertyA);
    cloned[5] = cloned[5].concat(propertyB[5]);
    return cloned;
  };
  var restructure = function(tokens, context) {
    var options = context.options;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var mergeLimit = options.compatibility.selectors.mergeLimit;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var specificityCache = context.cache.specificity;
    var movableTokens = {};
    var movedProperties = [];
    var multiPropertyMoveCache = {};
    var movedToBeDropped = [];
    var maxCombinationsLevel = 2;
    var ID_JOIN_CHARACTER = "%";
    function sendToMultiPropertyMoveCache(position2, movedProperty2, allFits) {
      for (var i2 = allFits.length - 1;i2 >= 0; i2--) {
        var fit = allFits[i2][0];
        var id = addToCache(movedProperty2, fit);
        if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position2, multiPropertyMoveCache[id])) {
          removeAllMatchingFromCache(id);
          break;
        }
      }
    }
    function addToCache(movedProperty2, fit) {
      var id = cacheId(fit);
      multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];
      multiPropertyMoveCache[id].push([movedProperty2, fit]);
      return id;
    }
    function removeAllMatchingFromCache(matchId) {
      var matchSelectors = matchId.split(ID_JOIN_CHARACTER);
      var forRemoval = [];
      var i2;
      for (var id in multiPropertyMoveCache) {
        var selectors = id.split(ID_JOIN_CHARACTER);
        for (i2 = selectors.length - 1;i2 >= 0; i2--) {
          if (matchSelectors.indexOf(selectors[i2]) > -1) {
            forRemoval.push(id);
            break;
          }
        }
      }
      for (i2 = forRemoval.length - 1;i2 >= 0; i2--) {
        delete multiPropertyMoveCache[forRemoval[i2]];
      }
    }
    function cacheId(cachedTokens) {
      var id = [];
      for (var i2 = 0, l2 = cachedTokens.length;i2 < l2; i2++) {
        id.push(serializeRules(cachedTokens[i2][1]));
      }
      return id.join(ID_JOIN_CHARACTER);
    }
    function tokensToMerge(sourceTokens) {
      var uniqueTokensWithBody = [];
      var mergeableTokens = [];
      for (var i2 = sourceTokens.length - 1;i2 >= 0; i2--) {
        if (!isMergeable(serializeRules(sourceTokens[i2][1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
          continue;
        }
        mergeableTokens.unshift(sourceTokens[i2]);
        if (sourceTokens[i2][2].length > 0 && uniqueTokensWithBody.indexOf(sourceTokens[i2]) == -1)
          uniqueTokensWithBody.push(sourceTokens[i2]);
      }
      return uniqueTokensWithBody.length > 1 ? mergeableTokens : [];
    }
    function shortenIfPossible(position2, movedProperty2) {
      var name = movedProperty2[0];
      var value = movedProperty2[1];
      var key2 = movedProperty2[4];
      var valueSize = name.length + value.length + 1;
      var allSelectors = [];
      var qualifiedTokens = [];
      var mergeableTokens = tokensToMerge(movableTokens[key2]);
      if (mergeableTokens.length < 2)
        return;
      var allFits = findAllFits(mergeableTokens, valueSize, 1);
      var bestFit = allFits[0];
      if (bestFit[1] > 0)
        return sendToMultiPropertyMoveCache(position2, movedProperty2, allFits);
      for (var i2 = bestFit[0].length - 1;i2 >= 0; i2--) {
        allSelectors = bestFit[0][i2][1].concat(allSelectors);
        qualifiedTokens.unshift(bestFit[0][i2]);
      }
      allSelectors = tidyRuleDuplicates(allSelectors);
      dropAsNewTokenAt(position2, [movedProperty2], allSelectors, qualifiedTokens);
    }
    function fitSorter(fit1, fit2) {
      return fit1[1] > fit2[1] ? 1 : fit1[1] == fit2[1] ? 0 : -1;
    }
    function findAllFits(mergeableTokens, propertySize, propertiesCount) {
      var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);
      return combinations.sort(fitSorter);
    }
    function allCombinations(tokensVariant, propertySize, propertiesCount, level) {
      var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];
      if (tokensVariant.length > 2 && level > 0) {
        for (var i2 = tokensVariant.length - 1;i2 >= 0; i2--) {
          var subVariant = Array.prototype.slice.call(tokensVariant, 0);
          subVariant.splice(i2, 1);
          differenceVariants = differenceVariants.concat(allCombinations(subVariant, propertySize, propertiesCount, level - 1));
        }
      }
      return differenceVariants;
    }
    function sizeDifference(tokensVariant, propertySize, propertiesCount) {
      var allSelectorsSize = 0;
      for (var i2 = tokensVariant.length - 1;i2 >= 0; i2--) {
        allSelectorsSize += tokensVariant[i2][2].length > propertiesCount ? serializeRules(tokensVariant[i2][1]).length : -1;
      }
      return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;
    }
    function dropAsNewTokenAt(position2, properties2, allSelectors, mergeableTokens) {
      var i2, j3, k3, m3;
      var allProperties = [];
      for (i2 = mergeableTokens.length - 1;i2 >= 0; i2--) {
        var mergeableToken = mergeableTokens[i2];
        for (j3 = mergeableToken[2].length - 1;j3 >= 0; j3--) {
          var mergeableProperty = mergeableToken[2][j3];
          for (k3 = 0, m3 = properties2.length;k3 < m3; k3++) {
            var property2 = properties2[k3];
            var mergeablePropertyName = mergeableProperty[1][1];
            var propertyName = property2[0];
            var propertyBody = property2[4];
            if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {
              mergeableToken[2].splice(j3, 1);
              break;
            }
          }
        }
      }
      for (i2 = properties2.length - 1;i2 >= 0; i2--) {
        allProperties.unshift(properties2[i2][3]);
      }
      var newToken = [Token.RULE, allSelectors, allProperties];
      tokens.splice(position2, 0, newToken);
    }
    function dropPropertiesAt(position2, movedProperty2) {
      var key2 = movedProperty2[4];
      var toMove = movableTokens[key2];
      if (toMove && toMove.length > 1) {
        if (!shortenMultiMovesIfPossible(position2, movedProperty2))
          shortenIfPossible(position2, movedProperty2);
      }
    }
    function shortenMultiMovesIfPossible(position2, movedProperty2) {
      var candidates = [];
      var propertiesAndMergableTokens = [];
      var key2 = movedProperty2[4];
      var j3, k3;
      var mergeableTokens = tokensToMerge(movableTokens[key2]);
      if (mergeableTokens.length < 2)
        return;
      movableLoop:
        for (var value in movableTokens) {
          var tokensList = movableTokens[value];
          for (j3 = mergeableTokens.length - 1;j3 >= 0; j3--) {
            if (tokensList.indexOf(mergeableTokens[j3]) == -1)
              continue movableLoop;
          }
          candidates.push(value);
        }
      if (candidates.length < 2)
        return false;
      for (j3 = candidates.length - 1;j3 >= 0; j3--) {
        for (k3 = movedProperties.length - 1;k3 >= 0; k3--) {
          if (movedProperties[k3][4] == candidates[j3]) {
            propertiesAndMergableTokens.unshift([movedProperties[k3], mergeableTokens]);
            break;
          }
        }
      }
      return processMultiPropertyMove(position2, propertiesAndMergableTokens);
    }
    function processMultiPropertyMove(position2, propertiesAndMergableTokens) {
      var valueSize = 0;
      var properties2 = [];
      var property2;
      for (var i2 = propertiesAndMergableTokens.length - 1;i2 >= 0; i2--) {
        property2 = propertiesAndMergableTokens[i2][0];
        var fullValue = property2[4];
        valueSize += fullValue.length + (i2 > 0 ? 1 : 0);
        properties2.push(property2);
      }
      var mergeableTokens = propertiesAndMergableTokens[0][1];
      var bestFit = findAllFits(mergeableTokens, valueSize, properties2.length)[0];
      if (bestFit[1] > 0)
        return false;
      var allSelectors = [];
      var qualifiedTokens = [];
      for (i2 = bestFit[0].length - 1;i2 >= 0; i2--) {
        allSelectors = bestFit[0][i2][1].concat(allSelectors);
        qualifiedTokens.unshift(bestFit[0][i2]);
      }
      allSelectors = tidyRuleDuplicates(allSelectors);
      dropAsNewTokenAt(position2, properties2, allSelectors, qualifiedTokens);
      for (i2 = properties2.length - 1;i2 >= 0; i2--) {
        property2 = properties2[i2];
        var index = movedProperties.indexOf(property2);
        delete movableTokens[property2[4]];
        if (index > -1 && movedToBeDropped.indexOf(index) == -1)
          movedToBeDropped.push(index);
      }
      return true;
    }
    function boundToAnotherPropertyInCurrrentToken(property2, movedProperty2, token2) {
      var propertyName = property2[0];
      var movedPropertyName = movedProperty2[0];
      if (propertyName != movedPropertyName)
        return false;
      var key2 = movedProperty2[4];
      var toMove = movableTokens[key2];
      return toMove && toMove.indexOf(token2) > -1;
    }
    for (var i = tokens.length - 1;i >= 0; i--) {
      var token = tokens[i];
      var isRule;
      var j2, k2, m2;
      var samePropertyAt;
      if (token[0] == Token.RULE) {
        isRule = true;
      } else if (token[0] == Token.NESTED_BLOCK) {
        isRule = false;
      } else {
        continue;
      }
      var movedCount = movedProperties.length;
      var properties = extractProperties(token);
      movedToBeDropped = [];
      var unmovableInCurrentToken = [];
      for (j2 = properties.length - 1;j2 >= 0; j2--) {
        for (k2 = j2 - 1;k2 >= 0; k2--) {
          if (!canReorderSingle(properties[j2], properties[k2], specificityCache)) {
            unmovableInCurrentToken.push(j2);
            break;
          }
        }
      }
      for (j2 = properties.length - 1;j2 >= 0; j2--) {
        var property = properties[j2];
        var movedSameProperty = false;
        for (k2 = 0;k2 < movedCount; k2++) {
          var movedProperty = movedProperties[k2];
          if (movedToBeDropped.indexOf(k2) == -1 && (!canReorderSingle(property, movedProperty, specificityCache) && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) || movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)) {
            dropPropertiesAt(i + 1, movedProperty);
            if (movedToBeDropped.indexOf(k2) == -1) {
              movedToBeDropped.push(k2);
              delete movableTokens[movedProperty[4]];
            }
          }
          if (!movedSameProperty) {
            movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];
            if (movedSameProperty) {
              samePropertyAt = k2;
            }
          }
        }
        if (!isRule || unmovableInCurrentToken.indexOf(j2) > -1)
          continue;
        var key = property[4];
        if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {
          dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);
          movedProperties.splice(samePropertyAt, 1);
          movableTokens[key] = [token];
          movedSameProperty = false;
        } else {
          movableTokens[key] = movableTokens[key] || [];
          movableTokens[key].push(token);
        }
        if (movedSameProperty) {
          movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);
        } else {
          movedProperties.push(property);
        }
      }
      movedToBeDropped = movedToBeDropped.sort(naturalSorter);
      for (j2 = 0, m2 = movedToBeDropped.length;j2 < m2; j2++) {
        var dropAt = movedToBeDropped[j2] - j2;
        movedProperties.splice(dropAt, 1);
      }
    }
    var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf("@charset") === 0 ? 1 : 0;
    for (;position < tokens.length - 1; position++) {
      var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf("@import") === 0;
      var isComment = tokens[position][0] === Token.COMMENT;
      if (!(isImportRule || isComment))
        break;
    }
    for (i = 0;i < movedProperties.length; i++) {
      dropPropertiesAt(position, movedProperties[i]);
    }
  };
  var canReorderSingle = require_reorderable().canReorderSingle;
  var extractProperties = require_extract_properties();
  var isMergeable = require_is_mergeable();
  var tidyRuleDuplicates = require_tidy_rule_duplicates();
  var Token = require_token();
  var cloneArray = require_clone_array();
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  module.exports = restructure;
});

// node_modules/clean-css/lib/optimizer/level-2/optimize.js
var require_optimize4 = __commonJS((exports, module) => {
  var removeEmpty = function(tokens) {
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      var token = tokens[i];
      var isEmpty = false;
      switch (token[0]) {
        case Token.RULE:
          isEmpty = token[1].length === 0 || token[2].length === 0;
          break;
        case Token.NESTED_BLOCK:
          removeEmpty(token[2]);
          isEmpty = token[2].length === 0;
          break;
        case Token.AT_RULE:
          isEmpty = token[1].length === 0;
          break;
        case Token.AT_RULE_BLOCK:
          isEmpty = token[2].length === 0;
      }
      if (isEmpty) {
        tokens.splice(i, 1);
        i--;
        l2--;
      }
    }
  };
  var recursivelyOptimizeBlocks = function(tokens, context) {
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      var token = tokens[i];
      if (token[0] == Token.NESTED_BLOCK) {
        var isKeyframes = /@(-moz-|-o-|-webkit-)?keyframes/.test(token[1][0][1]);
        level2Optimize(token[2], context, !isKeyframes);
      }
    }
  };
  var recursivelyOptimizeProperties = function(tokens, context) {
    for (var i = 0, l2 = tokens.length;i < l2; i++) {
      var token = tokens[i];
      switch (token[0]) {
        case Token.RULE:
          optimizeProperties(token[2], true, true, context);
          break;
        case Token.NESTED_BLOCK:
          recursivelyOptimizeProperties(token[2], context);
      }
    }
  };
  var level2Optimize = function(tokens, context, withRestructuring) {
    var levelOptions = context.options.level[OptimizationLevel.Two];
    var level2Plugins = context.options.plugins.level2Block;
    var reduced;
    var i;
    recursivelyOptimizeBlocks(tokens, context);
    recursivelyOptimizeProperties(tokens, context);
    if (levelOptions.removeDuplicateRules) {
      removeDuplicates(tokens, context);
    }
    if (levelOptions.mergeAdjacentRules) {
      mergeAdjacent(tokens, context);
    }
    if (levelOptions.reduceNonAdjacentRules) {
      reduceNonAdjacent(tokens, context);
    }
    if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != "body") {
      mergeNonAdjacentBySelector(tokens, context);
    }
    if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != "selector") {
      mergeNonAdjacentByBody(tokens, context);
    }
    if (levelOptions.restructureRules && levelOptions.mergeAdjacentRules && withRestructuring) {
      restructure(tokens, context);
      mergeAdjacent(tokens, context);
    }
    if (levelOptions.restructureRules && !levelOptions.mergeAdjacentRules && withRestructuring) {
      restructure(tokens, context);
    }
    if (levelOptions.removeDuplicateFontRules) {
      removeDuplicateFontAtRules(tokens, context);
    }
    if (levelOptions.removeDuplicateMediaBlocks) {
      removeDuplicateMediaQueries(tokens, context);
    }
    if (levelOptions.removeUnusedAtRules) {
      removeUnusedAtRules(tokens, context);
    }
    if (levelOptions.mergeMedia) {
      reduced = mergeMediaQueries(tokens, context);
      for (i = reduced.length - 1;i >= 0; i--) {
        level2Optimize(reduced[i][2], context, false);
      }
    }
    for (i = 0;i < level2Plugins.length; i++) {
      level2Plugins[i](tokens);
    }
    if (levelOptions.removeEmpty) {
      removeEmpty(tokens);
    }
    return tokens;
  };
  var mergeAdjacent = require_merge_adjacent();
  var mergeMediaQueries = require_merge_media_queries();
  var mergeNonAdjacentByBody = require_merge_non_adjacent_by_body();
  var mergeNonAdjacentBySelector = require_merge_non_adjacent_by_selector();
  var reduceNonAdjacent = require_reduce_non_adjacent();
  var removeDuplicateFontAtRules = require_remove_duplicate_font_at_rules();
  var removeDuplicateMediaQueries = require_remove_duplicate_media_queries();
  var removeDuplicates = require_remove_duplicates();
  var removeUnusedAtRules = require_remove_unused_at_rules();
  var restructure = require_restructure();
  var optimizeProperties = require_optimize3();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var Token = require_token();
  module.exports = level2Optimize;
});

// node_modules/clean-css/lib/optimizer/validator.js
var require_validator = __commonJS((exports, module) => {
  var isColor = function(value) {
    return value != "auto" && (isKeyword("color")(value) || isHexColor(value) || isColorFunction(value) || isNamedEntity(value));
  };
  var isColorFunction = function(value) {
    return isRgbColor(value) || isHslColor(value);
  };
  var isDynamicUnit = function(value) {
    return calcRegex.test(value);
  };
  var isFunction = function(value) {
    return functionAnyRegex.test(value);
  };
  var isHexColor = function(value) {
    return threeValueColorRegex.test(value) || fourValueColorRegex.test(value) || sixValueColorRegex.test(value) || eightValueColorRegex.test(value);
  };
  var isHslColor = function(value) {
    return hslColorRegex.test(value);
  };
  var isHexAlphaColor = function(value) {
    return hexAlphaColorRegex.test(value);
  };
  var isIdentifier = function(value) {
    return identifierRegex.test(value);
  };
  var isQuotedText = function(value) {
    return quotedTextRegex.test(value);
  };
  var isImage = function(value) {
    return value == "none" || value == "inherit" || isUrl(value);
  };
  var isKeyword = function(propertyName) {
    return function(value) {
      return Keywords[propertyName].indexOf(value) > -1;
    };
  };
  var isNamedEntity = function(value) {
    return namedEntityRegex.test(value);
  };
  var isNumber = function(value) {
    return scanForNumber(value) == value.length;
  };
  var isRgbColor = function(value) {
    return rgbColorRegex.test(value);
  };
  var isPrefixed = function(value) {
    return prefixRegex.test(value);
  };
  var isPositiveNumber = function(value) {
    return isNumber(value) && parseFloat(value) >= 0;
  };
  var isVariable = function(value) {
    return variableRegex.test(value);
  };
  var isTime = function(value) {
    var numberUpTo = scanForNumber(value);
    return numberUpTo == value.length && parseInt(value) === 0 || numberUpTo > -1 && validTimeUnits.indexOf(value.slice(numberUpTo + 1)) > -1 || isCalculatedTime(value);
  };
  var isCalculatedTime = function(value) {
    return isFunction(value) && timeUnitPattern.test(value);
  };
  var isTimingFunction = function() {
    var isTimingFunctionKeyword = isKeyword("*-timing-function");
    return function(value) {
      return isTimingFunctionKeyword(value) || timingFunctionRegex.test(value);
    };
  };
  var isUnit = function(validUnits, value) {
    var numberUpTo = scanForNumber(value);
    return numberUpTo == value.length && parseInt(value) === 0 || numberUpTo > -1 && validUnits.indexOf(value.slice(numberUpTo + 1).toLowerCase()) > -1 || value == "auto" || value == "inherit";
  };
  var isUrl = function(value) {
    return urlRegex.test(value);
  };
  var isZIndex = function(value) {
    return value == "auto" || isNumber(value) || isKeyword("^")(value);
  };
  var scanForNumber = function(value) {
    var hasDot = false;
    var hasSign = false;
    var character;
    var i, l2;
    for (i = 0, l2 = value.length;i < l2; i++) {
      character = value[i];
      if (i === 0 && (character == PLUS_SIGN || character == MINUS_SIGN)) {
        hasSign = true;
      } else if (i > 0 && hasSign && (character == PLUS_SIGN || character == MINUS_SIGN)) {
        return i - 1;
      } else if (character == DECIMAL_DOT && !hasDot) {
        hasDot = true;
      } else if (character == DECIMAL_DOT && hasDot) {
        return i - 1;
      } else if (decimalRegex.test(character)) {
        continue;
      } else {
        return i - 1;
      }
    }
    return i;
  };
  var validator = function(compatibility) {
    var validUnits = Units.slice(0).filter(function(value) {
      return !(value in compatibility.units) || compatibility.units[value] === true;
    });
    if (compatibility.customUnits.rpx) {
      validUnits.push("rpx");
    }
    return {
      colorOpacity: compatibility.colors.opacity,
      colorHexAlpha: compatibility.colors.hexAlpha,
      isAnimationDirectionKeyword: isKeyword("animation-direction"),
      isAnimationFillModeKeyword: isKeyword("animation-fill-mode"),
      isAnimationIterationCountKeyword: isKeyword("animation-iteration-count"),
      isAnimationNameKeyword: isKeyword("animation-name"),
      isAnimationPlayStateKeyword: isKeyword("animation-play-state"),
      isTimingFunction: isTimingFunction(),
      isBackgroundAttachmentKeyword: isKeyword("background-attachment"),
      isBackgroundClipKeyword: isKeyword("background-clip"),
      isBackgroundOriginKeyword: isKeyword("background-origin"),
      isBackgroundPositionKeyword: isKeyword("background-position"),
      isBackgroundRepeatKeyword: isKeyword("background-repeat"),
      isBackgroundSizeKeyword: isKeyword("background-size"),
      isColor,
      isColorFunction,
      isDynamicUnit,
      isFontKeyword: isKeyword("font"),
      isFontSizeKeyword: isKeyword("font-size"),
      isFontStretchKeyword: isKeyword("font-stretch"),
      isFontStyleKeyword: isKeyword("font-style"),
      isFontVariantKeyword: isKeyword("font-variant"),
      isFontWeightKeyword: isKeyword("font-weight"),
      isFunction,
      isGlobal: isKeyword("^"),
      isHexAlphaColor,
      isHslColor,
      isIdentifier,
      isImage,
      isKeyword,
      isLineHeightKeyword: isKeyword("line-height"),
      isListStylePositionKeyword: isKeyword("list-style-position"),
      isListStyleTypeKeyword: isKeyword("list-style-type"),
      isNumber,
      isPrefixed,
      isPositiveNumber,
      isQuotedText,
      isRgbColor,
      isStyleKeyword: isKeyword("*-style"),
      isTime,
      isUnit: isUnit.bind(null, validUnits),
      isUrl,
      isVariable,
      isWidth: isKeyword("width"),
      isZIndex
    };
  };
  var functionNoVendorRegexStr = "[A-Z]+(\\-|[A-Z]|[0-9])+\\(.*?\\)";
  var functionVendorRegexStr = "\\-(\\-|[A-Z]|[0-9])+\\(.*?\\)";
  var variableRegexStr = "var\\(\\-\\-[^\\)]+\\)";
  var functionAnyRegexStr = "(" + variableRegexStr + "|" + functionNoVendorRegexStr + "|" + functionVendorRegexStr + ")";
  var calcRegex = new RegExp("^(\\-moz\\-|\\-webkit\\-)?calc\\([^\\)]+\\)$", "i");
  var decimalRegex = /[0-9]/;
  var functionAnyRegex = new RegExp("^" + functionAnyRegexStr + "$", "i");
  var hexAlphaColorRegex = /^#(?:[0-9a-f]{4}|[0-9a-f]{8})$/i;
  var hslColorRegex = /^hsl\(\s{0,31}[\-\.]?\d+\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31}\)|hsla\(\s{0,31}[\-\.]?\d+\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\.?\d+\s{0,31}\)$/;
  var identifierRegex = /^(\-[a-z0-9_][a-z0-9\-_]*|[a-z_][a-z0-9\-_]*)$/i;
  var namedEntityRegex = /^[a-z]+$/i;
  var prefixRegex = /^-([a-z0-9]|-)*$/i;
  var quotedTextRegex = /^("[^"]*"|'[^']*')$/i;
  var rgbColorRegex = /^rgb\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31}\)|rgba\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\.\d]+\s{0,31}\)$/i;
  var timeUnitPattern = /\d+(s|ms)/;
  var timingFunctionRegex = /^(cubic\-bezier|steps)\([^\)]+\)$/;
  var validTimeUnits = ["ms", "s"];
  var urlRegex = /^url\([\s\S]+\)$/i;
  var variableRegex = new RegExp("^" + variableRegexStr + "$", "i");
  var eightValueColorRegex = /^#[0-9a-f]{8}$/i;
  var fourValueColorRegex = /^#[0-9a-f]{4}$/i;
  var sixValueColorRegex = /^#[0-9a-f]{6}$/i;
  var threeValueColorRegex = /^#[0-9a-f]{3}$/i;
  var DECIMAL_DOT = ".";
  var MINUS_SIGN = "-";
  var PLUS_SIGN = "+";
  var Keywords = {
    "^": [
      "inherit",
      "initial",
      "unset"
    ],
    "*-style": [
      "auto",
      "dashed",
      "dotted",
      "double",
      "groove",
      "hidden",
      "inset",
      "none",
      "outset",
      "ridge",
      "solid"
    ],
    "*-timing-function": [
      "ease",
      "ease-in",
      "ease-in-out",
      "ease-out",
      "linear",
      "step-end",
      "step-start"
    ],
    "animation-direction": [
      "alternate",
      "alternate-reverse",
      "normal",
      "reverse"
    ],
    "animation-fill-mode": [
      "backwards",
      "both",
      "forwards",
      "none"
    ],
    "animation-iteration-count": [
      "infinite"
    ],
    "animation-name": [
      "none"
    ],
    "animation-play-state": [
      "paused",
      "running"
    ],
    "background-attachment": [
      "fixed",
      "inherit",
      "local",
      "scroll"
    ],
    "background-clip": [
      "border-box",
      "content-box",
      "inherit",
      "padding-box",
      "text"
    ],
    "background-origin": [
      "border-box",
      "content-box",
      "inherit",
      "padding-box"
    ],
    "background-position": [
      "bottom",
      "center",
      "left",
      "right",
      "top"
    ],
    "background-repeat": [
      "no-repeat",
      "inherit",
      "repeat",
      "repeat-x",
      "repeat-y",
      "round",
      "space"
    ],
    "background-size": [
      "auto",
      "cover",
      "contain"
    ],
    "border-collapse": [
      "collapse",
      "inherit",
      "separate"
    ],
    bottom: [
      "auto"
    ],
    clear: [
      "both",
      "left",
      "none",
      "right"
    ],
    color: [
      "transparent"
    ],
    cursor: [
      "all-scroll",
      "auto",
      "col-resize",
      "crosshair",
      "default",
      "e-resize",
      "help",
      "move",
      "n-resize",
      "ne-resize",
      "no-drop",
      "not-allowed",
      "nw-resize",
      "pointer",
      "progress",
      "row-resize",
      "s-resize",
      "se-resize",
      "sw-resize",
      "text",
      "vertical-text",
      "w-resize",
      "wait"
    ],
    display: [
      "block",
      "inline",
      "inline-block",
      "inline-table",
      "list-item",
      "none",
      "table",
      "table-caption",
      "table-cell",
      "table-column",
      "table-column-group",
      "table-footer-group",
      "table-header-group",
      "table-row",
      "table-row-group"
    ],
    float: [
      "left",
      "none",
      "right"
    ],
    left: [
      "auto"
    ],
    font: [
      "caption",
      "icon",
      "menu",
      "message-box",
      "small-caption",
      "status-bar",
      "unset"
    ],
    "font-size": [
      "large",
      "larger",
      "medium",
      "small",
      "smaller",
      "x-large",
      "x-small",
      "xx-large",
      "xx-small"
    ],
    "font-stretch": [
      "condensed",
      "expanded",
      "extra-condensed",
      "extra-expanded",
      "normal",
      "semi-condensed",
      "semi-expanded",
      "ultra-condensed",
      "ultra-expanded"
    ],
    "font-style": [
      "italic",
      "normal",
      "oblique"
    ],
    "font-variant": [
      "normal",
      "small-caps"
    ],
    "font-weight": [
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900",
      "bold",
      "bolder",
      "lighter",
      "normal"
    ],
    "line-height": [
      "normal"
    ],
    "list-style-position": [
      "inside",
      "outside"
    ],
    "list-style-type": [
      "armenian",
      "circle",
      "decimal",
      "decimal-leading-zero",
      "disc",
      "decimal|disc",
      "georgian",
      "lower-alpha",
      "lower-greek",
      "lower-latin",
      "lower-roman",
      "none",
      "square",
      "upper-alpha",
      "upper-latin",
      "upper-roman"
    ],
    overflow: [
      "auto",
      "hidden",
      "scroll",
      "visible"
    ],
    position: [
      "absolute",
      "fixed",
      "relative",
      "static"
    ],
    right: [
      "auto"
    ],
    "text-align": [
      "center",
      "justify",
      "left",
      "left|right",
      "right"
    ],
    "text-decoration": [
      "line-through",
      "none",
      "overline",
      "underline"
    ],
    "text-overflow": [
      "clip",
      "ellipsis"
    ],
    top: [
      "auto"
    ],
    "vertical-align": [
      "baseline",
      "bottom",
      "middle",
      "sub",
      "super",
      "text-bottom",
      "text-top",
      "top"
    ],
    visibility: [
      "collapse",
      "hidden",
      "visible"
    ],
    "white-space": [
      "normal",
      "nowrap",
      "pre"
    ],
    width: [
      "inherit",
      "initial",
      "medium",
      "thick",
      "thin"
    ]
  };
  var Units = [
    "%",
    "ch",
    "cm",
    "em",
    "ex",
    "in",
    "mm",
    "pc",
    "pt",
    "px",
    "rem",
    "vh",
    "vm",
    "vmax",
    "vmin",
    "vw"
  ];
  module.exports = validator;
});

// node_modules/clean-css/lib/options/compatibility.js
var require_compatibility = __commonJS((exports, module) => {
  var compatibilityFrom = function(source) {
    return merge2(DEFAULTS["*"], calculateSource(source));
  };
  var merge2 = function(source, target) {
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        var value = source[key];
        if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === "object" && !Array.isArray(value)) {
          target[key] = merge2(value, target[key] || {});
        } else {
          target[key] = key in target ? target[key] : value;
        }
      }
    }
    return target;
  };
  var calculateSource = function(source) {
    if (typeof source == "object")
      return source;
    if (!/[,\+\-]/.test(source))
      return DEFAULTS[source] || DEFAULTS["*"];
    var parts = source.split(",");
    var template = parts[0] in DEFAULTS ? DEFAULTS[parts.shift()] : DEFAULTS["*"];
    source = {};
    parts.forEach(function(part) {
      var isAdd = part[0] == "+";
      var key = part.substring(1).split(".");
      var group = key[0];
      var option = key[1];
      source[group] = source[group] || {};
      source[group][option] = isAdd;
    });
    return merge2(template, source);
  };
  var DEFAULTS = {
    "*": {
      colors: {
        hexAlpha: false,
        opacity: true
      },
      customUnits: {
        rpx: false
      },
      properties: {
        backgroundClipMerging: true,
        backgroundOriginMerging: true,
        backgroundSizeMerging: true,
        colors: true,
        ieBangHack: false,
        ieFilters: false,
        iePrefixHack: false,
        ieSuffixHack: false,
        merging: true,
        shorterLengthUnits: false,
        spaceAfterClosingBrace: true,
        urlQuotes: true,
        zeroUnits: true
      },
      selectors: {
        adjacentSpace: false,
        ie7Hack: false,
        mergeablePseudoClasses: [
          ":active",
          ":after",
          ":before",
          ":empty",
          ":checked",
          ":disabled",
          ":empty",
          ":enabled",
          ":first-child",
          ":first-letter",
          ":first-line",
          ":first-of-type",
          ":focus",
          ":hover",
          ":lang",
          ":last-child",
          ":last-of-type",
          ":link",
          ":not",
          ":nth-child",
          ":nth-last-child",
          ":nth-last-of-type",
          ":nth-of-type",
          ":only-child",
          ":only-of-type",
          ":root",
          ":target",
          ":visited"
        ],
        mergeablePseudoElements: [
          "::after",
          "::before",
          "::first-letter",
          "::first-line"
        ],
        mergeLimit: 8191,
        multiplePseudoMerging: true
      },
      units: {
        ch: true,
        in: true,
        pc: true,
        pt: true,
        rem: true,
        vh: true,
        vm: true,
        vmax: true,
        vmin: true,
        vw: true
      }
    }
  };
  DEFAULTS.ie11 = merge2(DEFAULTS["*"], {
    properties: {
      ieSuffixHack: true
    }
  });
  DEFAULTS.ie10 = merge2(DEFAULTS["*"], {
    properties: {
      ieSuffixHack: true
    }
  });
  DEFAULTS.ie9 = merge2(DEFAULTS["*"], {
    properties: {
      ieFilters: true,
      ieSuffixHack: true
    }
  });
  DEFAULTS.ie8 = merge2(DEFAULTS.ie9, {
    colors: {
      opacity: false
    },
    properties: {
      backgroundClipMerging: false,
      backgroundOriginMerging: false,
      backgroundSizeMerging: false,
      iePrefixHack: true,
      merging: false
    },
    selectors: {
      mergeablePseudoClasses: [
        ":after",
        ":before",
        ":first-child",
        ":first-letter",
        ":focus",
        ":hover",
        ":visited"
      ],
      mergeablePseudoElements: []
    },
    units: {
      ch: false,
      rem: false,
      vh: false,
      vm: false,
      vmax: false,
      vmin: false,
      vw: false
    }
  });
  DEFAULTS.ie7 = merge2(DEFAULTS.ie8, {
    properties: {
      ieBangHack: true
    },
    selectors: {
      ie7Hack: true,
      mergeablePseudoClasses: [
        ":first-child",
        ":first-letter",
        ":hover",
        ":visited"
      ]
    }
  });
  module.exports = compatibilityFrom;
});

// node:http
var exports_http = {};
__export(exports_http, {
  request: () => {
    {
      return ou;
    }
  },
  globalAgent: () => {
    {
      return lu;
    }
  },
  get: () => {
    {
      return au;
    }
  },
  default: () => {
    {
      return iu;
    }
  },
  STATUS_CODES: () => {
    {
      return hu;
    }
  },
  METHODS: () => {
    {
      return cu;
    }
  },
  IncomingMessage: () => {
    {
      return fu;
    }
  },
  ClientRequest: () => {
    {
      return su;
    }
  },
  Agent: () => {
    {
      return uu;
    }
  }
});
var oe, Gs, yi, dr, Gi, ke, Ki, Vi, Yi, Xi, vr, b2, Er, xr, Rr, dt, gt, Q, bt, _t, qr, Dr, _e, Lt, an, Ft, fe, Nt, pn, Dt, ue, Sn, Bn, Kt, Qe, Vt, et, On, Nn, Ht, ir, zn, ti, ar, ur, fi, li, ci, _i, pi, js, Hs, Ws, $s, hr, K, cr, gi, Ks, di, wi, pr, yr, mi, bi, Vs, Ys, vi, xi, Si, Ni, Di, Hi, _r, iu, ou, au, su, fu, uu, lu, hu, cu;
var init_http = __esm(() => {
  oe = function(e) {
    throw new RangeError($s[e]);
  };
  Gs = function(e, t) {
    let r = [], n = e.length;
    for (;n--; )
      r[n] = t(e[n]);
    return r;
  };
  yi = function(e, t) {
    let r = e.split("@"), n = "";
    r.length > 1 && (n = r[0] + "@", e = r[1]), e = e.replace(Ws, ".");
    let i = e.split("."), o = Gs(i, t).join(".");
    return n + o;
  };
  dr = function(e) {
    let t = [], r = 0, n = e.length;
    for (;r < n; ) {
      let i = e.charCodeAt(r++);
      if (i >= 55296 && i <= 56319 && r < n) {
        let o = e.charCodeAt(r++);
        (o & 64512) == 56320 ? t.push(((i & 1023) << 10) + (o & 1023) + 65536) : (t.push(i), r--);
      } else
        t.push(i);
    }
    return t;
  };
  Gi = Object.create;
  ke = Object.defineProperty;
  Ki = Object.getOwnPropertyDescriptor;
  Vi = Object.getOwnPropertyNames;
  Yi = Object.getPrototypeOf;
  Xi = Object.prototype.hasOwnProperty;
  vr = (e, t) => () => (e && (t = e(e = 0)), t);
  b2 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
  Er = (e, t) => {
    for (var r in t)
      ke(e, r, { get: t[r], enumerable: true });
  };
  xr = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let i of Vi(t))
        !Xi.call(e, i) && i !== r && ke(e, i, { get: () => t[i], enumerable: !(n = Ki(t, i)) || n.enumerable });
    return e;
  };
  Rr = (e, t, r) => (r = e != null ? Gi(Yi(e)) : {}, xr(t || !e || !e.__esModule ? ke(r, "default", { value: e, enumerable: true }) : r, e));
  dt = (e) => xr(ke({}, "__esModule", { value: true }), e);
  gt = b2((N2) => {
    N2.fetch = Ce(global.fetch) && Ce(global.ReadableStream);
    N2.writableStream = Ce(global.WritableStream);
    N2.abortController = Ce(global.AbortController);
    var J;
    function pt() {
      if (J !== undefined)
        return J;
      if (global.XMLHttpRequest) {
        J = new global.XMLHttpRequest;
        try {
          J.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch {
          J = null;
        }
      } else
        J = null;
      return J;
    }
    function yt(e) {
      var t = pt();
      if (!t)
        return false;
      try {
        return t.responseType = e, t.responseType === e;
      } catch {
      }
      return false;
    }
    N2.arraybuffer = N2.fetch || yt("arraybuffer");
    N2.msstream = !N2.fetch && yt("ms-stream");
    N2.mozchunkedarraybuffer = !N2.fetch && yt("moz-chunked-arraybuffer");
    N2.overrideMimeType = N2.fetch || (pt() ? Ce(pt().overrideMimeType) : false);
    function Ce(e) {
      return typeof e == "function";
    }
    J = null;
  });
  Q = b2((Rf, wt) => {
    typeof Object.create == "function" ? wt.exports = function(t, r) {
      r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
    } : wt.exports = function(t, r) {
      if (r) {
        t.super_ = r;
        var n = function() {
        };
        n.prototype = r.prototype, t.prototype = new n, t.prototype.constructor = t;
      }
    };
  });
  bt = b2((Sf, mt) => {
    var ye = typeof Reflect == "object" ? Reflect : null, Sr = ye && typeof ye.apply == "function" ? ye.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, je;
    ye && typeof ye.ownKeys == "function" ? je = ye.ownKeys : Object.getOwnPropertySymbols ? je = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : je = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function zi(e) {
      console && console.warn && console.warn(e);
    }
    var Ar = Number.isNaN || function(t) {
      return t !== t;
    };
    function x2() {
      x2.init.call(this);
    }
    mt.exports = x2;
    mt.exports.once = eo;
    x2.EventEmitter = x2;
    x2.prototype._events = undefined;
    x2.prototype._eventsCount = 0;
    x2.prototype._maxListeners = undefined;
    var Tr = 10;
    function He(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(x2, "defaultMaxListeners", { enumerable: true, get: function() {
      return Tr;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || Ar(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      Tr = e;
    } });
    x2.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    x2.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || Ar(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Br(e) {
      return e._maxListeners === undefined ? x2.defaultMaxListeners : e._maxListeners;
    }
    x2.prototype.getMaxListeners = function() {
      return Br(this);
    };
    x2.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o = this._events;
      if (o !== undefined)
        i = i && o.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var a2;
        if (r.length > 0 && (a2 = r[0]), a2 instanceof Error)
          throw a2;
        var s2 = new Error("Unhandled error." + (a2 ? " (" + a2.message + ")" : ""));
        throw s2.context = a2, s2;
      }
      var u2 = o[t];
      if (u2 === undefined)
        return false;
      if (typeof u2 == "function")
        Sr(u2, this, r);
      else
        for (var l2 = u2.length, h2 = Or(u2, l2), n = 0;n < l2; ++n)
          Sr(h2[n], this, r);
      return true;
    };
    function Cr(e, t, r, n) {
      var i, o, a2;
      if (He(r), o = e._events, o === undefined ? (o = e._events = Object.create(null), e._eventsCount = 0) : (o.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o = e._events), a2 = o[t]), a2 === undefined)
        a2 = o[t] = r, ++e._eventsCount;
      else if (typeof a2 == "function" ? a2 = o[t] = n ? [r, a2] : [a2, r] : n ? a2.unshift(r) : a2.push(r), i = Br(e), i > 0 && a2.length > i && !a2.warned) {
        a2.warned = true;
        var s2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        s2.name = "MaxListenersExceededWarning", s2.emitter = e, s2.type = t, s2.count = a2.length, zi(s2);
      }
      return e;
    }
    x2.prototype.addListener = function(t, r) {
      return Cr(this, t, r, false);
    };
    x2.prototype.on = x2.prototype.addListener;
    x2.prototype.prependListener = function(t, r) {
      return Cr(this, t, r, true);
    };
    function Zi() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ir(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = Zi.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    x2.prototype.once = function(t, r) {
      return He(r), this.on(t, Ir(this, t, r)), this;
    };
    x2.prototype.prependOnceListener = function(t, r) {
      return He(r), this.prependListener(t, Ir(this, t, r)), this;
    };
    x2.prototype.removeListener = function(t, r) {
      var n, i, o, a2, s2;
      if (He(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o = -1, a2 = n.length - 1;a2 >= 0; a2--)
          if (n[a2] === r || n[a2].listener === r) {
            s2 = n[a2].listener, o = a2;
            break;
          }
        if (o < 0)
          return this;
        o === 0 ? n.shift() : Ji(n, o), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, s2 || r);
      }
      return this;
    };
    x2.prototype.off = x2.prototype.removeListener;
    x2.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o = Object.keys(n), a2;
        for (i = 0;i < o.length; ++i)
          a2 = o[i], a2 !== "removeListener" && this.removeAllListeners(a2);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Lr(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? Qi(i) : Or(i, i.length);
    }
    x2.prototype.listeners = function(t) {
      return Lr(this, t, true);
    };
    x2.prototype.rawListeners = function(t) {
      return Lr(this, t, false);
    };
    x2.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : Mr.call(e, t);
    };
    x2.prototype.listenerCount = Mr;
    function Mr(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    x2.prototype.eventNames = function() {
      return this._eventsCount > 0 ? je(this._events) : [];
    };
    function Or(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function Ji(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function Qi(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function eo(e, t) {
      return new Promise(function(r, n) {
        function i(a2) {
          e.removeListener(t, o), n(a2);
        }
        function o() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        Fr(e, t, o, { once: true }), t !== "error" && to(e, i, { once: true });
      });
    }
    function to(e, t, r) {
      typeof e.on == "function" && Fr(e, "error", t, r);
    }
    function Fr(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o) {
          n.once && e.removeEventListener(t, i), r(o);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  _t = b2((Tf, Nr) => {
    Nr.exports = bt().EventEmitter;
  });
  qr = b2((We) => {
    We.byteLength = no;
    We.toByteArray = oo;
    We.fromByteArray = fo;
    var H = [], U2 = [], ro = typeof Uint8Array < "u" ? Uint8Array : Array, vt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ae = 0, Ur = vt.length;ae < Ur; ++ae)
      H[ae] = vt[ae], U2[vt.charCodeAt(ae)] = ae;
    var ae, Ur;
    U2["-".charCodeAt(0)] = 62;
    U2["_".charCodeAt(0)] = 63;
    function Pr(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function no(e) {
      var t = Pr(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function io(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function oo(e) {
      var t, r = Pr(e), n = r[0], i = r[1], o = new ro(io(e, n, i)), a2 = 0, s2 = i > 0 ? n - 4 : n, u2;
      for (u2 = 0;u2 < s2; u2 += 4)
        t = U2[e.charCodeAt(u2)] << 18 | U2[e.charCodeAt(u2 + 1)] << 12 | U2[e.charCodeAt(u2 + 2)] << 6 | U2[e.charCodeAt(u2 + 3)], o[a2++] = t >> 16 & 255, o[a2++] = t >> 8 & 255, o[a2++] = t & 255;
      return i === 2 && (t = U2[e.charCodeAt(u2)] << 2 | U2[e.charCodeAt(u2 + 1)] >> 4, o[a2++] = t & 255), i === 1 && (t = U2[e.charCodeAt(u2)] << 10 | U2[e.charCodeAt(u2 + 1)] << 4 | U2[e.charCodeAt(u2 + 2)] >> 2, o[a2++] = t >> 8 & 255, o[a2++] = t & 255), o;
    }
    function ao(e) {
      return H[e >> 18 & 63] + H[e >> 12 & 63] + H[e >> 6 & 63] + H[e & 63];
    }
    function so(e, t, r) {
      for (var n, i = [], o = t;o < r; o += 3)
        n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(ao(n));
      return i.join("");
    }
    function fo(e) {
      for (var t, r = e.length, n = r % 3, i = [], o = 16383, a2 = 0, s2 = r - n;a2 < s2; a2 += o)
        i.push(so(e, a2, a2 + o > s2 ? s2 : a2 + o));
      return n === 1 ? (t = e[r - 1], i.push(H[t >> 2] + H[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(H[t >> 10] + H[t >> 4 & 63] + H[t << 2 & 63] + "=")), i.join("");
    }
  });
  Dr = b2((Et) => {
    Et.read = function(e, t, r, n, i) {
      var o, a2, s2 = i * 8 - n - 1, u2 = (1 << s2) - 1, l2 = u2 >> 1, h2 = -7, c2 = r ? i - 1 : 0, d2 = r ? -1 : 1, p2 = e[t + c2];
      for (c2 += d2, o = p2 & (1 << -h2) - 1, p2 >>= -h2, h2 += s2;h2 > 0; o = o * 256 + e[t + c2], c2 += d2, h2 -= 8)
        ;
      for (a2 = o & (1 << -h2) - 1, o >>= -h2, h2 += n;h2 > 0; a2 = a2 * 256 + e[t + c2], c2 += d2, h2 -= 8)
        ;
      if (o === 0)
        o = 1 - l2;
      else {
        if (o === u2)
          return a2 ? NaN : (p2 ? -1 : 1) * (1 / 0);
        a2 = a2 + Math.pow(2, n), o = o - l2;
      }
      return (p2 ? -1 : 1) * a2 * Math.pow(2, o - n);
    };
    Et.write = function(e, t, r, n, i, o) {
      var a2, s2, u2, l2 = o * 8 - i - 1, h2 = (1 << l2) - 1, c2 = h2 >> 1, d2 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p2 = n ? 0 : o - 1, g2 = n ? 1 : -1, E2 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s2 = isNaN(t) ? 1 : 0, a2 = h2) : (a2 = Math.floor(Math.log(t) / Math.LN2), t * (u2 = Math.pow(2, -a2)) < 1 && (a2--, u2 *= 2), a2 + c2 >= 1 ? t += d2 / u2 : t += d2 * Math.pow(2, 1 - c2), t * u2 >= 2 && (a2++, u2 /= 2), a2 + c2 >= h2 ? (s2 = 0, a2 = h2) : a2 + c2 >= 1 ? (s2 = (t * u2 - 1) * Math.pow(2, i), a2 = a2 + c2) : (s2 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), a2 = 0));i >= 8; e[r + p2] = s2 & 255, p2 += g2, s2 /= 256, i -= 8)
        ;
      for (a2 = a2 << i | s2, l2 += i;l2 > 0; e[r + p2] = a2 & 255, p2 += g2, a2 /= 256, l2 -= 8)
        ;
      e[r + p2 - g2] |= E2 * 128;
    };
  });
  _e = b2((be) => {
    var xt = qr(), we = Dr(), kr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    be.Buffer = f2;
    be.SlowBuffer = yo;
    be.INSPECT_MAX_BYTES = 50;
    var $e = 2147483647;
    be.kMaxLength = $e;
    f2.TYPED_ARRAY_SUPPORT = uo();
    !f2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function uo() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(f2.prototype, "parent", { enumerable: true, get: function() {
      if (!!f2.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(f2.prototype, "offset", { enumerable: true, get: function() {
      if (!!f2.isBuffer(this))
        return this.byteOffset;
    } });
    function X2(e) {
      if (e > $e)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, f2.prototype), t;
    }
    function f2(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return At(e);
      }
      return $r(e, t, r);
    }
    f2.poolSize = 8192;
    function $r(e, t, r) {
      if (typeof e == "string")
        return ho(e, t);
      if (ArrayBuffer.isView(e))
        return co(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (W(e, ArrayBuffer) || e && W(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (W(e, SharedArrayBuffer) || e && W(e.buffer, SharedArrayBuffer)))
        return St(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return f2.from(n, t, r);
      let i = po(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return f2.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    f2.from = function(e, t, r) {
      return $r(e, t, r);
    };
    Object.setPrototypeOf(f2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(f2, Uint8Array);
    function Gr(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function lo(e, t, r) {
      return Gr(e), e <= 0 ? X2(e) : t !== undefined ? typeof r == "string" ? X2(e).fill(t, r) : X2(e).fill(t) : X2(e);
    }
    f2.alloc = function(e, t, r) {
      return lo(e, t, r);
    };
    function At(e) {
      return Gr(e), X2(e < 0 ? 0 : Bt(e) | 0);
    }
    f2.allocUnsafe = function(e) {
      return At(e);
    };
    f2.allocUnsafeSlow = function(e) {
      return At(e);
    };
    function ho(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !f2.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = Kr(e, t) | 0, n = X2(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Rt(e) {
      let t = e.length < 0 ? 0 : Bt(e.length) | 0, r = X2(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function co(e) {
      if (W(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return St(t.buffer, t.byteOffset, t.byteLength);
      }
      return Rt(e);
    }
    function St(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, f2.prototype), n;
    }
    function po(e) {
      if (f2.isBuffer(e)) {
        let t = Bt(e.length) | 0, r = X2(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || It(e.length) ? X2(0) : Rt(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Rt(e.data);
    }
    function Bt(e) {
      if (e >= $e)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + $e.toString(16) + " bytes");
      return e | 0;
    }
    function yo(e) {
      return +e != e && (e = 0), f2.alloc(+e);
    }
    f2.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== f2.prototype;
    };
    f2.compare = function(t, r) {
      if (W(t, Uint8Array) && (t = f2.from(t, t.offset, t.byteLength)), W(r, Uint8Array) && (r = f2.from(r, r.offset, r.byteLength)), !f2.isBuffer(t) || !f2.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o = 0, a2 = Math.min(n, i);o < a2; ++o)
        if (t[o] !== r[o]) {
          n = t[o], i = r[o];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    f2.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    f2.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return f2.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = f2.allocUnsafe(r), o = 0;
      for (n = 0;n < t.length; ++n) {
        let a2 = t[n];
        if (W(a2, Uint8Array))
          o + a2.length > i.length ? (f2.isBuffer(a2) || (a2 = f2.from(a2)), a2.copy(i, o)) : Uint8Array.prototype.set.call(i, a2, o);
        else if (f2.isBuffer(a2))
          a2.copy(i, o);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o += a2.length;
      }
      return i;
    };
    function Kr(e, t) {
      if (f2.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || W(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Tt(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return tn(e).length;
          default:
            if (i)
              return n ? -1 : Tt(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    f2.byteLength = Kr;
    function go(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return To(this, t, r);
          case "utf8":
          case "utf-8":
            return Yr(this, t, r);
          case "ascii":
            return Ro(this, t, r);
          case "latin1":
          case "binary":
            return So(this, t, r);
          case "base64":
            return Eo(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ao(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    f2.prototype._isBuffer = true;
    function se(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    f2.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        se(this, r, r + 1);
      return this;
    };
    f2.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        se(this, r, r + 3), se(this, r + 1, r + 2);
      return this;
    };
    f2.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        se(this, r, r + 7), se(this, r + 1, r + 6), se(this, r + 2, r + 5), se(this, r + 3, r + 4);
      return this;
    };
    f2.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? Yr(this, 0, t) : go.apply(this, arguments);
    };
    f2.prototype.toLocaleString = f2.prototype.toString;
    f2.prototype.equals = function(t) {
      if (!f2.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : f2.compare(this, t) === 0;
    };
    f2.prototype.inspect = function() {
      let t = "", r = be.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    kr && (f2.prototype[kr] = f2.prototype.inspect);
    f2.prototype.compare = function(t, r, n, i, o) {
      if (W(t, Uint8Array) && (t = f2.from(t, t.offset, t.byteLength)), !f2.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o === undefined && (o = this.length), r < 0 || n > t.length || i < 0 || o > this.length)
        throw new RangeError("out of range index");
      if (i >= o && r >= n)
        return 0;
      if (i >= o)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === t)
        return 0;
      let a2 = o - i, s2 = n - r, u2 = Math.min(a2, s2), l2 = this.slice(i, o), h2 = t.slice(r, n);
      for (let c2 = 0;c2 < u2; ++c2)
        if (l2[c2] !== h2[c2]) {
          a2 = l2[c2], s2 = h2[c2];
          break;
        }
      return a2 < s2 ? -1 : s2 < a2 ? 1 : 0;
    };
    function Vr(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, It(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = f2.from(t, n)), f2.isBuffer(t))
        return t.length === 0 ? -1 : jr(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : jr(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function jr(e, t, r, n, i) {
      let o = 1, a2 = e.length, s2 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o = 2, a2 /= 2, s2 /= 2, r /= 2;
      }
      function u2(h2, c2) {
        return o === 1 ? h2[c2] : h2.readUInt16BE(c2 * o);
      }
      let l2;
      if (i) {
        let h2 = -1;
        for (l2 = r;l2 < a2; l2++)
          if (u2(e, l2) === u2(t, h2 === -1 ? 0 : l2 - h2)) {
            if (h2 === -1 && (h2 = l2), l2 - h2 + 1 === s2)
              return h2 * o;
          } else
            h2 !== -1 && (l2 -= l2 - h2), h2 = -1;
      } else
        for (r + s2 > a2 && (r = a2 - s2), l2 = r;l2 >= 0; l2--) {
          let h2 = true;
          for (let c2 = 0;c2 < s2; c2++)
            if (u2(e, l2 + c2) !== u2(t, c2)) {
              h2 = false;
              break;
            }
          if (h2)
            return l2;
        }
      return -1;
    }
    f2.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    f2.prototype.indexOf = function(t, r, n) {
      return Vr(this, t, r, n, true);
    };
    f2.prototype.lastIndexOf = function(t, r, n) {
      return Vr(this, t, r, n, false);
    };
    function wo(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o = t.length;
      n > o / 2 && (n = o / 2);
      let a2;
      for (a2 = 0;a2 < n; ++a2) {
        let s2 = parseInt(t.substr(a2 * 2, 2), 16);
        if (It(s2))
          return a2;
        e[r + a2] = s2;
      }
      return a2;
    }
    function mo(e, t, r, n) {
      return Ge(Tt(t, e.length - r), e, r, n);
    }
    function bo(e, t, r, n) {
      return Ge(Lo(t), e, r, n);
    }
    function _o(e, t, r, n) {
      return Ge(tn(t), e, r, n);
    }
    function vo(e, t, r, n) {
      return Ge(Mo(t, e.length - r), e, r, n);
    }
    f2.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o = this.length - r;
      if ((n === undefined || n > o) && (n = o), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let a2 = false;
      for (;; )
        switch (i) {
          case "hex":
            return wo(this, t, r, n);
          case "utf8":
          case "utf-8":
            return mo(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return bo(this, t, r, n);
          case "base64":
            return _o(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return vo(this, t, r, n);
          default:
            if (a2)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), a2 = true;
        }
    };
    f2.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Eo(e, t, r) {
      return t === 0 && r === e.length ? xt.fromByteArray(e) : xt.fromByteArray(e.slice(t, r));
    }
    function Yr(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o = e[i], a2 = null, s2 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
        if (i + s2 <= r) {
          let u2, l2, h2, c2;
          switch (s2) {
            case 1:
              o < 128 && (a2 = o);
              break;
            case 2:
              u2 = e[i + 1], (u2 & 192) === 128 && (c2 = (o & 31) << 6 | u2 & 63, c2 > 127 && (a2 = c2));
              break;
            case 3:
              u2 = e[i + 1], l2 = e[i + 2], (u2 & 192) === 128 && (l2 & 192) === 128 && (c2 = (o & 15) << 12 | (u2 & 63) << 6 | l2 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (a2 = c2));
              break;
            case 4:
              u2 = e[i + 1], l2 = e[i + 2], h2 = e[i + 3], (u2 & 192) === 128 && (l2 & 192) === 128 && (h2 & 192) === 128 && (c2 = (o & 15) << 18 | (u2 & 63) << 12 | (l2 & 63) << 6 | h2 & 63, c2 > 65535 && c2 < 1114112 && (a2 = c2));
          }
        }
        a2 === null ? (a2 = 65533, s2 = 1) : a2 > 65535 && (a2 -= 65536, n.push(a2 >>> 10 & 1023 | 55296), a2 = 56320 | a2 & 1023), n.push(a2), i += s2;
      }
      return xo(n);
    }
    var Hr = 4096;
    function xo(e) {
      let t = e.length;
      if (t <= Hr)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += Hr));
      return r;
    }
    function Ro(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function So(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function To(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o = t;o < r; ++o)
        i += Oo[e[o]];
      return i;
    }
    function Ao(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o = 0;o < n.length - 1; o += 2)
        i += String.fromCharCode(n[o] + n[o + 1] * 256);
      return i;
    }
    f2.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, f2.prototype), i;
    };
    function C(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    f2.prototype.readUintLE = f2.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C(t, r, this.length);
      let i = this[t], o = 1, a2 = 0;
      for (;++a2 < r && (o *= 256); )
        i += this[t + a2] * o;
      return i;
    };
    f2.prototype.readUintBE = f2.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C(t, r, this.length);
      let i = this[t + --r], o = 1;
      for (;r > 0 && (o *= 256); )
        i += this[t + --r] * o;
      return i;
    };
    f2.prototype.readUint8 = f2.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || C(t, 1, this.length), this[t];
    };
    f2.prototype.readUint16LE = f2.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || C(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    f2.prototype.readUint16BE = f2.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || C(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    f2.prototype.readUint32LE = f2.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || C(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    f2.prototype.readUint32BE = f2.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || C(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    f2.prototype.readBigUInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o) << BigInt(32));
    });
    f2.prototype.readBigUInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o);
    });
    f2.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C(t, r, this.length);
      let i = this[t], o = 1, a2 = 0;
      for (;++a2 < r && (o *= 256); )
        i += this[t + a2] * o;
      return o *= 128, i >= o && (i -= Math.pow(2, 8 * r)), i;
    };
    f2.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C(t, r, this.length);
      let i = r, o = 1, a2 = this[t + --i];
      for (;i > 0 && (o *= 256); )
        a2 += this[t + --i] * o;
      return o *= 128, a2 >= o && (a2 -= Math.pow(2, 8 * r)), a2;
    };
    f2.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || C(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    f2.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || C(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f2.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || C(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f2.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || C(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    f2.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || C(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    f2.prototype.readBigInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    f2.prototype.readBigInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    f2.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || C(t, 4, this.length), we.read(this, t, true, 23, 4);
    };
    f2.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || C(t, 4, this.length), we.read(this, t, false, 23, 4);
    };
    f2.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || C(t, 8, this.length), we.read(this, t, true, 52, 8);
    };
    f2.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || C(t, 8, this.length), we.read(this, t, false, 52, 8);
    };
    function O2(e, t, r, n, i, o) {
      if (!f2.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    f2.prototype.writeUintLE = f2.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s2 = Math.pow(2, 8 * n) - 1;
        O2(this, t, r, n, s2, 0);
      }
      let o = 1, a2 = 0;
      for (this[r] = t & 255;++a2 < n && (o *= 256); )
        this[r + a2] = t / o & 255;
      return r + n;
    };
    f2.prototype.writeUintBE = f2.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s2 = Math.pow(2, 8 * n) - 1;
        O2(this, t, r, n, s2, 0);
      }
      let o = n - 1, a2 = 1;
      for (this[r + o] = t & 255;--o >= 0 && (a2 *= 256); )
        this[r + o] = t / a2 & 255;
      return r + n;
    };
    f2.prototype.writeUint8 = f2.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    f2.prototype.writeUint16LE = f2.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f2.prototype.writeUint16BE = f2.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f2.prototype.writeUint32LE = f2.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    f2.prototype.writeUint32BE = f2.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function Xr(e, t, r, n, i) {
      en(t, n, i, e, r, 7);
      let o = Number(t & BigInt(4294967295));
      e[r++] = o, o = o >> 8, e[r++] = o, o = o >> 8, e[r++] = o, o = o >> 8, e[r++] = o;
      let a2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, r;
    }
    function zr(e, t, r, n, i) {
      en(t, n, i, e, r, 7);
      let o = Number(t & BigInt(4294967295));
      e[r + 7] = o, o = o >> 8, e[r + 6] = o, o = o >> 8, e[r + 5] = o, o = o >> 8, e[r + 4] = o;
      let a2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = a2, a2 = a2 >> 8, e[r + 2] = a2, a2 = a2 >> 8, e[r + 1] = a2, a2 = a2 >> 8, e[r] = a2, r + 8;
    }
    f2.prototype.writeBigUInt64LE = ee(function(t, r = 0) {
      return Xr(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f2.prototype.writeBigUInt64BE = ee(function(t, r = 0) {
      return zr(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f2.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u2 = Math.pow(2, 8 * n - 1);
        O2(this, t, r, n, u2 - 1, -u2);
      }
      let o = 0, a2 = 1, s2 = 0;
      for (this[r] = t & 255;++o < n && (a2 *= 256); )
        t < 0 && s2 === 0 && this[r + o - 1] !== 0 && (s2 = 1), this[r + o] = (t / a2 >> 0) - s2 & 255;
      return r + n;
    };
    f2.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u2 = Math.pow(2, 8 * n - 1);
        O2(this, t, r, n, u2 - 1, -u2);
      }
      let o = n - 1, a2 = 1, s2 = 0;
      for (this[r + o] = t & 255;--o >= 0 && (a2 *= 256); )
        t < 0 && s2 === 0 && this[r + o + 1] !== 0 && (s2 = 1), this[r + o] = (t / a2 >> 0) - s2 & 255;
      return r + n;
    };
    f2.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    f2.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f2.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f2.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    f2.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    f2.prototype.writeBigInt64LE = ee(function(t, r = 0) {
      return Xr(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    f2.prototype.writeBigInt64BE = ee(function(t, r = 0) {
      return zr(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Zr(e, t, r, n, i, o) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function Jr(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || Zr(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), we.write(e, t, r, n, 23, 4), r + 4;
    }
    f2.prototype.writeFloatLE = function(t, r, n) {
      return Jr(this, t, r, true, n);
    };
    f2.prototype.writeFloatBE = function(t, r, n) {
      return Jr(this, t, r, false, n);
    };
    function Qr(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || Zr(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), we.write(e, t, r, n, 52, 8), r + 8;
    }
    f2.prototype.writeDoubleLE = function(t, r, n) {
      return Qr(this, t, r, true, n);
    };
    f2.prototype.writeDoubleBE = function(t, r, n) {
      return Qr(this, t, r, false, n);
    };
    f2.prototype.copy = function(t, r, n, i) {
      if (!f2.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o;
    };
    f2.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !f2.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let a2 = t.charCodeAt(0);
          (i === "utf8" && a2 < 128 || i === "latin1") && (t = a2);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o;
      if (typeof t == "number")
        for (o = r;o < n; ++o)
          this[o] = t;
      else {
        let a2 = f2.isBuffer(t) ? t : f2.from(t, i), s2 = a2.length;
        if (s2 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o = 0;o < n - r; ++o)
          this[o + r] = a2[o % s2];
      }
      return this;
    };
    var ge = {};
    function Ct(e, t, r) {
      ge[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    Ct("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    Ct("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    Ct("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = Wr(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = Wr(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function Wr(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function Bo(e, t, r) {
      me(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ie(t, e.length - (r + 1));
    }
    function en(e, t, r, n, i, o) {
      if (e > r || e < t) {
        let a2 = typeof t == "bigint" ? "n" : "", s2;
        throw o > 3 ? t === 0 || t === BigInt(0) ? s2 = `>= 0${a2} and < 2${a2} ** ${(o + 1) * 8}${a2}` : s2 = `>= -(2${a2} ** ${(o + 1) * 8 - 1}${a2}) and < 2 ** ${(o + 1) * 8 - 1}${a2}` : s2 = `>= ${t}${a2} and <= ${r}${a2}`, new ge.ERR_OUT_OF_RANGE("value", s2, e);
      }
      Bo(n, i, o);
    }
    function me(e, t) {
      if (typeof e != "number")
        throw new ge.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ie(e, t, r) {
      throw Math.floor(e) !== e ? (me(e, r), new ge.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new ge.ERR_BUFFER_OUT_OF_BOUNDS : new ge.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var Co = /[^+/0-9A-Za-z-_]/g;
    function Io(e) {
      if (e = e.split("=")[0], e = e.trim().replace(Co, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Tt(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o = [];
      for (let a2 = 0;a2 < n; ++a2) {
        if (r = e.charCodeAt(a2), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o.push(239, 191, 189);
              continue;
            } else if (a2 + 1 === n) {
              (t -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o;
    }
    function Lo(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Mo(e, t) {
      let r, n, i, o = [];
      for (let a2 = 0;a2 < e.length && !((t -= 2) < 0); ++a2)
        r = e.charCodeAt(a2), n = r >> 8, i = r % 256, o.push(i), o.push(n);
      return o;
    }
    function tn(e) {
      return xt.toByteArray(Io(e));
    }
    function Ge(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function W(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function It(e) {
      return e !== e;
    }
    var Oo = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function ee(e) {
      return typeof BigInt > "u" ? Fo : e;
    }
    function Fo() {
      throw new Error("BigInt not supported");
    }
  });
  Lt = b2(() => {
  });
  an = b2((Of, on) => {
    function rn(e, t) {
      var r = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function No(e) {
      for (var t = 1;t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? rn(Object(r), true).forEach(function(n) {
          Uo(e, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : rn(Object(r)).forEach(function(n) {
          Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return e;
    }
    function Uo(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    function Po(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function nn(e, t) {
      for (var r = 0;r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    function qo(e, t, r) {
      return t && nn(e.prototype, t), r && nn(e, r), e;
    }
    var Do = _e(), Ke = Do.Buffer, ko = Lt(), Mt = ko.inspect, jo = Mt && Mt.custom || "inspect";
    function Ho(e, t, r) {
      Ke.prototype.copy.call(e, t, r);
    }
    on.exports = function() {
      function e() {
        Po(this, e), this.head = null, this.tail = null, this.length = 0;
      }
      return qo(e, [{ key: "push", value: function(r) {
        var n = { data: r, next: null };
        this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var n = { data: r, next: this.head };
        this.length === 0 && (this.tail = n), this.head = n, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var n = this.head, i = "" + n.data;n = n.next; )
          i += r + n.data;
        return i;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return Ke.alloc(0);
        for (var n = Ke.allocUnsafe(r >>> 0), i = this.head, o = 0;i; )
          Ho(i.data, n, o), o += i.data.length, i = i.next;
        return n;
      } }, { key: "consume", value: function(r, n) {
        var i;
        return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var n = this.head, i = 1, o = n.data;
        for (r -= o.length;n = n.next; ) {
          var a2 = n.data, s2 = r > a2.length ? a2.length : r;
          if (s2 === a2.length ? o += a2 : o += a2.slice(0, r), r -= s2, r === 0) {
            s2 === a2.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = a2.slice(s2));
            break;
          }
          ++i;
        }
        return this.length -= i, o;
      } }, { key: "_getBuffer", value: function(r) {
        var n = Ke.allocUnsafe(r), i = this.head, o = 1;
        for (i.data.copy(n), r -= i.data.length;i = i.next; ) {
          var a2 = i.data, s2 = r > a2.length ? a2.length : r;
          if (a2.copy(n, n.length - r, 0, s2), r -= s2, r === 0) {
            s2 === a2.length ? (++o, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = a2.slice(s2));
            break;
          }
          ++o;
        }
        return this.length -= o, n;
      } }, { key: jo, value: function(r, n) {
        return Mt(this, No({}, n, { depth: 0, customInspect: false }));
      } }]), e;
    }();
  });
  Ft = b2((Ff, fn) => {
    function Wo(e, t) {
      var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
      return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(Ot, this, e)) : process.nextTick(Ot, this, e)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e || null, function(o) {
        !t && o ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Ve, r) : (r._writableState.errorEmitted = true, process.nextTick(sn, r, o)) : process.nextTick(sn, r, o) : t ? (process.nextTick(Ve, r), t(o)) : process.nextTick(Ve, r);
      }), this);
    }
    function sn(e, t) {
      Ot(e, t), Ve(e);
    }
    function Ve(e) {
      e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function $o() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function Ot(e, t) {
      e.emit("error", t);
    }
    function Go(e, t) {
      var { _readableState: r, _writableState: n } = e;
      r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    fn.exports = { destroy: Wo, undestroy: $o, errorOrDestroy: Go };
  });
  fe = b2((Nf, hn) => {
    function Ko(e, t) {
      e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var ln = {};
    function P(e, t, r) {
      r || (r = Error);
      function n(o, a2, s2) {
        return typeof t == "string" ? t : t(o, a2, s2);
      }
      var i = function(o) {
        Ko(a2, o);
        function a2(s2, u2, l2) {
          return o.call(this, n(s2, u2, l2)) || this;
        }
        return a2;
      }(r);
      i.prototype.name = r.name, i.prototype.code = e, ln[e] = i;
    }
    function un(e, t) {
      if (Array.isArray(e)) {
        var r = e.length;
        return e = e.map(function(n) {
          return String(n);
        }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
      } else
        return "of ".concat(t, " ").concat(String(e));
    }
    function Vo(e, t, r) {
      return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Yo(e, t, r) {
      return (r === undefined || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Xo(e, t, r) {
      return typeof r != "number" && (r = 0), r + t.length > e.length ? false : e.indexOf(t, r) !== -1;
    }
    P("ERR_INVALID_OPT_VALUE", function(e, t) {
      return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    P("ERR_INVALID_ARG_TYPE", function(e, t, r) {
      var n;
      typeof t == "string" && Vo(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
      var i;
      if (Yo(e, " argument"))
        i = "The ".concat(e, " ").concat(n, " ").concat(un(t, "type"));
      else {
        var o = Xo(e, ".") ? "property" : "argument";
        i = 'The "'.concat(e, '" ').concat(o, " ").concat(n, " ").concat(un(t, "type"));
      }
      return i += ". Received type ".concat(typeof r), i;
    }, TypeError);
    P("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    P("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
      return "The " + e + " method is not implemented";
    });
    P("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    P("ERR_STREAM_DESTROYED", function(e) {
      return "Cannot call " + e + " after a stream was destroyed";
    });
    P("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    P("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    P("ERR_STREAM_WRITE_AFTER_END", "write after end");
    P("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    P("ERR_UNKNOWN_ENCODING", function(e) {
      return "Unknown encoding: " + e;
    }, TypeError);
    P("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    hn.exports.codes = ln;
  });
  Nt = b2((Uf, cn) => {
    var zo = fe().codes.ERR_INVALID_OPT_VALUE;
    function Zo(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function Jo(e, t, r, n) {
      var i = Zo(t, n, r);
      if (i != null) {
        if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
          var o = n ? r : "highWaterMark";
          throw new zo(o, i);
        }
        return Math.floor(i);
      }
      return e.objectMode ? 16 : 16 * 1024;
    }
    cn.exports = { getHighWaterMark: Jo };
  });
  pn = b2((Pf, dn) => {
    dn.exports = Qo;
    function Qo(e, t) {
      if (Ut("noDeprecation"))
        return e;
      var r = false;
      function n() {
        if (!r) {
          if (Ut("throwDeprecation"))
            throw new Error(t);
          Ut("traceDeprecation") ? console.trace(t) : console.warn(t), r = true;
        }
        return e.apply(this, arguments);
      }
      return n;
    }
    function Ut(e) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var t = global.localStorage[e];
      return t == null ? false : String(t).toLowerCase() === "true";
    }
  });
  Dt = b2((qf, _n) => {
    _n.exports = A2;
    function gn(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        Ta(t, e);
      };
    }
    var ve;
    A2.WritableState = Me;
    var ea = { deprecate: pn() }, wn = _t(), Xe = _e().Buffer, ta = global.Uint8Array || function() {
    };
    function ra(e) {
      return Xe.from(e);
    }
    function na(e) {
      return Xe.isBuffer(e) || e instanceof ta;
    }
    var qt = Ft(), ia = Nt(), oa = ia.getHighWaterMark, te = fe().codes, aa = te.ERR_INVALID_ARG_TYPE, sa = te.ERR_METHOD_NOT_IMPLEMENTED, fa = te.ERR_MULTIPLE_CALLBACK, ua = te.ERR_STREAM_CANNOT_PIPE, la = te.ERR_STREAM_DESTROYED, ha = te.ERR_STREAM_NULL_VALUES, ca = te.ERR_STREAM_WRITE_AFTER_END, da = te.ERR_UNKNOWN_ENCODING, Ee = qt.errorOrDestroy;
    Q()(A2, wn);
    function pa() {
    }
    function Me(e, t, r) {
      ve = ve || ue(), e = e || {}, typeof r != "boolean" && (r = t instanceof ve), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = oa(this, e, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var n = e.decodeStrings === false;
      this.decodeStrings = !n, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
        va(t, i);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new gn(this);
    }
    Me.prototype.getBuffer = function() {
      for (var t = this.bufferedRequest, r = [];t; )
        r.push(t), t = t.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Me.prototype, "buffer", { get: ea.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ye;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ye = Function.prototype[Symbol.hasInstance], Object.defineProperty(A2, Symbol.hasInstance, { value: function(t) {
      return Ye.call(this, t) ? true : this !== A2 ? false : t && t._writableState instanceof Me;
    } })) : Ye = function(t) {
      return t instanceof this;
    };
    function A2(e) {
      ve = ve || ue();
      var t = this instanceof ve;
      if (!t && !Ye.call(A2, this))
        return new A2(e);
      this._writableState = new Me(e, this, t), this.writable = true, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), wn.call(this);
    }
    A2.prototype.pipe = function() {
      Ee(this, new ua);
    };
    function ya(e, t) {
      var r = new ca;
      Ee(e, r), process.nextTick(t, r);
    }
    function ga(e, t, r, n) {
      var i;
      return r === null ? i = new ha : typeof r != "string" && !t.objectMode && (i = new aa("chunk", ["string", "Buffer"], r)), i ? (Ee(e, i), process.nextTick(n, i), false) : true;
    }
    A2.prototype.write = function(e, t, r) {
      var n = this._writableState, i = false, o = !n.objectMode && na(e);
      return o && !Xe.isBuffer(e) && (e = ra(e)), typeof t == "function" && (r = t, t = null), o ? t = "buffer" : t || (t = n.defaultEncoding), typeof r != "function" && (r = pa), n.ending ? ya(this, r) : (o || ga(this, n, e, r)) && (n.pendingcb++, i = ma(this, n, o, e, t, r)), i;
    };
    A2.prototype.cork = function() {
      this._writableState.corked++;
    };
    A2.prototype.uncork = function() {
      var e = this._writableState;
      e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && mn(this, e));
    };
    A2.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1))
        throw new da(t);
      return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(A2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function wa(e, t, r) {
      return !e.objectMode && e.decodeStrings !== false && typeof t == "string" && (t = Xe.from(t, r)), t;
    }
    Object.defineProperty(A2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function ma(e, t, r, n, i, o) {
      if (!r) {
        var a2 = wa(t, n, i);
        n !== a2 && (r = true, i = "buffer", n = a2);
      }
      var s2 = t.objectMode ? 1 : n.length;
      t.length += s2;
      var u2 = t.length < t.highWaterMark;
      if (u2 || (t.needDrain = true), t.writing || t.corked) {
        var l2 = t.lastBufferedRequest;
        t.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o, next: null }, l2 ? l2.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
      } else
        Pt(e, t, false, s2, n, i, o);
      return u2;
    }
    function Pt(e, t, r, n, i, o, a2) {
      t.writelen = n, t.writecb = a2, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new la("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = false;
    }
    function ba(e, t, r, n, i) {
      --t.pendingcb, r ? (process.nextTick(i, n), process.nextTick(Le, e, t), e._writableState.errorEmitted = true, Ee(e, n)) : (i(n), e._writableState.errorEmitted = true, Ee(e, n), Le(e, t));
    }
    function _a(e) {
      e.writing = false, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function va(e, t) {
      var r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function")
        throw new fa;
      if (_a(r), t)
        ba(e, r, n, t, i);
      else {
        var o = bn(r) || e.destroyed;
        !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && mn(e, r), n ? process.nextTick(yn, e, r, o, i) : yn(e, r, o, i);
      }
    }
    function yn(e, t, r, n) {
      r || Ea(e, t), t.pendingcb--, n(), Le(e, t);
    }
    function Ea(e, t) {
      t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));
    }
    function mn(e, t) {
      t.bufferProcessing = true;
      var r = t.bufferedRequest;
      if (e._writev && r && r.next) {
        var n = t.bufferedRequestCount, i = new Array(n), o = t.corkedRequestsFree;
        o.entry = r;
        for (var a2 = 0, s2 = true;r; )
          i[a2] = r, r.isBuf || (s2 = false), r = r.next, a2 += 1;
        i.allBuffers = s2, Pt(e, t, true, t.length, i, "", o.finish), t.pendingcb++, t.lastBufferedRequest = null, o.next ? (t.corkedRequestsFree = o.next, o.next = null) : t.corkedRequestsFree = new gn(t), t.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: u2, encoding: l2, callback: h2 } = r, c2 = t.objectMode ? 1 : u2.length;
          if (Pt(e, t, false, c2, u2, l2, h2), r = r.next, t.bufferedRequestCount--, t.writing)
            break;
        }
        r === null && (t.lastBufferedRequest = null);
      }
      t.bufferedRequest = r, t.bufferProcessing = false;
    }
    A2.prototype._write = function(e, t, r) {
      r(new sa("_write()"));
    };
    A2.prototype._writev = null;
    A2.prototype.end = function(e, t, r) {
      var n = this._writableState;
      return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || Sa(this, n, r), this;
    };
    Object.defineProperty(A2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function bn(e) {
      return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function xa(e, t) {
      e._final(function(r) {
        t.pendingcb--, r && Ee(e, r), t.prefinished = true, e.emit("prefinish"), Le(e, t);
      });
    }
    function Ra(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = true, process.nextTick(xa, e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Le(e, t) {
      var r = bn(t);
      if (r && (Ra(e, t), t.pendingcb === 0 && (t.finished = true, e.emit("finish"), t.autoDestroy))) {
        var n = e._readableState;
        (!n || n.autoDestroy && n.endEmitted) && e.destroy();
      }
      return r;
    }
    function Sa(e, t, r) {
      t.ending = true, Le(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = true, e.writable = false;
    }
    function Ta(e, t, r) {
      var n = e.entry;
      for (e.entry = null;n; ) {
        var i = n.callback;
        t.pendingcb--, i(r), n = n.next;
      }
      t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(A2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(t) {
      !this._writableState || (this._writableState.destroyed = t);
    } });
    A2.prototype.destroy = qt.destroy;
    A2.prototype._undestroy = qt.undestroy;
    A2.prototype._destroy = function(e, t) {
      t(e);
    };
  });
  ue = b2((Df, En) => {
    var Aa = Object.keys || function(e) {
      var t = [];
      for (var r in e)
        t.push(r);
      return t;
    };
    En.exports = $;
    var vn = Ht(), jt = Dt();
    Q()($, vn);
    for (kt = Aa(jt.prototype), ze = 0;ze < kt.length; ze++)
      Ze = kt[ze], $.prototype[Ze] || ($.prototype[Ze] = jt.prototype[Ze]);
    var kt, Ze, ze;
    function $(e) {
      if (!(this instanceof $))
        return new $(e);
      vn.call(this, e), jt.call(this, e), this.allowHalfOpen = true, e && (e.readable === false && (this.readable = false), e.writable === false && (this.writable = false), e.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Ba)));
    }
    Object.defineProperty($.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ba() {
      this._writableState.ended || process.nextTick(Ca, this);
    }
    function Ca(e) {
      e.end();
    }
    Object.defineProperty($.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(t) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } });
  });
  Sn = b2((Wt, Rn) => {
    var Je = _e(), G = Je.Buffer;
    function xn(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    G.from && G.alloc && G.allocUnsafe && G.allocUnsafeSlow ? Rn.exports = Je : (xn(Je, Wt), Wt.Buffer = le);
    function le(e, t, r) {
      return G(e, t, r);
    }
    le.prototype = Object.create(G.prototype);
    xn(G, le);
    le.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return G(e, t, r);
    };
    le.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = G(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    le.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return G(e);
    };
    le.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return Je.SlowBuffer(e);
    };
  });
  Bn = b2((An) => {
    var Gt = Sn().Buffer, Tn = Gt.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function Ia(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function La(e) {
      var t = Ia(e);
      if (typeof t != "string" && (Gt.isEncoding === Tn || !Tn(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    An.StringDecoder = Oe;
    function Oe(e) {
      this.encoding = La(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = Pa, this.end = qa, t = 4;
          break;
        case "utf8":
          this.fillLast = Fa, t = 4;
          break;
        case "base64":
          this.text = Da, this.end = ka, t = 3;
          break;
        default:
          this.write = ja, this.end = Ha;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Gt.allocUnsafe(t);
    }
    Oe.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Oe.prototype.end = Ua;
    Oe.prototype.text = Na;
    Oe.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function $t(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Ma(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = $t(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = $t(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = $t(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function Oa(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "\uFFFD";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "\uFFFD";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "\uFFFD";
      }
    }
    function Fa(e) {
      var t = this.lastTotal - this.lastNeed, r = Oa(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Na(e, t) {
      var r = Ma(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function Ua(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "\uFFFD" : t;
    }
    function Pa(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function qa(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Da(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function ka(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function ja(e) {
      return e.toString(this.encoding);
    }
    function Ha(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Kt = {};
  Er(Kt, { StringDecoder: () => Qe.StringDecoder, default: () => Qe.StringDecoder });
  Vt = vr(() => {
    Qe = Rr(Bn());
  });
  et = b2((jf, Ln) => {
    var Cn = fe().codes.ERR_STREAM_PREMATURE_CLOSE;
    function Wa(e) {
      var t = false;
      return function() {
        if (!t) {
          t = true;
          for (var r = arguments.length, n = new Array(r), i = 0;i < r; i++)
            n[i] = arguments[i];
          e.apply(this, n);
        }
      };
    }
    function $a() {
    }
    function Ga(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function In(e, t, r) {
      if (typeof t == "function")
        return In(e, null, t);
      t || (t = {}), r = Wa(r || $a);
      var n = t.readable || t.readable !== false && e.readable, i = t.writable || t.writable !== false && e.writable, o = function() {
        e.writable || s2();
      }, a2 = e._writableState && e._writableState.finished, s2 = function() {
        i = false, a2 = true, n || r.call(e);
      }, u2 = e._readableState && e._readableState.endEmitted, l2 = function() {
        n = false, u2 = true, i || r.call(e);
      }, h2 = function(g2) {
        r.call(e, g2);
      }, c2 = function() {
        var g2;
        if (n && !u2)
          return (!e._readableState || !e._readableState.ended) && (g2 = new Cn), r.call(e, g2);
        if (i && !a2)
          return (!e._writableState || !e._writableState.ended) && (g2 = new Cn), r.call(e, g2);
      }, d2 = function() {
        e.req.on("finish", s2);
      };
      return Ga(e) ? (e.on("complete", s2), e.on("abort", c2), e.req ? d2() : e.on("request", d2)) : i && !e._writableState && (e.on("end", o), e.on("close", o)), e.on("end", l2), e.on("finish", s2), t.error !== false && e.on("error", h2), e.on("close", c2), function() {
        e.removeListener("complete", s2), e.removeListener("abort", c2), e.removeListener("request", d2), e.req && e.req.removeListener("finish", s2), e.removeListener("end", o), e.removeListener("close", o), e.removeListener("finish", s2), e.removeListener("end", l2), e.removeListener("error", h2), e.removeListener("close", c2);
      };
    }
    Ln.exports = In;
  });
  On = b2((Hf, Mn) => {
    var tt;
    function re(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    var Ka = et(), ne = Symbol("lastResolve"), he = Symbol("lastReject"), Fe = Symbol("error"), rt = Symbol("ended"), ce = Symbol("lastPromise"), Yt = Symbol("handlePromise"), de = Symbol("stream");
    function ie(e, t) {
      return { value: e, done: t };
    }
    function Va(e) {
      var t = e[ne];
      if (t !== null) {
        var r = e[de].read();
        r !== null && (e[ce] = null, e[ne] = null, e[he] = null, t(ie(r, false)));
      }
    }
    function Ya(e) {
      process.nextTick(Va, e);
    }
    function Xa(e, t) {
      return function(r, n) {
        e.then(function() {
          if (t[rt]) {
            r(ie(undefined, true));
            return;
          }
          t[Yt](r, n);
        }, n);
      };
    }
    var za = Object.getPrototypeOf(function() {
    }), Za = Object.setPrototypeOf((tt = { get stream() {
      return this[de];
    }, next: function() {
      var t = this, r = this[Fe];
      if (r !== null)
        return Promise.reject(r);
      if (this[rt])
        return Promise.resolve(ie(undefined, true));
      if (this[de].destroyed)
        return new Promise(function(a2, s2) {
          process.nextTick(function() {
            t[Fe] ? s2(t[Fe]) : a2(ie(undefined, true));
          });
        });
      var n = this[ce], i;
      if (n)
        i = new Promise(Xa(n, this));
      else {
        var o = this[de].read();
        if (o !== null)
          return Promise.resolve(ie(o, false));
        i = new Promise(this[Yt]);
      }
      return this[ce] = i, i;
    } }, re(tt, Symbol.asyncIterator, function() {
      return this;
    }), re(tt, "return", function() {
      var t = this;
      return new Promise(function(r, n) {
        t[de].destroy(null, function(i) {
          if (i) {
            n(i);
            return;
          }
          r(ie(undefined, true));
        });
      });
    }), tt), za), Ja = function(t) {
      var r, n = Object.create(Za, (r = {}, re(r, de, { value: t, writable: true }), re(r, ne, { value: null, writable: true }), re(r, he, { value: null, writable: true }), re(r, Fe, { value: null, writable: true }), re(r, rt, { value: t._readableState.endEmitted, writable: true }), re(r, Yt, { value: function(o, a2) {
        var s2 = n[de].read();
        s2 ? (n[ce] = null, n[ne] = null, n[he] = null, o(ie(s2, false))) : (n[ne] = o, n[he] = a2);
      }, writable: true }), r));
      return n[ce] = null, Ka(t, function(i) {
        if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var o = n[he];
          o !== null && (n[ce] = null, n[ne] = null, n[he] = null, o(i)), n[Fe] = i;
          return;
        }
        var a2 = n[ne];
        a2 !== null && (n[ce] = null, n[ne] = null, n[he] = null, a2(ie(undefined, true))), n[rt] = true;
      }), t.on("readable", Ya.bind(null, n)), n;
    };
    Mn.exports = Ja;
  });
  Nn = b2((Wf, Fn) => {
    Fn.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  Ht = b2((Gf, Gn) => {
    Gn.exports = _2;
    var xe;
    _2.ReadableState = Dn;
    var $f = bt().EventEmitter, qn = function(t, r) {
      return t.listeners(r).length;
    }, Ue = _t(), nt = _e().Buffer, Qa = global.Uint8Array || function() {
    };
    function es(e) {
      return nt.from(e);
    }
    function ts(e) {
      return nt.isBuffer(e) || e instanceof Qa;
    }
    var Xt = Lt(), w;
    Xt && Xt.debuglog ? w = Xt.debuglog("stream") : w = function() {
    };
    var rs = an(), rr = Ft(), ns = Nt(), is = ns.getHighWaterMark, it = fe().codes, os = it.ERR_INVALID_ARG_TYPE, as = it.ERR_STREAM_PUSH_AFTER_EOF, ss = it.ERR_METHOD_NOT_IMPLEMENTED, fs = it.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Re, zt, Zt;
    Q()(_2, Ue);
    var Ne = rr.errorOrDestroy, Jt = ["error", "close", "destroy", "pause", "resume"];
    function us(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    function Dn(e, t, r) {
      xe = xe || ue(), e = e || {}, typeof r != "boolean" && (r = t instanceof xe), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = is(this, e, "readableHighWaterMark", r), this.buffer = new rs, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.destroyed = false, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e.encoding && (Re || (Re = (Vt(), dt(Kt)).StringDecoder), this.decoder = new Re(e.encoding), this.encoding = e.encoding);
    }
    function _2(e) {
      if (xe = xe || ue(), !(this instanceof _2))
        return new _2(e);
      var t = this instanceof xe;
      this._readableState = new Dn(e, this, t), this.readable = true, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), Ue.call(this);
    }
    Object.defineProperty(_2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } });
    _2.prototype.destroy = rr.destroy;
    _2.prototype._undestroy = rr.undestroy;
    _2.prototype._destroy = function(e, t) {
      t(e);
    };
    _2.prototype.push = function(e, t) {
      var r = this._readableState, n;
      return r.objectMode ? n = true : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = nt.from(e, t), t = ""), n = true), kn(this, e, t, false, n);
    };
    _2.prototype.unshift = function(e) {
      return kn(this, e, null, true, false);
    };
    function kn(e, t, r, n, i) {
      w("readableAddChunk", t);
      var o = e._readableState;
      if (t === null)
        o.reading = false, cs(e, o);
      else {
        var a2;
        if (i || (a2 = ls(o, t)), a2)
          Ne(e, a2);
        else if (o.objectMode || t && t.length > 0)
          if (typeof t != "string" && !o.objectMode && Object.getPrototypeOf(t) !== nt.prototype && (t = es(t)), n)
            o.endEmitted ? Ne(e, new fs) : Qt(e, o, t, true);
          else if (o.ended)
            Ne(e, new as);
          else {
            if (o.destroyed)
              return false;
            o.reading = false, o.decoder && !r ? (t = o.decoder.write(t), o.objectMode || t.length !== 0 ? Qt(e, o, t, false) : tr(e, o)) : Qt(e, o, t, false);
          }
        else
          n || (o.reading = false, tr(e, o));
      }
      return !o.ended && (o.length < o.highWaterMark || o.length === 0);
    }
    function Qt(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ot(e)), tr(e, t);
    }
    function ls(e, t) {
      var r;
      return !ts(t) && typeof t != "string" && t !== undefined && !e.objectMode && (r = new os("chunk", ["string", "Buffer", "Uint8Array"], t)), r;
    }
    _2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    _2.prototype.setEncoding = function(e) {
      Re || (Re = (Vt(), dt(Kt)).StringDecoder);
      var t = new Re(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, n = "";r !== null; )
        n += t.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
    };
    var Un = 1073741824;
    function hs(e) {
      return e >= Un ? e = Un : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Pn(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = hs(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = true, 0));
    }
    _2.prototype.read = function(e) {
      w("read", e), e = parseInt(e, 10);
      var t = this._readableState, r = e;
      if (e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return w("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? er(this) : ot(this), null;
      if (e = Pn(e, t), e === 0 && t.ended)
        return t.length === 0 && er(this), null;
      var n = t.needReadable;
      w("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, w("length less than watermark", n)), t.ended || t.reading ? (n = false, w("reading or ended", n)) : n && (w("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true), this._read(t.highWaterMark), t.sync = false, t.reading || (e = Pn(r, t)));
      var i;
      return e > 0 ? i = Wn(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && er(this)), i !== null && this.emit("data", i), i;
    };
    function cs(e, t) {
      if (w("onEofChunk"), !t.ended) {
        if (t.decoder) {
          var r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? ot(e) : (t.needReadable = false, t.emittedReadable || (t.emittedReadable = true, jn(e)));
      }
    }
    function ot(e) {
      var t = e._readableState;
      w("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (w("emitReadable", t.flowing), t.emittedReadable = true, process.nextTick(jn, e));
    }
    function jn(e) {
      var t = e._readableState;
      w("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, nr(e);
    }
    function tr(e, t) {
      t.readingMore || (t.readingMore = true, process.nextTick(ds, e, t));
    }
    function ds(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        var r = t.length;
        if (w("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    _2.prototype._read = function(e) {
      Ne(this, new ss("_read()"));
    };
    _2.prototype.pipe = function(e, t) {
      var r = this, n = this._readableState;
      switch (n.pipesCount) {
        case 0:
          n.pipes = e;
          break;
        case 1:
          n.pipes = [n.pipes, e];
          break;
        default:
          n.pipes.push(e);
          break;
      }
      n.pipesCount += 1, w("pipe count=%d opts=%j", n.pipesCount, t);
      var i = (!t || t.end !== false) && e !== process.stdout && e !== process.stderr, o = i ? s2 : E2;
      n.endEmitted ? process.nextTick(o) : r.once("end", o), e.on("unpipe", a2);
      function a2(v, m2) {
        w("onunpipe"), v === r && m2 && m2.hasUnpiped === false && (m2.hasUnpiped = true, h2());
      }
      function s2() {
        w("onend"), e.end();
      }
      var u2 = ps(r);
      e.on("drain", u2);
      var l2 = false;
      function h2() {
        w("cleanup"), e.removeListener("close", p2), e.removeListener("finish", g2), e.removeListener("drain", u2), e.removeListener("error", d2), e.removeListener("unpipe", a2), r.removeListener("end", s2), r.removeListener("end", E2), r.removeListener("data", c2), l2 = true, n.awaitDrain && (!e._writableState || e._writableState.needDrain) && u2();
      }
      r.on("data", c2);
      function c2(v) {
        w("ondata");
        var m2 = e.write(v);
        w("dest.write", m2), m2 === false && ((n.pipesCount === 1 && n.pipes === e || n.pipesCount > 1 && $n(n.pipes, e) !== -1) && !l2 && (w("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
      }
      function d2(v) {
        w("onerror", v), E2(), e.removeListener("error", d2), qn(e, "error") === 0 && Ne(e, v);
      }
      us(e, "error", d2);
      function p2() {
        e.removeListener("finish", g2), E2();
      }
      e.once("close", p2);
      function g2() {
        w("onfinish"), e.removeListener("close", p2), E2();
      }
      e.once("finish", g2);
      function E2() {
        w("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), n.flowing || (w("pipe resume"), r.resume()), e;
    };
    function ps(e) {
      return function() {
        var r = e._readableState;
        w("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && qn(e, "data") && (r.flowing = true, nr(e));
      };
    }
    _2.prototype.unpipe = function(e) {
      var t = this._readableState, r = { hasUnpiped: false };
      if (t.pipesCount === 0)
        return this;
      if (t.pipesCount === 1)
        return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = false, e && e.emit("unpipe", this, r), this);
      if (!e) {
        var { pipes: n, pipesCount: i } = t;
        t.pipes = null, t.pipesCount = 0, t.flowing = false;
        for (var o = 0;o < i; o++)
          n[o].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var a2 = $n(t.pipes, e);
      return a2 === -1 ? this : (t.pipes.splice(a2, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    _2.prototype.on = function(e, t) {
      var r = Ue.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, w("on readable", n.length, n.reading), n.length ? ot(this) : n.reading || process.nextTick(ys, this)), r;
    };
    _2.prototype.addListener = _2.prototype.on;
    _2.prototype.removeListener = function(e, t) {
      var r = Ue.prototype.removeListener.call(this, e, t);
      return e === "readable" && process.nextTick(Hn, this), r;
    };
    _2.prototype.removeAllListeners = function(e) {
      var t = Ue.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && process.nextTick(Hn, this), t;
    };
    function Hn(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = true : e.listenerCount("data") > 0 && e.resume();
    }
    function ys(e) {
      w("readable nexttick read 0"), e.read(0);
    }
    _2.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (w("resume"), e.flowing = !e.readableListening, gs(this, e)), e.paused = false, this;
    };
    function gs(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, process.nextTick(ws, e, t));
    }
    function ws(e, t) {
      w("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), nr(e), t.flowing && !t.reading && e.read(0);
    }
    _2.prototype.pause = function() {
      return w("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (w("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function nr(e) {
      var t = e._readableState;
      for (w("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    _2.prototype.wrap = function(e) {
      var t = this, r = this._readableState, n = false;
      e.on("end", function() {
        if (w("wrapped end"), r.decoder && !r.ended) {
          var a2 = r.decoder.end();
          a2 && a2.length && t.push(a2);
        }
        t.push(null);
      }), e.on("data", function(a2) {
        if (w("wrapped data"), r.decoder && (a2 = r.decoder.write(a2)), !(r.objectMode && a2 == null) && !(!r.objectMode && (!a2 || !a2.length))) {
          var s2 = t.push(a2);
          s2 || (n = true, e.pause());
        }
      });
      for (var i in e)
        this[i] === undefined && typeof e[i] == "function" && (this[i] = function(s2) {
          return function() {
            return e[s2].apply(e, arguments);
          };
        }(i));
      for (var o = 0;o < Jt.length; o++)
        e.on(Jt[o], this.emit.bind(this, Jt[o]));
      return this._read = function(a2) {
        w("wrapped _read", a2), n && (n = false, e.resume());
      }, this;
    };
    typeof Symbol == "function" && (_2.prototype[Symbol.asyncIterator] = function() {
      return zt === undefined && (zt = On()), zt(this);
    });
    Object.defineProperty(_2.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(_2.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(_2.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } });
    _2._fromList = Wn;
    Object.defineProperty(_2.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wn(e, t) {
      if (t.length === 0)
        return null;
      var r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function er(e) {
      var t = e._readableState;
      w("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, process.nextTick(ms, t, e));
    }
    function ms(e, t) {
      if (w("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = true, t.readable = false, t.emit("end"), e.autoDestroy)) {
        var r = t._writableState;
        (!r || r.autoDestroy && r.finished) && t.destroy();
      }
    }
    typeof Symbol == "function" && (_2.from = function(e, t) {
      return Zt === undefined && (Zt = Nn()), Zt(_2, e, t);
    });
    function $n(e, t) {
      for (var r = 0, n = e.length;r < n; r++)
        if (e[r] === t)
          return r;
      return -1;
    }
  });
  ir = b2((Kf, Vn) => {
    Vn.exports = z;
    var at = fe().codes, bs = at.ERR_METHOD_NOT_IMPLEMENTED, _s = at.ERR_MULTIPLE_CALLBACK, vs = at.ERR_TRANSFORM_ALREADY_TRANSFORMING, Es = at.ERR_TRANSFORM_WITH_LENGTH_0, st = ue();
    Q()(z, st);
    function xs(e, t) {
      var r = this._transformState;
      r.transforming = false;
      var n = r.writecb;
      if (n === null)
        return this.emit("error", new _s);
      r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
      var i = this._readableState;
      i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
    function z(e) {
      if (!(this instanceof z))
        return new z(e);
      st.call(this, e), this._transformState = { afterTransform: xs.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Rs);
    }
    function Rs() {
      var e = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
        Kn(e, t, r);
      }) : Kn(this, null, null);
    }
    z.prototype.push = function(e, t) {
      return this._transformState.needTransform = false, st.prototype.push.call(this, e, t);
    };
    z.prototype._transform = function(e, t, r) {
      r(new bs("_transform()"));
    };
    z.prototype._write = function(e, t, r) {
      var n = this._transformState;
      if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
      }
    };
    z.prototype._read = function(e) {
      var t = this._transformState;
      t.writechunk !== null && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
    };
    z.prototype._destroy = function(e, t) {
      st.prototype._destroy.call(this, e, function(r) {
        t(r);
      });
    };
    function Kn(e, t, r) {
      if (t)
        return e.emit("error", t);
      if (r != null && e.push(r), e._writableState.length)
        throw new Es;
      if (e._transformState.transforming)
        throw new vs;
      return e.push(null);
    }
  });
  zn = b2((Vf, Xn) => {
    Xn.exports = Pe;
    var Yn = ir();
    Q()(Pe, Yn);
    function Pe(e) {
      if (!(this instanceof Pe))
        return new Pe(e);
      Yn.call(this, e);
    }
    Pe.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  ti = b2((Yf, ei) => {
    var or;
    function Ss(e) {
      var t = false;
      return function() {
        t || (t = true, e.apply(undefined, arguments));
      };
    }
    var Qn = fe().codes, Ts = Qn.ERR_MISSING_ARGS, As = Qn.ERR_STREAM_DESTROYED;
    function Zn(e) {
      if (e)
        throw e;
    }
    function Bs(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Cs(e, t, r, n) {
      n = Ss(n);
      var i = false;
      e.on("close", function() {
        i = true;
      }), or === undefined && (or = et()), or(e, { readable: t, writable: r }, function(a2) {
        if (a2)
          return n(a2);
        i = true, n();
      });
      var o = false;
      return function(a2) {
        if (!i && !o) {
          if (o = true, Bs(e))
            return e.abort();
          if (typeof e.destroy == "function")
            return e.destroy();
          n(a2 || new As("pipe"));
        }
      };
    }
    function Jn(e) {
      e();
    }
    function Is(e, t) {
      return e.pipe(t);
    }
    function Ls(e) {
      return !e.length || typeof e[e.length - 1] != "function" ? Zn : e.pop();
    }
    function Ms() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      var n = Ls(t);
      if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
        throw new Ts("streams");
      var i, o = t.map(function(a2, s2) {
        var u2 = s2 < t.length - 1, l2 = s2 > 0;
        return Cs(a2, u2, l2, function(h2) {
          i || (i = h2), h2 && o.forEach(Jn), !u2 && (o.forEach(Jn), n(i));
        });
      });
      return t.reduce(Is);
    }
    ei.exports = Ms;
  });
  ar = b2((q, ri) => {
    q = ri.exports = Ht();
    q.Stream = q;
    q.Readable = q;
    q.Writable = Dt();
    q.Duplex = ue();
    q.Transform = ir();
    q.PassThrough = zn();
    q.finished = et();
    q.pipeline = ti();
  });
  ur = b2((fr) => {
    var ni = gt(), Os = Q(), ii = ar(), ft = fr.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, sr = fr.IncomingMessage = function(e, t, r, n) {
      var i = this;
      if (ii.Readable.call(i), i._mode = r, i.headers = {}, i.rawHeaders = [], i.trailers = {}, i.rawTrailers = [], i.on("end", function() {
        process.nextTick(function() {
          i.emit("close");
        });
      }), r === "fetch") {
        let c2 = function() {
          a2.read().then(function(d2) {
            if (!i._destroyed) {
              if (n(d2.done), d2.done) {
                i.push(null);
                return;
              }
              i.push(Buffer.from(d2.value)), c2();
            }
          }).catch(function(d2) {
            n(true), i._destroyed || i.emit("error", d2);
          });
        };
        var h2 = c2;
        if (i._fetchResponse = t, i.url = t.url, i.statusCode = t.status, i.statusMessage = t.statusText, t.headers.forEach(function(d2, p2) {
          i.headers[p2.toLowerCase()] = d2, i.rawHeaders.push(p2, d2);
        }), ni.writableStream) {
          var o = new WritableStream({ write: function(d2) {
            return n(false), new Promise(function(p2, g2) {
              i._destroyed ? g2() : i.push(Buffer.from(d2)) ? p2() : i._resumeFetch = p2;
            });
          }, close: function() {
            n(true), i._destroyed || i.push(null);
          }, abort: function(d2) {
            n(true), i._destroyed || i.emit("error", d2);
          } });
          try {
            t.body.pipeTo(o).catch(function(d2) {
              n(true), i._destroyed || i.emit("error", d2);
            });
            return;
          } catch {
          }
        }
        var a2 = t.body.getReader();
        c2();
      } else {
        i._xhr = e, i._pos = 0, i.url = e.responseURL, i.statusCode = e.status, i.statusMessage = e.statusText;
        var s2 = e.getAllResponseHeaders().split(/\r?\n/);
        if (s2.forEach(function(c2) {
          var d2 = c2.match(/^([^:]+):\s*(.*)/);
          if (d2) {
            var p2 = d2[1].toLowerCase();
            p2 === "set-cookie" ? (i.headers[p2] === undefined && (i.headers[p2] = []), i.headers[p2].push(d2[2])) : i.headers[p2] !== undefined ? i.headers[p2] += ", " + d2[2] : i.headers[p2] = d2[2], i.rawHeaders.push(d2[1], d2[2]);
          }
        }), i._charset = "x-user-defined", !ni.overrideMimeType) {
          var u2 = i.rawHeaders["mime-type"];
          if (u2) {
            var l2 = u2.match(/;\s*charset=([^;])(;|$)/);
            l2 && (i._charset = l2[1].toLowerCase());
          }
          i._charset || (i._charset = "utf-8");
        }
      }
    };
    Os(sr, ii.Readable);
    sr.prototype._read = function() {
      var e = this, t = e._resumeFetch;
      t && (e._resumeFetch = null, t());
    };
    sr.prototype._onXHRProgress = function(e) {
      var t = this, r = t._xhr, n = null;
      switch (t._mode) {
        case "text":
          if (n = r.responseText, n.length > t._pos) {
            var i = n.substr(t._pos);
            if (t._charset === "x-user-defined") {
              for (var o = Buffer.alloc(i.length), a2 = 0;a2 < i.length; a2++)
                o[a2] = i.charCodeAt(a2) & 255;
              t.push(o);
            } else
              t.push(i, t._charset);
            t._pos = n.length;
          }
          break;
        case "arraybuffer":
          if (r.readyState !== ft.DONE || !r.response)
            break;
          n = r.response, t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "moz-chunked-arraybuffer":
          if (n = r.response, r.readyState !== ft.LOADING || !n)
            break;
          t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "ms-stream":
          if (n = r.response, r.readyState !== ft.LOADING)
            break;
          var s2 = new global.MSStreamReader;
          s2.onprogress = function() {
            s2.result.byteLength > t._pos && (t.push(Buffer.from(new Uint8Array(s2.result.slice(t._pos)))), t._pos = s2.result.byteLength);
          }, s2.onload = function() {
            e(true), t.push(null);
          }, s2.readAsArrayBuffer(n);
          break;
      }
      t._xhr.readyState === ft.DONE && t._mode !== "ms-stream" && (e(true), t.push(null));
    };
  });
  fi = b2((zf, si) => {
    var pe = gt(), Fs = Q(), ai = ur(), lr = ar(), Ns = ai.IncomingMessage, oi = ai.readyStates;
    function Us(e, t) {
      return pe.fetch && t ? "fetch" : pe.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : pe.msstream ? "ms-stream" : pe.arraybuffer && e ? "arraybuffer" : "text";
    }
    var M2 = si.exports = function(e) {
      var t = this;
      lr.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(i) {
        t.setHeader(i, e.headers[i]);
      });
      var r, n = true;
      if (e.mode === "disable-fetch" || "requestTimeout" in e && !pe.abortController)
        n = false, r = true;
      else if (e.mode === "prefer-streaming")
        r = false;
      else if (e.mode === "allow-wrong-content-type")
        r = !pe.overrideMimeType;
      else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
        r = true;
      else
        throw new Error("Invalid value for opts.mode");
      t._mode = Us(r, n), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
        t._onFinish();
      });
    };
    Fs(M2, lr.Writable);
    M2.prototype.setHeader = function(e, t) {
      var r = this, n = e.toLowerCase();
      qs.indexOf(n) === -1 && (r._headers[n] = { name: e, value: t });
    };
    M2.prototype.getHeader = function(e) {
      var t = this._headers[e.toLowerCase()];
      return t ? t.value : null;
    };
    M2.prototype.removeHeader = function(e) {
      var t = this;
      delete t._headers[e.toLowerCase()];
    };
    M2.prototype._onFinish = function() {
      var e = this;
      if (!e._destroyed) {
        var t = e._opts;
        "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
        var r = e._headers, n = null;
        t.method !== "GET" && t.method !== "HEAD" && (n = new Blob(e._body, { type: (r["content-type"] || {}).value || "" }));
        var i = [];
        if (Object.keys(r).forEach(function(u2) {
          var l2 = r[u2].name, h2 = r[u2].value;
          Array.isArray(h2) ? h2.forEach(function(c2) {
            i.push([l2, c2]);
          }) : i.push([l2, h2]);
        }), e._mode === "fetch") {
          var o = null;
          if (pe.abortController) {
            var a2 = new AbortController;
            o = a2.signal, e._fetchAbortController = a2, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = global.setTimeout(function() {
              e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
            }, t.requestTimeout));
          }
          global.fetch(e._opts.url, { method: e._opts.method, headers: i, body: n || undefined, mode: "cors", credentials: t.withCredentials ? "include" : "same-origin", signal: o }).then(function(u2) {
            e._fetchResponse = u2, e._resetTimers(false), e._connect();
          }, function(u2) {
            e._resetTimers(true), e._destroyed || e.emit("error", u2);
          });
        } else {
          var s2 = e._xhr = new global.XMLHttpRequest;
          try {
            s2.open(e._opts.method, e._opts.url, true);
          } catch (u2) {
            process.nextTick(function() {
              e.emit("error", u2);
            });
            return;
          }
          "responseType" in s2 && (s2.responseType = e._mode), "withCredentials" in s2 && (s2.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in s2 && s2.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (s2.timeout = t.requestTimeout, s2.ontimeout = function() {
            e.emit("requestTimeout");
          }), i.forEach(function(u2) {
            s2.setRequestHeader(u2[0], u2[1]);
          }), e._response = null, s2.onreadystatechange = function() {
            switch (s2.readyState) {
              case oi.LOADING:
              case oi.DONE:
                e._onXHRProgress();
                break;
            }
          }, e._mode === "moz-chunked-arraybuffer" && (s2.onprogress = function() {
            e._onXHRProgress();
          }), s2.onerror = function() {
            e._destroyed || (e._resetTimers(true), e.emit("error", new Error("XHR error")));
          };
          try {
            s2.send(n);
          } catch (u2) {
            process.nextTick(function() {
              e.emit("error", u2);
            });
            return;
          }
        }
      }
    };
    function Ps(e) {
      try {
        var t = e.status;
        return t !== null && t !== 0;
      } catch {
        return false;
      }
    }
    M2.prototype._onXHRProgress = function() {
      var e = this;
      e._resetTimers(false), !(!Ps(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
    };
    M2.prototype._connect = function() {
      var e = this;
      e._destroyed || (e._response = new Ns(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
        e.emit("error", t);
      }), e.emit("response", e._response));
    };
    M2.prototype._write = function(e, t, r) {
      var n = this;
      n._body.push(e), r();
    };
    M2.prototype._resetTimers = function(e) {
      var t = this;
      global.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (global.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = global.setTimeout(function() {
        t.emit("timeout");
      }, t._socketTimeout));
    };
    M2.prototype.abort = M2.prototype.destroy = function(e) {
      var t = this;
      t._destroyed = true, t._resetTimers(true), t._response && (t._response._destroyed = true), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
    };
    M2.prototype.end = function(e, t, r) {
      var n = this;
      typeof e == "function" && (r = e, e = undefined), lr.Writable.prototype.end.call(n, e, t, r);
    };
    M2.prototype.setTimeout = function(e, t) {
      var r = this;
      t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(false);
    };
    M2.prototype.flushHeaders = function() {
    };
    M2.prototype.setNoDelay = function() {
    };
    M2.prototype.setSocketKeepAlive = function() {
    };
    var qs = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  });
  li = b2((Zf, ui) => {
    ui.exports = ks;
    var Ds = Object.prototype.hasOwnProperty;
    function ks() {
      for (var e = {}, t = 0;t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r)
          Ds.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }
  });
  ci = b2((Jf, hi) => {
    hi.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
  });
  _i = {};
  Er(_i, { decode: () => pr, default: () => Ys, encode: () => yr, toASCII: () => bi, toUnicode: () => mi, ucs2decode: () => dr, ucs2encode: () => gi });
  vi = vr(() => {
    pi = "-", js = /^xn--/, Hs = /[^\0-\x7F]/, Ws = /[\x2E\u3002\uFF0E\uFF61]/g, $s = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, hr = 36 - 1, K = Math.floor, cr = String.fromCharCode;
    gi = (e) => String.fromCodePoint(...e), Ks = function(e) {
      return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : 36;
    }, di = function(e, t) {
      return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
    }, wi = function(e, t, r) {
      let n = 0;
      for (e = r ? K(e / 700) : e >> 1, e += K(e / t);e > hr * 26 >> 1; n += 36)
        e = K(e / hr);
      return K(n + (hr + 1) * e / (e + 38));
    }, pr = function(e) {
      let t = [], r = e.length, n = 0, i = 128, o = 72, a2 = e.lastIndexOf(pi);
      a2 < 0 && (a2 = 0);
      for (let s2 = 0;s2 < a2; ++s2)
        e.charCodeAt(s2) >= 128 && oe("not-basic"), t.push(e.charCodeAt(s2));
      for (let s2 = a2 > 0 ? a2 + 1 : 0;s2 < r; ) {
        let u2 = n;
        for (let h2 = 1, c2 = 36;; c2 += 36) {
          s2 >= r && oe("invalid-input");
          let d2 = Ks(e.charCodeAt(s2++));
          d2 >= 36 && oe("invalid-input"), d2 > K((2147483647 - n) / h2) && oe("overflow"), n += d2 * h2;
          let p2 = c2 <= o ? 1 : c2 >= o + 26 ? 26 : c2 - o;
          if (d2 < p2)
            break;
          let g2 = 36 - p2;
          h2 > K(2147483647 / g2) && oe("overflow"), h2 *= g2;
        }
        let l2 = t.length + 1;
        o = wi(n - u2, l2, u2 == 0), K(n / l2) > 2147483647 - i && oe("overflow"), i += K(n / l2), n %= l2, t.splice(n++, 0, i);
      }
      return String.fromCodePoint(...t);
    }, yr = function(e) {
      let t = [];
      e = dr(e);
      let r = e.length, n = 128, i = 0, o = 72;
      for (let u2 of e)
        u2 < 128 && t.push(cr(u2));
      let a2 = t.length, s2 = a2;
      for (a2 && t.push(pi);s2 < r; ) {
        let u2 = 2147483647;
        for (let h2 of e)
          h2 >= n && h2 < u2 && (u2 = h2);
        let l2 = s2 + 1;
        u2 - n > K((2147483647 - i) / l2) && oe("overflow"), i += (u2 - n) * l2, n = u2;
        for (let h2 of e)
          if (h2 < n && ++i > 2147483647 && oe("overflow"), h2 === n) {
            let c2 = i;
            for (let d2 = 36;; d2 += 36) {
              let p2 = d2 <= o ? 1 : d2 >= o + 26 ? 26 : d2 - o;
              if (c2 < p2)
                break;
              let g2 = c2 - p2, E2 = 36 - p2;
              t.push(cr(di(p2 + g2 % E2, 0))), c2 = K(g2 / E2);
            }
            t.push(cr(di(c2, 0))), o = wi(i, l2, s2 === a2), i = 0, ++s2;
          }
        ++i, ++n;
      }
      return t.join("");
    }, mi = function(e) {
      return yi(e, function(t) {
        return js.test(t) ? pr(t.slice(4).toLowerCase()) : t;
      });
    }, bi = function(e) {
      return yi(e, function(t) {
        return Hs.test(t) ? "xn--" + yr(t) : t;
      });
    }, Vs = { version: "2.1.0", ucs2: { decode: dr, encode: gi }, decode: pr, encode: yr, toASCII: bi, toUnicode: mi }, Ys = Vs;
  });
  xi = b2((Qf, Ei) => {
    Ei.exports = { isString: function(e) {
      return typeof e == "string";
    }, isObject: function(e) {
      return typeof e == "object" && e !== null;
    }, isNull: function(e) {
      return e === null;
    }, isNullOrUndefined: function(e) {
      return e == null;
    } };
  });
  Si = b2((eu, Ri) => {
    var Xs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, zs = Object.keys || function() {
      var e = Object.prototype.hasOwnProperty, t = !{ toString: null }.propertyIsEnumerable("toString"), r = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], n = r.length;
      return function(i) {
        if (typeof i != "function" && ((typeof i > "u" ? "undefined" : Xs(i)) !== "object" || i === null))
          throw new TypeError("Object.keys called on non-object");
        var o = [], a2, s2;
        for (a2 in i)
          e.call(i, a2) && o.push(a2);
        if (t)
          for (s2 = 0;s2 < n; s2++)
            e.call(i, r[s2]) && o.push(r[s2]);
        return o;
      };
    }();
    Ri.exports = zs;
  });
  Ni = b2((tu, Fi) => {
    var Li = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, lt = Fi.exports = { unescapeBuffer: ef, unescape: Oi, escape: rf, stringify: Bi, encode: Bi, parse: Ii, decode: Ii }, Zs = _e().Buffer, Js = Si(), Qs = function(t) {
      return Object.prototype.toString.call(t) === "[object Array]";
    }, Ti = function(t, r, n) {
      var i;
      if (t == null)
        throw new TypeError('"arr" is null or not defined');
      var o = Object(t), a2 = o.length >>> 0;
      if (a2 === 0)
        return -1;
      var s2 = n | 0;
      if (s2 >= a2)
        return -1;
      for (i = Math.max(s2 >= 0 ? s2 : a2 - Math.abs(s2), 0);i < a2; ) {
        if (i in o && o[i] === r)
          return i;
        i++;
      }
      return -1;
    };
    function Mi() {
    }
    Mi.prototype = Object.create ? Object.create(null) : {};
    var Ai = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    function ef(e, t) {
      for (var r = Zs.allocUnsafe(e.length), n = 0, i, o, a2, s2, u2 = 0, l2 = 0;; u2++) {
        if (u2 < e.length)
          s2 = e.charCodeAt(u2);
        else {
          n > 0 && (r[l2++] = 37, n === 2 && (r[l2++] = a2));
          break;
        }
        switch (n) {
          case 0:
            switch (s2) {
              case 37:
                i = 0, o = 0, n = 1;
                break;
              case 43:
                t && (s2 = 32);
              default:
                r[l2++] = s2;
                break;
            }
            break;
          case 1:
            if (a2 = s2, i = Ai[s2], !(i >= 0)) {
              r[l2++] = 37, r[l2++] = s2, n = 0;
              break;
            }
            n = 2;
            break;
          case 2:
            if (n = 0, o = Ai[s2], !(o >= 0)) {
              r[l2++] = 37, r[l2++] = a2, r[l2++] = s2;
              break;
            }
            r[l2++] = 16 * i + o;
            break;
        }
      }
      return r.slice(0, l2);
    }
    function Oi(e, t) {
      try {
        return decodeURIComponent(e);
      } catch {
        return lt.unescapeBuffer(e, t).toString();
      }
    }
    var k2 = [];
    for (Se = 0;Se < 256; ++Se)
      k2[Se] = "%" + ((Se < 16 ? "0" : "") + Se.toString(16)).toUpperCase();
    var Se, tf = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0];
    function rf(e) {
      typeof e != "string" && ((typeof e > "u" ? "undefined" : Li(e)) === "object" ? e = String(e) : e += "");
      for (var t = "", r = 0, n = 0;n < e.length; ++n) {
        var i = e.charCodeAt(n);
        if (i < 128) {
          if (tf[i] === 1)
            continue;
          r < n && (t += e.slice(r, n)), r = n + 1, t += k2[i];
          continue;
        }
        if (r < n && (t += e.slice(r, n)), i < 2048) {
          r = n + 1, t += k2[192 | i >> 6] + k2[128 | i & 63];
          continue;
        }
        if (i < 55296 || i >= 57344) {
          r = n + 1, t += k2[224 | i >> 12] + k2[128 | i >> 6 & 63] + k2[128 | i & 63];
          continue;
        }
        ++n;
        var o;
        if (n < e.length)
          o = e.charCodeAt(n) & 1023;
        else
          throw new URIError("URI malformed");
        r = n + 1, i = 65536 + ((i & 1023) << 10 | o), t += k2[240 | i >> 18] + k2[128 | i >> 12 & 63] + k2[128 | i >> 6 & 63] + k2[128 | i & 63];
      }
      return r === 0 ? e : r < e.length ? t + e.slice(r) : t;
    }
    function gr(e) {
      return typeof e == "string" ? e : typeof e == "number" && isFinite(e) ? "" + e : typeof e == "boolean" ? e ? "true" : "false" : "";
    }
    function Bi(e, t, r, n) {
      t = t || "&", r = r || "=";
      var i = lt.escape;
      if (n && typeof n.encodeURIComponent == "function" && (i = n.encodeURIComponent), e !== null && (typeof e > "u" ? "undefined" : Li(e)) === "object") {
        for (var o = Js(e), a2 = o.length, s2 = a2 - 1, u2 = "", l2 = 0;l2 < a2; ++l2) {
          var h2 = o[l2], c2 = e[h2], d2 = i(gr(h2)) + r;
          if (Qs(c2)) {
            for (var p2 = c2.length, g2 = p2 - 1, E2 = 0;E2 < p2; ++E2)
              u2 += d2 + i(gr(c2[E2])), E2 < g2 && (u2 += t);
            p2 && l2 < s2 && (u2 += t);
          } else
            u2 += d2 + i(gr(c2)), l2 < s2 && (u2 += t);
        }
        return u2;
      }
      return "";
    }
    function Ci(e) {
      if (e.length === 0)
        return [];
      if (e.length === 1)
        return [e.charCodeAt(0)];
      for (var t = [], r = 0;r < e.length; ++r)
        t[t.length] = e.charCodeAt(r);
      return t;
    }
    var nf = [38], of = [61];
    function Ii(e, t, r, n) {
      var i = new Mi;
      if (typeof e != "string" || e.length === 0)
        return i;
      var o = t ? Ci(t + "") : nf, a2 = r ? Ci(r + "") : of, s2 = o.length, u2 = a2.length, l2 = 1000;
      n && typeof n.maxKeys == "number" && (l2 = n.maxKeys > 0 ? n.maxKeys : -1);
      var h2 = lt.unescape;
      n && typeof n.decodeURIComponent == "function" && (h2 = n.decodeURIComponent);
      for (var c2 = h2 !== Oi, d2 = [], p2 = 0, g2 = 0, E2 = 0, v = 0, m2 = "", y2 = "", R = c2, I2 = c2, T = 0, S = 0;S < e.length; ++S) {
        var B2 = e.charCodeAt(S);
        if (B2 === o[E2]) {
          if (++E2 === s2) {
            var F = S - E2 + 1;
            if (v < u2 ? g2 < F && (m2 += e.slice(g2, F)) : g2 < F && (y2 += e.slice(g2, F)), R && (m2 = ut(m2, h2)), I2 && (y2 = ut(y2, h2)), m2 || y2 || g2 - p2 > s2 || S === 0)
              if (Ti(d2, m2) === -1)
                i[m2] = y2, d2[d2.length] = m2;
              else {
                var L2 = i[m2] || "";
                L2.pop ? L2[L2.length] = y2 : L2 && (i[m2] = [L2, y2]);
              }
            else
              S === 1 && delete i[m2];
            if (--l2 === 0)
              break;
            R = I2 = c2, T = 0, m2 = y2 = "", p2 = g2, g2 = S + 1, E2 = v = 0;
          }
          continue;
        } else
          E2 = 0, I2 || (B2 === 37 ? T = 1 : T > 0 && (B2 >= 48 && B2 <= 57 || B2 >= 65 && B2 <= 70 || B2 >= 97 && B2 <= 102) ? ++T === 3 && (I2 = true) : T = 0);
        if (v < u2)
          if (B2 === a2[v]) {
            if (++v === u2) {
              var Y = S - v + 1;
              g2 < Y && (m2 += e.slice(g2, Y)), T = 0, g2 = S + 1;
            }
            continue;
          } else
            v = 0, R || (B2 === 37 ? T = 1 : T > 0 && (B2 >= 48 && B2 <= 57 || B2 >= 65 && B2 <= 70 || B2 >= 97 && B2 <= 102) ? ++T === 3 && (R = true) : T = 0);
        B2 === 43 && (v < u2 ? (g2 < S && (m2 += e.slice(g2, S)), m2 += "%20", R = true) : (g2 < S && (y2 += e.slice(g2, S)), y2 += "%20", I2 = true), g2 = S + 1);
      }
      if (l2 !== 0 && (g2 < e.length || v > 0))
        if (g2 < e.length && (v < u2 ? m2 += e.slice(g2) : E2 < s2 && (y2 += e.slice(g2))), R && (m2 = ut(m2, h2)), I2 && (y2 = ut(y2, h2)), Ti(d2, m2) === -1)
          i[m2] = y2, d2[d2.length] = m2;
        else {
          var Z = i[m2];
          Z.pop ? Z[Z.length] = y2 : i[m2] = [Z, y2];
        }
      return i;
    }
    function ut(e, t) {
      try {
        return t(e);
      } catch {
        return lt.unescape(e, true);
      }
    }
  });
  Di = b2((Ae) => {
    var af = (vi(), dt(_i)), V2 = xi();
    Ae.parse = qe;
    Ae.resolve = gf;
    Ae.resolveObject = wf;
    Ae.format = yf;
    Ae.Url = D;
    function D() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var sf = /^([a-z0-9.+-]+:)/i, ff = /:[0-9]*$/, uf = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, lf = ["<", ">", '"', "`", " ", "\r", `
`, "	"], hf = ["{", "}", "|", "\\", "^", "`"].concat(lf), wr = ["'"].concat(hf), Ui = ["%", "/", "?", ";", "#"].concat(wr), Pi = ["/", "?", "#"], cf = 255, qi = /^[+a-z0-9A-Z_-]{0,63}$/, df = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, pf = { javascript: true, "javascript:": true }, mr = { javascript: true, "javascript:": true }, Te = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, br = Ni();
    function qe(e, t, r) {
      if (e && V2.isObject(e) && e instanceof D)
        return e;
      var n = new D;
      return n.parse(e, t, r), n;
    }
    D.prototype.parse = function(e, t, r) {
      if (!V2.isString(e))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
      var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", o = e.split(i), a2 = /\\/g;
      o[0] = o[0].replace(a2, "/"), e = o.join(i);
      var s2 = e;
      if (s2 = s2.trim(), !r && e.split("#").length === 1) {
        var u2 = uf.exec(s2);
        if (u2)
          return this.path = s2, this.href = s2, this.pathname = u2[1], u2[2] ? (this.search = u2[2], t ? this.query = br.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
      }
      var l2 = sf.exec(s2);
      if (l2) {
        l2 = l2[0];
        var h2 = l2.toLowerCase();
        this.protocol = h2, s2 = s2.substr(l2.length);
      }
      if (r || l2 || s2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var c2 = s2.substr(0, 2) === "//";
        c2 && !(l2 && mr[l2]) && (s2 = s2.substr(2), this.slashes = true);
      }
      if (!mr[l2] && (c2 || l2 && !Te[l2])) {
        for (var d2 = -1, p2 = 0;p2 < Pi.length; p2++) {
          var g2 = s2.indexOf(Pi[p2]);
          g2 !== -1 && (d2 === -1 || g2 < d2) && (d2 = g2);
        }
        var E2, v;
        d2 === -1 ? v = s2.lastIndexOf("@") : v = s2.lastIndexOf("@", d2), v !== -1 && (E2 = s2.slice(0, v), s2 = s2.slice(v + 1), this.auth = decodeURIComponent(E2)), d2 = -1;
        for (var p2 = 0;p2 < Ui.length; p2++) {
          var g2 = s2.indexOf(Ui[p2]);
          g2 !== -1 && (d2 === -1 || g2 < d2) && (d2 = g2);
        }
        d2 === -1 && (d2 = s2.length), this.host = s2.slice(0, d2), s2 = s2.slice(d2), this.parseHost(), this.hostname = this.hostname || "";
        var m2 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!m2)
          for (var y2 = this.hostname.split(/\./), p2 = 0, R = y2.length;p2 < R; p2++) {
            var I2 = y2[p2];
            if (!!I2 && !I2.match(qi)) {
              for (var T = "", S = 0, B2 = I2.length;S < B2; S++)
                I2.charCodeAt(S) > 127 ? T += "x" : T += I2[S];
              if (!T.match(qi)) {
                var F = y2.slice(0, p2), L2 = y2.slice(p2 + 1), Y = I2.match(df);
                Y && (F.push(Y[1]), L2.unshift(Y[2])), L2.length && (s2 = "/" + L2.join(".") + s2), this.hostname = F.join(".");
                break;
              }
            }
          }
        this.hostname.length > cf ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m2 || (this.hostname = af.toASCII(this.hostname));
        var Z = this.port ? ":" + this.port : "", Wi = this.hostname || "";
        this.host = Wi + Z, this.href += this.host, m2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s2[0] !== "/" && (s2 = "/" + s2));
      }
      if (!pf[h2])
        for (var p2 = 0, R = wr.length;p2 < R; p2++) {
          var Be = wr[p2];
          if (s2.indexOf(Be) !== -1) {
            var ht = encodeURIComponent(Be);
            ht === Be && (ht = escape(Be)), s2 = s2.split(Be).join(ht);
          }
        }
      var ct = s2.indexOf("#");
      ct !== -1 && (this.hash = s2.substr(ct), s2 = s2.slice(0, ct));
      var De = s2.indexOf("?");
      if (De !== -1 ? (this.search = s2.substr(De), this.query = s2.substr(De + 1), t && (this.query = br.parse(this.query)), s2 = s2.slice(0, De)) : t && (this.search = "", this.query = {}), s2 && (this.pathname = s2), Te[h2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var Z = this.pathname || "", $i = this.search || "";
        this.path = Z + $i;
      }
      return this.href = this.format(), this;
    };
    function yf(e) {
      return V2.isString(e) && (e = qe(e)), e instanceof D ? e.format() : D.prototype.format.call(e);
    }
    D.prototype.format = function() {
      var e = this.auth || "";
      e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
      var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = false, o = "";
      this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && V2.isObject(this.query) && Object.keys(this.query).length && (o = br.stringify(this.query));
      var a2 = this.search || o && "?" + o || "";
      return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Te[t]) && i !== false ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a2 && a2.charAt(0) !== "?" && (a2 = "?" + a2), r = r.replace(/[?#]/g, function(s2) {
        return encodeURIComponent(s2);
      }), a2 = a2.replace("#", "%23"), t + i + r + a2 + n;
    };
    function gf(e, t) {
      return qe(e, false, true).resolve(t);
    }
    D.prototype.resolve = function(e) {
      return this.resolveObject(qe(e, false, true)).format();
    };
    function wf(e, t) {
      return e ? qe(e, false, true).resolveObject(t) : t;
    }
    D.prototype.resolveObject = function(e) {
      if (V2.isString(e)) {
        var t = new D;
        t.parse(e, false, true), e = t;
      }
      for (var r = new D, n = Object.keys(this), i = 0;i < n.length; i++) {
        var o = n[i];
        r[o] = this[o];
      }
      if (r.hash = e.hash, e.href === "")
        return r.href = r.format(), r;
      if (e.slashes && !e.protocol) {
        for (var a2 = Object.keys(e), s2 = 0;s2 < a2.length; s2++) {
          var u2 = a2[s2];
          u2 !== "protocol" && (r[u2] = e[u2]);
        }
        return Te[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
      }
      if (e.protocol && e.protocol !== r.protocol) {
        if (!Te[e.protocol]) {
          for (var l2 = Object.keys(e), h2 = 0;h2 < l2.length; h2++) {
            var c2 = l2[h2];
            r[c2] = e[c2];
          }
          return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !mr[e.protocol]) {
          for (var R = (e.pathname || "").split("/");R.length && !(e.host = R.shift()); )
            ;
          e.host || (e.host = ""), e.hostname || (e.hostname = ""), R[0] !== "" && R.unshift(""), R.length < 2 && R.unshift(""), r.pathname = R.join("/");
        } else
          r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
          var d2 = r.pathname || "", p2 = r.search || "";
          r.path = d2 + p2;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
      }
      var g2 = r.pathname && r.pathname.charAt(0) === "/", E2 = e.host || e.pathname && e.pathname.charAt(0) === "/", v = E2 || g2 || r.host && e.pathname, m2 = v, y2 = r.pathname && r.pathname.split("/") || [], R = e.pathname && e.pathname.split("/") || [], I2 = r.protocol && !Te[r.protocol];
      if (I2 && (r.hostname = "", r.port = null, r.host && (y2[0] === "" ? y2[0] = r.host : y2.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (R[0] === "" ? R[0] = e.host : R.unshift(e.host)), e.host = null), v = v && (R[0] === "" || y2[0] === "")), E2)
        r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, y2 = R;
      else if (R.length)
        y2 || (y2 = []), y2.pop(), y2 = y2.concat(R), r.search = e.search, r.query = e.query;
      else if (!V2.isNullOrUndefined(e.search)) {
        if (I2) {
          r.hostname = r.host = y2.shift();
          var T = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
          T && (r.auth = T.shift(), r.host = r.hostname = T.shift());
        }
        return r.search = e.search, r.query = e.query, (!V2.isNull(r.pathname) || !V2.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
      }
      if (!y2.length)
        return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
      for (var S = y2.slice(-1)[0], B2 = (r.host || e.host || y2.length > 1) && (S === "." || S === "..") || S === "", F = 0, L2 = y2.length;L2 >= 0; L2--)
        S = y2[L2], S === "." ? y2.splice(L2, 1) : S === ".." ? (y2.splice(L2, 1), F++) : F && (y2.splice(L2, 1), F--);
      if (!v && !m2)
        for (;F--; F)
          y2.unshift("..");
      v && y2[0] !== "" && (!y2[0] || y2[0].charAt(0) !== "/") && y2.unshift(""), B2 && y2.join("/").substr(-1) !== "/" && y2.push("");
      var Y = y2[0] === "" || y2[0] && y2[0].charAt(0) === "/";
      if (I2) {
        r.hostname = r.host = Y ? "" : y2.length ? y2.shift() : "";
        var T = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
        T && (r.auth = T.shift(), r.host = r.hostname = T.shift());
      }
      return v = v || r.host && y2.length, v && !Y && y2.unshift(""), y2.length ? r.pathname = y2.join("/") : (r.pathname = null, r.path = null), (!V2.isNull(r.pathname) || !V2.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    };
    D.prototype.parseHost = function() {
      var e = this.host, t = ff.exec(e);
      t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
    };
  });
  Hi = b2((ji) => {
    var ki = fi(), mf = ur(), bf = li(), _f = ci(), vf = Di(), j2 = ji;
    j2.request = function(e, t) {
      typeof e == "string" ? e = vf.parse(e) : e = bf(e);
      var r = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", n = e.protocol || r, i = e.hostname || e.host, o = e.port, a2 = e.path || "/";
      i && i.indexOf(":") !== -1 && (i = "[" + i + "]"), e.url = (i ? n + "//" + i : "") + (o ? ":" + o : "") + a2, e.method = (e.method || "GET").toUpperCase(), e.headers = e.headers || {};
      var s2 = new ki(e);
      return t && s2.on("response", t), s2;
    };
    j2.get = function(t, r) {
      var n = j2.request(t, r);
      return n.end(), n;
    };
    j2.ClientRequest = ki;
    j2.IncomingMessage = mf.IncomingMessage;
    j2.Agent = function() {
    };
    j2.Agent.defaultMaxSockets = 4;
    j2.globalAgent = new j2.Agent;
    j2.STATUS_CODES = _f;
    j2.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  });
  _r = Rr(Hi());
  iu = _r.default;
  ({ request: ou, get: au, ClientRequest: su, IncomingMessage: fu, Agent: uu, globalAgent: lu, STATUS_CODES: hu, METHODS: cu } = _r.default);
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node:https
var exports_https = {};
__export(exports_https, {
  default: () => {
    {
      return Cf;
    }
  }
});
var oe2, Js, vi2, _r2, Ji, He, Qi, eo, to, ro, Cr, b3, mt, We, $e, bt2, _t2, xt, Q2, Tt, At, $r, Gr, _e2, qt, cn, jt, fe2, Wt, _n, Kt2, ue2, Ln, Fn, Qt, nt, er, it, Dn, jn, Xt, hr2, ri, si, dr2, gr, pi2, gi2, mi2, Ti, _i2, Ys2, Xs, zs, Zs, mr, K2, br, Ei, Qs, bi2, xi2, vr2, Er2, Ri, Si2, ef, tf, Ai, Ii, Li, ji, Ar, Vi2, Ir, ke2, Cf;
var init_https = __esm(() => {
  oe2 = function(e) {
    throw new RangeError(Zs[e]);
  };
  Js = function(e, t) {
    let r = [], n = e.length;
    for (;n--; )
      r[n] = t(e[n]);
    return r;
  };
  vi2 = function(e, t) {
    let r = e.split("@"), n = "";
    r.length > 1 && (n = r[0] + "@", e = r[1]), e = e.replace(zs, ".");
    let i = e.split("."), o = Js(i, t).join(".");
    return n + o;
  };
  _r2 = function(e) {
    let t = [], r = 0, n = e.length;
    for (;r < n; ) {
      let i = e.charCodeAt(r++);
      if (i >= 55296 && i <= 56319 && r < n) {
        let o = e.charCodeAt(r++);
        (o & 64512) == 56320 ? t.push(((i & 1023) << 10) + (o & 1023) + 65536) : (t.push(i), r--);
      } else
        t.push(i);
    }
    return t;
  };
  Ji = Object.create;
  He = Object.defineProperty;
  Qi = Object.getOwnPropertyDescriptor;
  eo = Object.getOwnPropertyNames;
  to = Object.getPrototypeOf;
  ro = Object.prototype.hasOwnProperty;
  Cr = (e, t) => () => (e && (t = e(e = 0)), t);
  b3 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
  mt = (e, t) => {
    for (var r in t)
      He(e, r, { get: t[r], enumerable: true });
  };
  We = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let i of eo(t))
        !ro.call(e, i) && i !== r && He(e, i, { get: () => t[i], enumerable: !(n = Qi(t, i)) || n.enumerable });
    return e;
  };
  $e = (e, t, r) => (We(e, t, "default"), r && We(r, t, "default"));
  bt2 = (e, t, r) => (r = e != null ? Ji(to(e)) : {}, We(t || !e || !e.__esModule ? He(r, "default", { value: e, enumerable: true }) : r, e));
  _t2 = (e) => We(He({}, "__esModule", { value: true }), e);
  xt = b3((N2) => {
    N2.fetch = Ie(global.fetch) && Ie(global.ReadableStream);
    N2.writableStream = Ie(global.WritableStream);
    N2.abortController = Ie(global.AbortController);
    var J;
    function vt() {
      if (J !== undefined)
        return J;
      if (global.XMLHttpRequest) {
        J = new global.XMLHttpRequest;
        try {
          J.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch {
          J = null;
        }
      } else
        J = null;
      return J;
    }
    function Et(e) {
      var t = vt();
      if (!t)
        return false;
      try {
        return t.responseType = e, t.responseType === e;
      } catch {
      }
      return false;
    }
    N2.arraybuffer = N2.fetch || Et("arraybuffer");
    N2.msstream = !N2.fetch && Et("ms-stream");
    N2.mozchunkedarraybuffer = !N2.fetch && Et("moz-chunked-arraybuffer");
    N2.overrideMimeType = N2.fetch || (vt() ? Ie(vt().overrideMimeType) : false);
    function Ie(e) {
      return typeof e == "function";
    }
    J = null;
  });
  Q2 = b3((Of, Rt) => {
    typeof Object.create == "function" ? Rt.exports = function(t, r) {
      r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
    } : Rt.exports = function(t, r) {
      if (r) {
        t.super_ = r;
        var n = function() {
        };
        n.prototype = r.prototype, t.prototype = new n, t.prototype.constructor = t;
      }
    };
  });
  Tt = b3((Ff, St) => {
    var ye = typeof Reflect == "object" ? Reflect : null, Lr = ye && typeof ye.apply == "function" ? ye.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, Ge;
    ye && typeof ye.ownKeys == "function" ? Ge = ye.ownKeys : Object.getOwnPropertySymbols ? Ge = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : Ge = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function no(e) {
      console && console.warn && console.warn(e);
    }
    var Or = Number.isNaN || function(t) {
      return t !== t;
    };
    function x2() {
      x2.init.call(this);
    }
    St.exports = x2;
    St.exports.once = so;
    x2.EventEmitter = x2;
    x2.prototype._events = undefined;
    x2.prototype._eventsCount = 0;
    x2.prototype._maxListeners = undefined;
    var Mr = 10;
    function Ke(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(x2, "defaultMaxListeners", { enumerable: true, get: function() {
      return Mr;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || Or(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      Mr = e;
    } });
    x2.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    x2.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || Or(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Fr(e) {
      return e._maxListeners === undefined ? x2.defaultMaxListeners : e._maxListeners;
    }
    x2.prototype.getMaxListeners = function() {
      return Fr(this);
    };
    x2.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o = this._events;
      if (o !== undefined)
        i = i && o.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var a2;
        if (r.length > 0 && (a2 = r[0]), a2 instanceof Error)
          throw a2;
        var s2 = new Error("Unhandled error." + (a2 ? " (" + a2.message + ")" : ""));
        throw s2.context = a2, s2;
      }
      var u2 = o[t];
      if (u2 === undefined)
        return false;
      if (typeof u2 == "function")
        Lr(u2, this, r);
      else
        for (var l2 = u2.length, h2 = Dr2(u2, l2), n = 0;n < l2; ++n)
          Lr(h2[n], this, r);
      return true;
    };
    function Nr(e, t, r, n) {
      var i, o, a2;
      if (Ke(r), o = e._events, o === undefined ? (o = e._events = Object.create(null), e._eventsCount = 0) : (o.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o = e._events), a2 = o[t]), a2 === undefined)
        a2 = o[t] = r, ++e._eventsCount;
      else if (typeof a2 == "function" ? a2 = o[t] = n ? [r, a2] : [a2, r] : n ? a2.unshift(r) : a2.push(r), i = Fr(e), i > 0 && a2.length > i && !a2.warned) {
        a2.warned = true;
        var s2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        s2.name = "MaxListenersExceededWarning", s2.emitter = e, s2.type = t, s2.count = a2.length, no(s2);
      }
      return e;
    }
    x2.prototype.addListener = function(t, r) {
      return Nr(this, t, r, false);
    };
    x2.prototype.on = x2.prototype.addListener;
    x2.prototype.prependListener = function(t, r) {
      return Nr(this, t, r, true);
    };
    function io() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ur(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = io.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    x2.prototype.once = function(t, r) {
      return Ke(r), this.on(t, Ur(this, t, r)), this;
    };
    x2.prototype.prependOnceListener = function(t, r) {
      return Ke(r), this.prependListener(t, Ur(this, t, r)), this;
    };
    x2.prototype.removeListener = function(t, r) {
      var n, i, o, a2, s2;
      if (Ke(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o = -1, a2 = n.length - 1;a2 >= 0; a2--)
          if (n[a2] === r || n[a2].listener === r) {
            s2 = n[a2].listener, o = a2;
            break;
          }
        if (o < 0)
          return this;
        o === 0 ? n.shift() : oo(n, o), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, s2 || r);
      }
      return this;
    };
    x2.prototype.off = x2.prototype.removeListener;
    x2.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o = Object.keys(n), a2;
        for (i = 0;i < o.length; ++i)
          a2 = o[i], a2 !== "removeListener" && this.removeAllListeners(a2);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Pr(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? ao(i) : Dr2(i, i.length);
    }
    x2.prototype.listeners = function(t) {
      return Pr(this, t, true);
    };
    x2.prototype.rawListeners = function(t) {
      return Pr(this, t, false);
    };
    x2.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : qr2.call(e, t);
    };
    x2.prototype.listenerCount = qr2;
    function qr2(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    x2.prototype.eventNames = function() {
      return this._eventsCount > 0 ? Ge(this._events) : [];
    };
    function Dr2(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function oo(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function ao(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function so(e, t) {
      return new Promise(function(r, n) {
        function i(a2) {
          e.removeListener(t, o), n(a2);
        }
        function o() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        kr(e, t, o, { once: true }), t !== "error" && fo(e, i, { once: true });
      });
    }
    function fo(e, t, r) {
      typeof e.on == "function" && kr(e, "error", t, r);
    }
    function kr(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o) {
          n.once && e.removeEventListener(t, i), r(o);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  At = b3((Nf, jr) => {
    jr.exports = Tt().EventEmitter;
  });
  $r = b3((Ve) => {
    Ve.byteLength = lo;
    Ve.toByteArray = co;
    Ve.fromByteArray = go;
    var W = [], U2 = [], uo = typeof Uint8Array < "u" ? Uint8Array : Array, Bt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ae = 0, Wr = Bt.length;ae < Wr; ++ae)
      W[ae] = Bt[ae], U2[Bt.charCodeAt(ae)] = ae;
    var ae, Wr;
    U2["-".charCodeAt(0)] = 62;
    U2["_".charCodeAt(0)] = 63;
    function Hr(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function lo(e) {
      var t = Hr(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function ho(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function co(e) {
      var t, r = Hr(e), n = r[0], i = r[1], o = new uo(ho(e, n, i)), a2 = 0, s2 = i > 0 ? n - 4 : n, u2;
      for (u2 = 0;u2 < s2; u2 += 4)
        t = U2[e.charCodeAt(u2)] << 18 | U2[e.charCodeAt(u2 + 1)] << 12 | U2[e.charCodeAt(u2 + 2)] << 6 | U2[e.charCodeAt(u2 + 3)], o[a2++] = t >> 16 & 255, o[a2++] = t >> 8 & 255, o[a2++] = t & 255;
      return i === 2 && (t = U2[e.charCodeAt(u2)] << 2 | U2[e.charCodeAt(u2 + 1)] >> 4, o[a2++] = t & 255), i === 1 && (t = U2[e.charCodeAt(u2)] << 10 | U2[e.charCodeAt(u2 + 1)] << 4 | U2[e.charCodeAt(u2 + 2)] >> 2, o[a2++] = t >> 8 & 255, o[a2++] = t & 255), o;
    }
    function po(e) {
      return W[e >> 18 & 63] + W[e >> 12 & 63] + W[e >> 6 & 63] + W[e & 63];
    }
    function yo(e, t, r) {
      for (var n, i = [], o = t;o < r; o += 3)
        n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(po(n));
      return i.join("");
    }
    function go(e) {
      for (var t, r = e.length, n = r % 3, i = [], o = 16383, a2 = 0, s2 = r - n;a2 < s2; a2 += o)
        i.push(yo(e, a2, a2 + o > s2 ? s2 : a2 + o));
      return n === 1 ? (t = e[r - 1], i.push(W[t >> 2] + W[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(W[t >> 10] + W[t >> 4 & 63] + W[t << 2 & 63] + "=")), i.join("");
    }
  });
  Gr = b3((It) => {
    It.read = function(e, t, r, n, i) {
      var o, a2, s2 = i * 8 - n - 1, u2 = (1 << s2) - 1, l2 = u2 >> 1, h2 = -7, c2 = r ? i - 1 : 0, d2 = r ? -1 : 1, p2 = e[t + c2];
      for (c2 += d2, o = p2 & (1 << -h2) - 1, p2 >>= -h2, h2 += s2;h2 > 0; o = o * 256 + e[t + c2], c2 += d2, h2 -= 8)
        ;
      for (a2 = o & (1 << -h2) - 1, o >>= -h2, h2 += n;h2 > 0; a2 = a2 * 256 + e[t + c2], c2 += d2, h2 -= 8)
        ;
      if (o === 0)
        o = 1 - l2;
      else {
        if (o === u2)
          return a2 ? NaN : (p2 ? -1 : 1) * (1 / 0);
        a2 = a2 + Math.pow(2, n), o = o - l2;
      }
      return (p2 ? -1 : 1) * a2 * Math.pow(2, o - n);
    };
    It.write = function(e, t, r, n, i, o) {
      var a2, s2, u2, l2 = o * 8 - i - 1, h2 = (1 << l2) - 1, c2 = h2 >> 1, d2 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p2 = n ? 0 : o - 1, g2 = n ? 1 : -1, E2 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s2 = isNaN(t) ? 1 : 0, a2 = h2) : (a2 = Math.floor(Math.log(t) / Math.LN2), t * (u2 = Math.pow(2, -a2)) < 1 && (a2--, u2 *= 2), a2 + c2 >= 1 ? t += d2 / u2 : t += d2 * Math.pow(2, 1 - c2), t * u2 >= 2 && (a2++, u2 /= 2), a2 + c2 >= h2 ? (s2 = 0, a2 = h2) : a2 + c2 >= 1 ? (s2 = (t * u2 - 1) * Math.pow(2, i), a2 = a2 + c2) : (s2 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), a2 = 0));i >= 8; e[r + p2] = s2 & 255, p2 += g2, s2 /= 256, i -= 8)
        ;
      for (a2 = a2 << i | s2, l2 += i;l2 > 0; e[r + p2] = a2 & 255, p2 += g2, a2 /= 256, l2 -= 8)
        ;
      e[r + p2 - g2] |= E2 * 128;
    };
  });
  _e2 = b3((be) => {
    var Ct = $r(), we = Gr(), Kr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    be.Buffer = f2;
    be.SlowBuffer = Eo;
    be.INSPECT_MAX_BYTES = 50;
    var Ye = 2147483647;
    be.kMaxLength = Ye;
    f2.TYPED_ARRAY_SUPPORT = wo();
    !f2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function wo() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(f2.prototype, "parent", { enumerable: true, get: function() {
      if (!!f2.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(f2.prototype, "offset", { enumerable: true, get: function() {
      if (!!f2.isBuffer(this))
        return this.byteOffset;
    } });
    function X2(e) {
      if (e > Ye)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, f2.prototype), t;
    }
    function f2(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return Ft2(e);
      }
      return zr(e, t, r);
    }
    f2.poolSize = 8192;
    function zr(e, t, r) {
      if (typeof e == "string")
        return bo(e, t);
      if (ArrayBuffer.isView(e))
        return _o(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (H(e, ArrayBuffer) || e && H(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (H(e, SharedArrayBuffer) || e && H(e.buffer, SharedArrayBuffer)))
        return Mt(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return f2.from(n, t, r);
      let i = vo(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return f2.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    f2.from = function(e, t, r) {
      return zr(e, t, r);
    };
    Object.setPrototypeOf(f2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(f2, Uint8Array);
    function Zr(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function mo(e, t, r) {
      return Zr(e), e <= 0 ? X2(e) : t !== undefined ? typeof r == "string" ? X2(e).fill(t, r) : X2(e).fill(t) : X2(e);
    }
    f2.alloc = function(e, t, r) {
      return mo(e, t, r);
    };
    function Ft2(e) {
      return Zr(e), X2(e < 0 ? 0 : Nt2(e) | 0);
    }
    f2.allocUnsafe = function(e) {
      return Ft2(e);
    };
    f2.allocUnsafeSlow = function(e) {
      return Ft2(e);
    };
    function bo(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !f2.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = Jr(e, t) | 0, n = X2(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Lt2(e) {
      let t = e.length < 0 ? 0 : Nt2(e.length) | 0, r = X2(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function _o(e) {
      if (H(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Mt(t.buffer, t.byteOffset, t.byteLength);
      }
      return Lt2(e);
    }
    function Mt(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, f2.prototype), n;
    }
    function vo(e) {
      if (f2.isBuffer(e)) {
        let t = Nt2(e.length) | 0, r = X2(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || Pt(e.length) ? X2(0) : Lt2(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Lt2(e.data);
    }
    function Nt2(e) {
      if (e >= Ye)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Ye.toString(16) + " bytes");
      return e | 0;
    }
    function Eo(e) {
      return +e != e && (e = 0), f2.alloc(+e);
    }
    f2.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== f2.prototype;
    };
    f2.compare = function(t, r) {
      if (H(t, Uint8Array) && (t = f2.from(t, t.offset, t.byteLength)), H(r, Uint8Array) && (r = f2.from(r, r.offset, r.byteLength)), !f2.isBuffer(t) || !f2.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o = 0, a2 = Math.min(n, i);o < a2; ++o)
        if (t[o] !== r[o]) {
          n = t[o], i = r[o];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    f2.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    f2.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return f2.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = f2.allocUnsafe(r), o = 0;
      for (n = 0;n < t.length; ++n) {
        let a2 = t[n];
        if (H(a2, Uint8Array))
          o + a2.length > i.length ? (f2.isBuffer(a2) || (a2 = f2.from(a2)), a2.copy(i, o)) : Uint8Array.prototype.set.call(i, a2, o);
        else if (f2.isBuffer(a2))
          a2.copy(i, o);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o += a2.length;
      }
      return i;
    };
    function Jr(e, t) {
      if (f2.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || H(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Ot(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return fn(e).length;
          default:
            if (i)
              return n ? -1 : Ot(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    f2.byteLength = Jr;
    function xo(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return Oo(this, t, r);
          case "utf8":
          case "utf-8":
            return en(this, t, r);
          case "ascii":
            return Lo(this, t, r);
          case "latin1":
          case "binary":
            return Mo(this, t, r);
          case "base64":
            return Io(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Fo(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    f2.prototype._isBuffer = true;
    function se(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    f2.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        se(this, r, r + 1);
      return this;
    };
    f2.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        se(this, r, r + 3), se(this, r + 1, r + 2);
      return this;
    };
    f2.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        se(this, r, r + 7), se(this, r + 1, r + 6), se(this, r + 2, r + 5), se(this, r + 3, r + 4);
      return this;
    };
    f2.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? en(this, 0, t) : xo.apply(this, arguments);
    };
    f2.prototype.toLocaleString = f2.prototype.toString;
    f2.prototype.equals = function(t) {
      if (!f2.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : f2.compare(this, t) === 0;
    };
    f2.prototype.inspect = function() {
      let t = "", r = be.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    Kr && (f2.prototype[Kr] = f2.prototype.inspect);
    f2.prototype.compare = function(t, r, n, i, o) {
      if (H(t, Uint8Array) && (t = f2.from(t, t.offset, t.byteLength)), !f2.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o === undefined && (o = this.length), r < 0 || n > t.length || i < 0 || o > this.length)
        throw new RangeError("out of range index");
      if (i >= o && r >= n)
        return 0;
      if (i >= o)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === t)
        return 0;
      let a2 = o - i, s2 = n - r, u2 = Math.min(a2, s2), l2 = this.slice(i, o), h2 = t.slice(r, n);
      for (let c2 = 0;c2 < u2; ++c2)
        if (l2[c2] !== h2[c2]) {
          a2 = l2[c2], s2 = h2[c2];
          break;
        }
      return a2 < s2 ? -1 : s2 < a2 ? 1 : 0;
    };
    function Qr(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Pt(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = f2.from(t, n)), f2.isBuffer(t))
        return t.length === 0 ? -1 : Vr(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : Vr(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Vr(e, t, r, n, i) {
      let o = 1, a2 = e.length, s2 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o = 2, a2 /= 2, s2 /= 2, r /= 2;
      }
      function u2(h2, c2) {
        return o === 1 ? h2[c2] : h2.readUInt16BE(c2 * o);
      }
      let l2;
      if (i) {
        let h2 = -1;
        for (l2 = r;l2 < a2; l2++)
          if (u2(e, l2) === u2(t, h2 === -1 ? 0 : l2 - h2)) {
            if (h2 === -1 && (h2 = l2), l2 - h2 + 1 === s2)
              return h2 * o;
          } else
            h2 !== -1 && (l2 -= l2 - h2), h2 = -1;
      } else
        for (r + s2 > a2 && (r = a2 - s2), l2 = r;l2 >= 0; l2--) {
          let h2 = true;
          for (let c2 = 0;c2 < s2; c2++)
            if (u2(e, l2 + c2) !== u2(t, c2)) {
              h2 = false;
              break;
            }
          if (h2)
            return l2;
        }
      return -1;
    }
    f2.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    f2.prototype.indexOf = function(t, r, n) {
      return Qr(this, t, r, n, true);
    };
    f2.prototype.lastIndexOf = function(t, r, n) {
      return Qr(this, t, r, n, false);
    };
    function Ro(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o = t.length;
      n > o / 2 && (n = o / 2);
      let a2;
      for (a2 = 0;a2 < n; ++a2) {
        let s2 = parseInt(t.substr(a2 * 2, 2), 16);
        if (Pt(s2))
          return a2;
        e[r + a2] = s2;
      }
      return a2;
    }
    function So(e, t, r, n) {
      return Xe(Ot(t, e.length - r), e, r, n);
    }
    function To(e, t, r, n) {
      return Xe(qo(t), e, r, n);
    }
    function Ao(e, t, r, n) {
      return Xe(fn(t), e, r, n);
    }
    function Bo(e, t, r, n) {
      return Xe(Do(t, e.length - r), e, r, n);
    }
    f2.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o = this.length - r;
      if ((n === undefined || n > o) && (n = o), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let a2 = false;
      for (;; )
        switch (i) {
          case "hex":
            return Ro(this, t, r, n);
          case "utf8":
          case "utf-8":
            return So(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return To(this, t, r, n);
          case "base64":
            return Ao(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Bo(this, t, r, n);
          default:
            if (a2)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), a2 = true;
        }
    };
    f2.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Io(e, t, r) {
      return t === 0 && r === e.length ? Ct.fromByteArray(e) : Ct.fromByteArray(e.slice(t, r));
    }
    function en(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o = e[i], a2 = null, s2 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
        if (i + s2 <= r) {
          let u2, l2, h2, c2;
          switch (s2) {
            case 1:
              o < 128 && (a2 = o);
              break;
            case 2:
              u2 = e[i + 1], (u2 & 192) === 128 && (c2 = (o & 31) << 6 | u2 & 63, c2 > 127 && (a2 = c2));
              break;
            case 3:
              u2 = e[i + 1], l2 = e[i + 2], (u2 & 192) === 128 && (l2 & 192) === 128 && (c2 = (o & 15) << 12 | (u2 & 63) << 6 | l2 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (a2 = c2));
              break;
            case 4:
              u2 = e[i + 1], l2 = e[i + 2], h2 = e[i + 3], (u2 & 192) === 128 && (l2 & 192) === 128 && (h2 & 192) === 128 && (c2 = (o & 15) << 18 | (u2 & 63) << 12 | (l2 & 63) << 6 | h2 & 63, c2 > 65535 && c2 < 1114112 && (a2 = c2));
          }
        }
        a2 === null ? (a2 = 65533, s2 = 1) : a2 > 65535 && (a2 -= 65536, n.push(a2 >>> 10 & 1023 | 55296), a2 = 56320 | a2 & 1023), n.push(a2), i += s2;
      }
      return Co(n);
    }
    var Yr = 4096;
    function Co(e) {
      let t = e.length;
      if (t <= Yr)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += Yr));
      return r;
    }
    function Lo(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function Mo(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function Oo(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o = t;o < r; ++o)
        i += ko[e[o]];
      return i;
    }
    function Fo(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o = 0;o < n.length - 1; o += 2)
        i += String.fromCharCode(n[o] + n[o + 1] * 256);
      return i;
    }
    f2.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, f2.prototype), i;
    };
    function I2(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    f2.prototype.readUintLE = f2.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I2(t, r, this.length);
      let i = this[t], o = 1, a2 = 0;
      for (;++a2 < r && (o *= 256); )
        i += this[t + a2] * o;
      return i;
    };
    f2.prototype.readUintBE = f2.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I2(t, r, this.length);
      let i = this[t + --r], o = 1;
      for (;r > 0 && (o *= 256); )
        i += this[t + --r] * o;
      return i;
    };
    f2.prototype.readUint8 = f2.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || I2(t, 1, this.length), this[t];
    };
    f2.prototype.readUint16LE = f2.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || I2(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    f2.prototype.readUint16BE = f2.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || I2(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    f2.prototype.readUint32LE = f2.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || I2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    f2.prototype.readUint32BE = f2.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || I2(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    f2.prototype.readBigUInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o) << BigInt(32));
    });
    f2.prototype.readBigUInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o);
    });
    f2.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I2(t, r, this.length);
      let i = this[t], o = 1, a2 = 0;
      for (;++a2 < r && (o *= 256); )
        i += this[t + a2] * o;
      return o *= 128, i >= o && (i -= Math.pow(2, 8 * r)), i;
    };
    f2.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I2(t, r, this.length);
      let i = r, o = 1, a2 = this[t + --i];
      for (;i > 0 && (o *= 256); )
        a2 += this[t + --i] * o;
      return o *= 128, a2 >= o && (a2 -= Math.pow(2, 8 * r)), a2;
    };
    f2.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || I2(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    f2.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || I2(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f2.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || I2(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f2.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || I2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    f2.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || I2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    f2.prototype.readBigInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    f2.prototype.readBigInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    f2.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || I2(t, 4, this.length), we.read(this, t, true, 23, 4);
    };
    f2.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || I2(t, 4, this.length), we.read(this, t, false, 23, 4);
    };
    f2.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || I2(t, 8, this.length), we.read(this, t, true, 52, 8);
    };
    f2.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || I2(t, 8, this.length), we.read(this, t, false, 52, 8);
    };
    function O2(e, t, r, n, i, o) {
      if (!f2.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    f2.prototype.writeUintLE = f2.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s2 = Math.pow(2, 8 * n) - 1;
        O2(this, t, r, n, s2, 0);
      }
      let o = 1, a2 = 0;
      for (this[r] = t & 255;++a2 < n && (o *= 256); )
        this[r + a2] = t / o & 255;
      return r + n;
    };
    f2.prototype.writeUintBE = f2.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s2 = Math.pow(2, 8 * n) - 1;
        O2(this, t, r, n, s2, 0);
      }
      let o = n - 1, a2 = 1;
      for (this[r + o] = t & 255;--o >= 0 && (a2 *= 256); )
        this[r + o] = t / a2 & 255;
      return r + n;
    };
    f2.prototype.writeUint8 = f2.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    f2.prototype.writeUint16LE = f2.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f2.prototype.writeUint16BE = f2.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f2.prototype.writeUint32LE = f2.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    f2.prototype.writeUint32BE = f2.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function tn(e, t, r, n, i) {
      sn(t, n, i, e, r, 7);
      let o = Number(t & BigInt(4294967295));
      e[r++] = o, o = o >> 8, e[r++] = o, o = o >> 8, e[r++] = o, o = o >> 8, e[r++] = o;
      let a2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, r;
    }
    function rn(e, t, r, n, i) {
      sn(t, n, i, e, r, 7);
      let o = Number(t & BigInt(4294967295));
      e[r + 7] = o, o = o >> 8, e[r + 6] = o, o = o >> 8, e[r + 5] = o, o = o >> 8, e[r + 4] = o;
      let a2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = a2, a2 = a2 >> 8, e[r + 2] = a2, a2 = a2 >> 8, e[r + 1] = a2, a2 = a2 >> 8, e[r] = a2, r + 8;
    }
    f2.prototype.writeBigUInt64LE = ee(function(t, r = 0) {
      return tn(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f2.prototype.writeBigUInt64BE = ee(function(t, r = 0) {
      return rn(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f2.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u2 = Math.pow(2, 8 * n - 1);
        O2(this, t, r, n, u2 - 1, -u2);
      }
      let o = 0, a2 = 1, s2 = 0;
      for (this[r] = t & 255;++o < n && (a2 *= 256); )
        t < 0 && s2 === 0 && this[r + o - 1] !== 0 && (s2 = 1), this[r + o] = (t / a2 >> 0) - s2 & 255;
      return r + n;
    };
    f2.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u2 = Math.pow(2, 8 * n - 1);
        O2(this, t, r, n, u2 - 1, -u2);
      }
      let o = n - 1, a2 = 1, s2 = 0;
      for (this[r + o] = t & 255;--o >= 0 && (a2 *= 256); )
        t < 0 && s2 === 0 && this[r + o + 1] !== 0 && (s2 = 1), this[r + o] = (t / a2 >> 0) - s2 & 255;
      return r + n;
    };
    f2.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    f2.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f2.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f2.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    f2.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    f2.prototype.writeBigInt64LE = ee(function(t, r = 0) {
      return tn(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    f2.prototype.writeBigInt64BE = ee(function(t, r = 0) {
      return rn(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function nn(e, t, r, n, i, o) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function on(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || nn(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), we.write(e, t, r, n, 23, 4), r + 4;
    }
    f2.prototype.writeFloatLE = function(t, r, n) {
      return on(this, t, r, true, n);
    };
    f2.prototype.writeFloatBE = function(t, r, n) {
      return on(this, t, r, false, n);
    };
    function an2(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || nn(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), we.write(e, t, r, n, 52, 8), r + 8;
    }
    f2.prototype.writeDoubleLE = function(t, r, n) {
      return an2(this, t, r, true, n);
    };
    f2.prototype.writeDoubleBE = function(t, r, n) {
      return an2(this, t, r, false, n);
    };
    f2.prototype.copy = function(t, r, n, i) {
      if (!f2.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o;
    };
    f2.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !f2.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let a2 = t.charCodeAt(0);
          (i === "utf8" && a2 < 128 || i === "latin1") && (t = a2);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o;
      if (typeof t == "number")
        for (o = r;o < n; ++o)
          this[o] = t;
      else {
        let a2 = f2.isBuffer(t) ? t : f2.from(t, i), s2 = a2.length;
        if (s2 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o = 0;o < n - r; ++o)
          this[o + r] = a2[o % s2];
      }
      return this;
    };
    var ge = {};
    function Ut(e, t, r) {
      ge[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    Ut("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    Ut("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    Ut("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = Xr(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = Xr(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function Xr(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function No(e, t, r) {
      me(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ce(t, e.length - (r + 1));
    }
    function sn(e, t, r, n, i, o) {
      if (e > r || e < t) {
        let a2 = typeof t == "bigint" ? "n" : "", s2;
        throw o > 3 ? t === 0 || t === BigInt(0) ? s2 = `>= 0${a2} and < 2${a2} ** ${(o + 1) * 8}${a2}` : s2 = `>= -(2${a2} ** ${(o + 1) * 8 - 1}${a2}) and < 2 ** ${(o + 1) * 8 - 1}${a2}` : s2 = `>= ${t}${a2} and <= ${r}${a2}`, new ge.ERR_OUT_OF_RANGE("value", s2, e);
      }
      No(n, i, o);
    }
    function me(e, t) {
      if (typeof e != "number")
        throw new ge.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ce(e, t, r) {
      throw Math.floor(e) !== e ? (me(e, r), new ge.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new ge.ERR_BUFFER_OUT_OF_BOUNDS : new ge.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var Uo = /[^+/0-9A-Za-z-_]/g;
    function Po(e) {
      if (e = e.split("=")[0], e = e.trim().replace(Uo, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Ot(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o = [];
      for (let a2 = 0;a2 < n; ++a2) {
        if (r = e.charCodeAt(a2), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o.push(239, 191, 189);
              continue;
            } else if (a2 + 1 === n) {
              (t -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o;
    }
    function qo(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Do(e, t) {
      let r, n, i, o = [];
      for (let a2 = 0;a2 < e.length && !((t -= 2) < 0); ++a2)
        r = e.charCodeAt(a2), n = r >> 8, i = r % 256, o.push(i), o.push(n);
      return o;
    }
    function fn(e) {
      return Ct.toByteArray(Po(e));
    }
    function Xe(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function H(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function Pt(e) {
      return e !== e;
    }
    var ko = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function ee(e) {
      return typeof BigInt > "u" ? jo : e;
    }
    function jo() {
      throw new Error("BigInt not supported");
    }
  });
  qt = b3(() => {
  });
  cn = b3((Wf, hn) => {
    function un(e, t) {
      var r = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function Wo(e) {
      for (var t = 1;t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? un(Object(r), true).forEach(function(n) {
          Ho(e, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : un(Object(r)).forEach(function(n) {
          Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return e;
    }
    function Ho(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    function $o(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function ln(e, t) {
      for (var r = 0;r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    function Go(e, t, r) {
      return t && ln(e.prototype, t), r && ln(e, r), e;
    }
    var Ko = _e2(), ze = Ko.Buffer, Vo = qt(), Dt2 = Vo.inspect, Yo = Dt2 && Dt2.custom || "inspect";
    function Xo(e, t, r) {
      ze.prototype.copy.call(e, t, r);
    }
    hn.exports = function() {
      function e() {
        $o(this, e), this.head = null, this.tail = null, this.length = 0;
      }
      return Go(e, [{ key: "push", value: function(r) {
        var n = { data: r, next: null };
        this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var n = { data: r, next: this.head };
        this.length === 0 && (this.tail = n), this.head = n, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var n = this.head, i = "" + n.data;n = n.next; )
          i += r + n.data;
        return i;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ze.alloc(0);
        for (var n = ze.allocUnsafe(r >>> 0), i = this.head, o = 0;i; )
          Xo(i.data, n, o), o += i.data.length, i = i.next;
        return n;
      } }, { key: "consume", value: function(r, n) {
        var i;
        return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var n = this.head, i = 1, o = n.data;
        for (r -= o.length;n = n.next; ) {
          var a2 = n.data, s2 = r > a2.length ? a2.length : r;
          if (s2 === a2.length ? o += a2 : o += a2.slice(0, r), r -= s2, r === 0) {
            s2 === a2.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = a2.slice(s2));
            break;
          }
          ++i;
        }
        return this.length -= i, o;
      } }, { key: "_getBuffer", value: function(r) {
        var n = ze.allocUnsafe(r), i = this.head, o = 1;
        for (i.data.copy(n), r -= i.data.length;i = i.next; ) {
          var a2 = i.data, s2 = r > a2.length ? a2.length : r;
          if (a2.copy(n, n.length - r, 0, s2), r -= s2, r === 0) {
            s2 === a2.length ? (++o, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = a2.slice(s2));
            break;
          }
          ++o;
        }
        return this.length -= o, n;
      } }, { key: Yo, value: function(r, n) {
        return Dt2(this, Wo({}, n, { depth: 0, customInspect: false }));
      } }]), e;
    }();
  });
  jt = b3((Hf, pn2) => {
    function zo(e, t) {
      var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
      return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(kt, this, e)) : process.nextTick(kt, this, e)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e || null, function(o) {
        !t && o ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Ze, r) : (r._writableState.errorEmitted = true, process.nextTick(dn, r, o)) : process.nextTick(dn, r, o) : t ? (process.nextTick(Ze, r), t(o)) : process.nextTick(Ze, r);
      }), this);
    }
    function dn(e, t) {
      kt(e, t), Ze(e);
    }
    function Ze(e) {
      e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function Zo() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function kt(e, t) {
      e.emit("error", t);
    }
    function Jo(e, t) {
      var { _readableState: r, _writableState: n } = e;
      r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    pn2.exports = { destroy: zo, undestroy: Zo, errorOrDestroy: Jo };
  });
  fe2 = b3(($f, wn) => {
    function Qo(e, t) {
      e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var gn = {};
    function P(e, t, r) {
      r || (r = Error);
      function n(o, a2, s2) {
        return typeof t == "string" ? t : t(o, a2, s2);
      }
      var i = function(o) {
        Qo(a2, o);
        function a2(s2, u2, l2) {
          return o.call(this, n(s2, u2, l2)) || this;
        }
        return a2;
      }(r);
      i.prototype.name = r.name, i.prototype.code = e, gn[e] = i;
    }
    function yn(e, t) {
      if (Array.isArray(e)) {
        var r = e.length;
        return e = e.map(function(n) {
          return String(n);
        }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
      } else
        return "of ".concat(t, " ").concat(String(e));
    }
    function ea(e, t, r) {
      return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function ta(e, t, r) {
      return (r === undefined || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function ra(e, t, r) {
      return typeof r != "number" && (r = 0), r + t.length > e.length ? false : e.indexOf(t, r) !== -1;
    }
    P("ERR_INVALID_OPT_VALUE", function(e, t) {
      return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    P("ERR_INVALID_ARG_TYPE", function(e, t, r) {
      var n;
      typeof t == "string" && ea(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
      var i;
      if (ta(e, " argument"))
        i = "The ".concat(e, " ").concat(n, " ").concat(yn(t, "type"));
      else {
        var o = ra(e, ".") ? "property" : "argument";
        i = 'The "'.concat(e, '" ').concat(o, " ").concat(n, " ").concat(yn(t, "type"));
      }
      return i += ". Received type ".concat(typeof r), i;
    }, TypeError);
    P("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    P("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
      return "The " + e + " method is not implemented";
    });
    P("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    P("ERR_STREAM_DESTROYED", function(e) {
      return "Cannot call " + e + " after a stream was destroyed";
    });
    P("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    P("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    P("ERR_STREAM_WRITE_AFTER_END", "write after end");
    P("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    P("ERR_UNKNOWN_ENCODING", function(e) {
      return "Unknown encoding: " + e;
    }, TypeError);
    P("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    wn.exports.codes = gn;
  });
  Wt = b3((Gf, mn) => {
    var na = fe2().codes.ERR_INVALID_OPT_VALUE;
    function ia(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function oa(e, t, r, n) {
      var i = ia(t, n, r);
      if (i != null) {
        if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
          var o = n ? r : "highWaterMark";
          throw new na(o, i);
        }
        return Math.floor(i);
      }
      return e.objectMode ? 16 : 16 * 1024;
    }
    mn.exports = { getHighWaterMark: oa };
  });
  _n = b3((Kf, bn) => {
    bn.exports = aa;
    function aa(e, t) {
      if (Ht2("noDeprecation"))
        return e;
      var r = false;
      function n() {
        if (!r) {
          if (Ht2("throwDeprecation"))
            throw new Error(t);
          Ht2("traceDeprecation") ? console.trace(t) : console.warn(t), r = true;
        }
        return e.apply(this, arguments);
      }
      return n;
    }
    function Ht2(e) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var t = global.localStorage[e];
      return t == null ? false : String(t).toLowerCase() === "true";
    }
  });
  Kt2 = b3((Vf, Tn) => {
    Tn.exports = A2;
    function En(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        Oa(t, e);
      };
    }
    var ve;
    A2.WritableState = Me;
    var sa = { deprecate: _n() }, xn = At(), Qe2 = _e2().Buffer, fa = global.Uint8Array || function() {
    };
    function ua(e) {
      return Qe2.from(e);
    }
    function la(e) {
      return Qe2.isBuffer(e) || e instanceof fa;
    }
    var Gt = jt(), ha = Wt(), ca = ha.getHighWaterMark, te = fe2().codes, da = te.ERR_INVALID_ARG_TYPE, pa = te.ERR_METHOD_NOT_IMPLEMENTED, ya = te.ERR_MULTIPLE_CALLBACK, ga = te.ERR_STREAM_CANNOT_PIPE, wa = te.ERR_STREAM_DESTROYED, ma = te.ERR_STREAM_NULL_VALUES, ba = te.ERR_STREAM_WRITE_AFTER_END, _a = te.ERR_UNKNOWN_ENCODING, Ee = Gt.errorOrDestroy;
    Q2()(A2, xn);
    function va() {
    }
    function Me(e, t, r) {
      ve = ve || ue2(), e = e || {}, typeof r != "boolean" && (r = t instanceof ve), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = ca(this, e, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var n = e.decodeStrings === false;
      this.decodeStrings = !n, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
        Ba(t, i);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new En(this);
    }
    Me.prototype.getBuffer = function() {
      for (var t = this.bufferedRequest, r = [];t; )
        r.push(t), t = t.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Me.prototype, "buffer", { get: sa.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Je;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Je = Function.prototype[Symbol.hasInstance], Object.defineProperty(A2, Symbol.hasInstance, { value: function(t) {
      return Je.call(this, t) ? true : this !== A2 ? false : t && t._writableState instanceof Me;
    } })) : Je = function(t) {
      return t instanceof this;
    };
    function A2(e) {
      ve = ve || ue2();
      var t = this instanceof ve;
      if (!t && !Je.call(A2, this))
        return new A2(e);
      this._writableState = new Me(e, this, t), this.writable = true, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), xn.call(this);
    }
    A2.prototype.pipe = function() {
      Ee(this, new ga);
    };
    function Ea(e, t) {
      var r = new ba;
      Ee(e, r), process.nextTick(t, r);
    }
    function xa(e, t, r, n) {
      var i;
      return r === null ? i = new ma : typeof r != "string" && !t.objectMode && (i = new da("chunk", ["string", "Buffer"], r)), i ? (Ee(e, i), process.nextTick(n, i), false) : true;
    }
    A2.prototype.write = function(e, t, r) {
      var n = this._writableState, i = false, o = !n.objectMode && la(e);
      return o && !Qe2.isBuffer(e) && (e = ua(e)), typeof t == "function" && (r = t, t = null), o ? t = "buffer" : t || (t = n.defaultEncoding), typeof r != "function" && (r = va), n.ending ? Ea(this, r) : (o || xa(this, n, e, r)) && (n.pendingcb++, i = Sa(this, n, o, e, t, r)), i;
    };
    A2.prototype.cork = function() {
      this._writableState.corked++;
    };
    A2.prototype.uncork = function() {
      var e = this._writableState;
      e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Rn(this, e));
    };
    A2.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1))
        throw new _a(t);
      return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(A2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function Ra(e, t, r) {
      return !e.objectMode && e.decodeStrings !== false && typeof t == "string" && (t = Qe2.from(t, r)), t;
    }
    Object.defineProperty(A2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function Sa(e, t, r, n, i, o) {
      if (!r) {
        var a2 = Ra(t, n, i);
        n !== a2 && (r = true, i = "buffer", n = a2);
      }
      var s2 = t.objectMode ? 1 : n.length;
      t.length += s2;
      var u2 = t.length < t.highWaterMark;
      if (u2 || (t.needDrain = true), t.writing || t.corked) {
        var l2 = t.lastBufferedRequest;
        t.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o, next: null }, l2 ? l2.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
      } else
        $t(e, t, false, s2, n, i, o);
      return u2;
    }
    function $t(e, t, r, n, i, o, a2) {
      t.writelen = n, t.writecb = a2, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new wa("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = false;
    }
    function Ta(e, t, r, n, i) {
      --t.pendingcb, r ? (process.nextTick(i, n), process.nextTick(Le, e, t), e._writableState.errorEmitted = true, Ee(e, n)) : (i(n), e._writableState.errorEmitted = true, Ee(e, n), Le(e, t));
    }
    function Aa(e) {
      e.writing = false, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function Ba(e, t) {
      var r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function")
        throw new ya;
      if (Aa(r), t)
        Ta(e, r, n, t, i);
      else {
        var o = Sn2(r) || e.destroyed;
        !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && Rn(e, r), n ? process.nextTick(vn, e, r, o, i) : vn(e, r, o, i);
      }
    }
    function vn(e, t, r, n) {
      r || Ia(e, t), t.pendingcb--, n(), Le(e, t);
    }
    function Ia(e, t) {
      t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));
    }
    function Rn(e, t) {
      t.bufferProcessing = true;
      var r = t.bufferedRequest;
      if (e._writev && r && r.next) {
        var n = t.bufferedRequestCount, i = new Array(n), o = t.corkedRequestsFree;
        o.entry = r;
        for (var a2 = 0, s2 = true;r; )
          i[a2] = r, r.isBuf || (s2 = false), r = r.next, a2 += 1;
        i.allBuffers = s2, $t(e, t, true, t.length, i, "", o.finish), t.pendingcb++, t.lastBufferedRequest = null, o.next ? (t.corkedRequestsFree = o.next, o.next = null) : t.corkedRequestsFree = new En(t), t.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: u2, encoding: l2, callback: h2 } = r, c2 = t.objectMode ? 1 : u2.length;
          if ($t(e, t, false, c2, u2, l2, h2), r = r.next, t.bufferedRequestCount--, t.writing)
            break;
        }
        r === null && (t.lastBufferedRequest = null);
      }
      t.bufferedRequest = r, t.bufferProcessing = false;
    }
    A2.prototype._write = function(e, t, r) {
      r(new pa("_write()"));
    };
    A2.prototype._writev = null;
    A2.prototype.end = function(e, t, r) {
      var n = this._writableState;
      return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || Ma(this, n, r), this;
    };
    Object.defineProperty(A2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Sn2(e) {
      return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function Ca(e, t) {
      e._final(function(r) {
        t.pendingcb--, r && Ee(e, r), t.prefinished = true, e.emit("prefinish"), Le(e, t);
      });
    }
    function La(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = true, process.nextTick(Ca, e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Le(e, t) {
      var r = Sn2(t);
      if (r && (La(e, t), t.pendingcb === 0 && (t.finished = true, e.emit("finish"), t.autoDestroy))) {
        var n = e._readableState;
        (!n || n.autoDestroy && n.endEmitted) && e.destroy();
      }
      return r;
    }
    function Ma(e, t, r) {
      t.ending = true, Le(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = true, e.writable = false;
    }
    function Oa(e, t, r) {
      var n = e.entry;
      for (e.entry = null;n; ) {
        var i = n.callback;
        t.pendingcb--, i(r), n = n.next;
      }
      t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(A2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(t) {
      !this._writableState || (this._writableState.destroyed = t);
    } });
    A2.prototype.destroy = Gt.destroy;
    A2.prototype._undestroy = Gt.undestroy;
    A2.prototype._destroy = function(e, t) {
      t(e);
    };
  });
  ue2 = b3((Yf, Bn2) => {
    var Fa = Object.keys || function(e) {
      var t = [];
      for (var r in e)
        t.push(r);
      return t;
    };
    Bn2.exports = $;
    var An = Xt(), Yt = Kt2();
    Q2()($, An);
    for (Vt2 = Fa(Yt.prototype), et2 = 0;et2 < Vt2.length; et2++)
      tt = Vt2[et2], $.prototype[tt] || ($.prototype[tt] = Yt.prototype[tt]);
    var Vt2, tt, et2;
    function $(e) {
      if (!(this instanceof $))
        return new $(e);
      An.call(this, e), Yt.call(this, e), this.allowHalfOpen = true, e && (e.readable === false && (this.readable = false), e.writable === false && (this.writable = false), e.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Na)));
    }
    Object.defineProperty($.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Na() {
      this._writableState.ended || process.nextTick(Ua, this);
    }
    function Ua(e) {
      e.end();
    }
    Object.defineProperty($.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(t) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } });
  });
  Ln = b3((zt, Cn) => {
    var rt = _e2(), G = rt.Buffer;
    function In(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    G.from && G.alloc && G.allocUnsafe && G.allocUnsafeSlow ? Cn.exports = rt : (In(rt, zt), zt.Buffer = le);
    function le(e, t, r) {
      return G(e, t, r);
    }
    le.prototype = Object.create(G.prototype);
    In(G, le);
    le.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return G(e, t, r);
    };
    le.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = G(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    le.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return G(e);
    };
    le.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return rt.SlowBuffer(e);
    };
  });
  Fn = b3((On2) => {
    var Jt = Ln().Buffer, Mn = Jt.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function Pa(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function qa(e) {
      var t = Pa(e);
      if (typeof t != "string" && (Jt.isEncoding === Mn || !Mn(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    On2.StringDecoder = Oe;
    function Oe(e) {
      this.encoding = qa(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = $a, this.end = Ga, t = 4;
          break;
        case "utf8":
          this.fillLast = ja, t = 4;
          break;
        case "base64":
          this.text = Ka, this.end = Va, t = 3;
          break;
        default:
          this.write = Ya, this.end = Xa;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Jt.allocUnsafe(t);
    }
    Oe.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Oe.prototype.end = Ha;
    Oe.prototype.text = Wa;
    Oe.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function Zt(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Da(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = Zt(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = Zt(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = Zt(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function ka(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "\uFFFD";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "\uFFFD";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "\uFFFD";
      }
    }
    function ja(e) {
      var t = this.lastTotal - this.lastNeed, r = ka(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Wa(e, t) {
      var r = Da(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function Ha(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "\uFFFD" : t;
    }
    function $a(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Ga(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Ka(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Va(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Ya(e) {
      return e.toString(this.encoding);
    }
    function Xa(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Qt = {};
  mt(Qt, { StringDecoder: () => nt.StringDecoder, default: () => nt.StringDecoder });
  er = Cr(() => {
    nt = bt2(Fn());
  });
  it = b3((zf, Pn) => {
    var Nn2 = fe2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function za(e) {
      var t = false;
      return function() {
        if (!t) {
          t = true;
          for (var r = arguments.length, n = new Array(r), i = 0;i < r; i++)
            n[i] = arguments[i];
          e.apply(this, n);
        }
      };
    }
    function Za() {
    }
    function Ja(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Un(e, t, r) {
      if (typeof t == "function")
        return Un(e, null, t);
      t || (t = {}), r = za(r || Za);
      var n = t.readable || t.readable !== false && e.readable, i = t.writable || t.writable !== false && e.writable, o = function() {
        e.writable || s2();
      }, a2 = e._writableState && e._writableState.finished, s2 = function() {
        i = false, a2 = true, n || r.call(e);
      }, u2 = e._readableState && e._readableState.endEmitted, l2 = function() {
        n = false, u2 = true, i || r.call(e);
      }, h2 = function(g2) {
        r.call(e, g2);
      }, c2 = function() {
        var g2;
        if (n && !u2)
          return (!e._readableState || !e._readableState.ended) && (g2 = new Nn2), r.call(e, g2);
        if (i && !a2)
          return (!e._writableState || !e._writableState.ended) && (g2 = new Nn2), r.call(e, g2);
      }, d2 = function() {
        e.req.on("finish", s2);
      };
      return Ja(e) ? (e.on("complete", s2), e.on("abort", c2), e.req ? d2() : e.on("request", d2)) : i && !e._writableState && (e.on("end", o), e.on("close", o)), e.on("end", l2), e.on("finish", s2), t.error !== false && e.on("error", h2), e.on("close", c2), function() {
        e.removeListener("complete", s2), e.removeListener("abort", c2), e.removeListener("request", d2), e.req && e.req.removeListener("finish", s2), e.removeListener("end", o), e.removeListener("close", o), e.removeListener("finish", s2), e.removeListener("end", l2), e.removeListener("error", h2), e.removeListener("close", c2);
      };
    }
    Pn.exports = Un;
  });
  Dn = b3((Zf, qn) => {
    var ot;
    function re(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    var Qa = it(), ne = Symbol("lastResolve"), he = Symbol("lastReject"), Fe = Symbol("error"), at = Symbol("ended"), ce = Symbol("lastPromise"), tr = Symbol("handlePromise"), de = Symbol("stream");
    function ie(e, t) {
      return { value: e, done: t };
    }
    function es(e) {
      var t = e[ne];
      if (t !== null) {
        var r = e[de].read();
        r !== null && (e[ce] = null, e[ne] = null, e[he] = null, t(ie(r, false)));
      }
    }
    function ts(e) {
      process.nextTick(es, e);
    }
    function rs(e, t) {
      return function(r, n) {
        e.then(function() {
          if (t[at]) {
            r(ie(undefined, true));
            return;
          }
          t[tr](r, n);
        }, n);
      };
    }
    var ns = Object.getPrototypeOf(function() {
    }), is = Object.setPrototypeOf((ot = { get stream() {
      return this[de];
    }, next: function() {
      var t = this, r = this[Fe];
      if (r !== null)
        return Promise.reject(r);
      if (this[at])
        return Promise.resolve(ie(undefined, true));
      if (this[de].destroyed)
        return new Promise(function(a2, s2) {
          process.nextTick(function() {
            t[Fe] ? s2(t[Fe]) : a2(ie(undefined, true));
          });
        });
      var n = this[ce], i;
      if (n)
        i = new Promise(rs(n, this));
      else {
        var o = this[de].read();
        if (o !== null)
          return Promise.resolve(ie(o, false));
        i = new Promise(this[tr]);
      }
      return this[ce] = i, i;
    } }, re(ot, Symbol.asyncIterator, function() {
      return this;
    }), re(ot, "return", function() {
      var t = this;
      return new Promise(function(r, n) {
        t[de].destroy(null, function(i) {
          if (i) {
            n(i);
            return;
          }
          r(ie(undefined, true));
        });
      });
    }), ot), ns), os = function(t) {
      var r, n = Object.create(is, (r = {}, re(r, de, { value: t, writable: true }), re(r, ne, { value: null, writable: true }), re(r, he, { value: null, writable: true }), re(r, Fe, { value: null, writable: true }), re(r, at, { value: t._readableState.endEmitted, writable: true }), re(r, tr, { value: function(o, a2) {
        var s2 = n[de].read();
        s2 ? (n[ce] = null, n[ne] = null, n[he] = null, o(ie(s2, false))) : (n[ne] = o, n[he] = a2);
      }, writable: true }), r));
      return n[ce] = null, Qa(t, function(i) {
        if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var o = n[he];
          o !== null && (n[ce] = null, n[ne] = null, n[he] = null, o(i)), n[Fe] = i;
          return;
        }
        var a2 = n[ne];
        a2 !== null && (n[ce] = null, n[ne] = null, n[he] = null, a2(ie(undefined, true))), n[at] = true;
      }), t.on("readable", ts.bind(null, n)), n;
    };
    qn.exports = os;
  });
  jn = b3((Jf, kn) => {
    kn.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  Xt = b3((eu, Zn) => {
    Zn.exports = _2;
    var xe;
    _2.ReadableState = Gn;
    var Qf = Tt().EventEmitter, $n = function(t, r) {
      return t.listeners(r).length;
    }, Ue = At(), st = _e2().Buffer, as = global.Uint8Array || function() {
    };
    function ss(e) {
      return st.from(e);
    }
    function fs(e) {
      return st.isBuffer(e) || e instanceof as;
    }
    var rr = qt(), w;
    rr && rr.debuglog ? w = rr.debuglog("stream") : w = function() {
    };
    var us = cn(), ur2 = jt(), ls = Wt(), hs = ls.getHighWaterMark, ft = fe2().codes, cs = ft.ERR_INVALID_ARG_TYPE, ds = ft.ERR_STREAM_PUSH_AFTER_EOF, ps = ft.ERR_METHOD_NOT_IMPLEMENTED, ys = ft.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Re, nr, ir2;
    Q2()(_2, Ue);
    var Ne = ur2.errorOrDestroy, or = ["error", "close", "destroy", "pause", "resume"];
    function gs(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    function Gn(e, t, r) {
      xe = xe || ue2(), e = e || {}, typeof r != "boolean" && (r = t instanceof xe), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = hs(this, e, "readableHighWaterMark", r), this.buffer = new us, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.destroyed = false, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e.encoding && (Re || (Re = (er(), _t2(Qt)).StringDecoder), this.decoder = new Re(e.encoding), this.encoding = e.encoding);
    }
    function _2(e) {
      if (xe = xe || ue2(), !(this instanceof _2))
        return new _2(e);
      var t = this instanceof xe;
      this._readableState = new Gn(e, this, t), this.readable = true, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), Ue.call(this);
    }
    Object.defineProperty(_2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } });
    _2.prototype.destroy = ur2.destroy;
    _2.prototype._undestroy = ur2.undestroy;
    _2.prototype._destroy = function(e, t) {
      t(e);
    };
    _2.prototype.push = function(e, t) {
      var r = this._readableState, n;
      return r.objectMode ? n = true : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = st.from(e, t), t = ""), n = true), Kn(this, e, t, false, n);
    };
    _2.prototype.unshift = function(e) {
      return Kn(this, e, null, true, false);
    };
    function Kn(e, t, r, n, i) {
      w("readableAddChunk", t);
      var o = e._readableState;
      if (t === null)
        o.reading = false, bs(e, o);
      else {
        var a2;
        if (i || (a2 = ws(o, t)), a2)
          Ne(e, a2);
        else if (o.objectMode || t && t.length > 0)
          if (typeof t != "string" && !o.objectMode && Object.getPrototypeOf(t) !== st.prototype && (t = ss(t)), n)
            o.endEmitted ? Ne(e, new ys) : ar2(e, o, t, true);
          else if (o.ended)
            Ne(e, new ds);
          else {
            if (o.destroyed)
              return false;
            o.reading = false, o.decoder && !r ? (t = o.decoder.write(t), o.objectMode || t.length !== 0 ? ar2(e, o, t, false) : fr(e, o)) : ar2(e, o, t, false);
          }
        else
          n || (o.reading = false, fr(e, o));
      }
      return !o.ended && (o.length < o.highWaterMark || o.length === 0);
    }
    function ar2(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ut(e)), fr(e, t);
    }
    function ws(e, t) {
      var r;
      return !fs(t) && typeof t != "string" && t !== undefined && !e.objectMode && (r = new cs("chunk", ["string", "Buffer", "Uint8Array"], t)), r;
    }
    _2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    _2.prototype.setEncoding = function(e) {
      Re || (Re = (er(), _t2(Qt)).StringDecoder);
      var t = new Re(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, n = "";r !== null; )
        n += t.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
    };
    var Wn = 1073741824;
    function ms(e) {
      return e >= Wn ? e = Wn : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Hn(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = ms(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = true, 0));
    }
    _2.prototype.read = function(e) {
      w("read", e), e = parseInt(e, 10);
      var t = this._readableState, r = e;
      if (e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return w("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? sr(this) : ut(this), null;
      if (e = Hn(e, t), e === 0 && t.ended)
        return t.length === 0 && sr(this), null;
      var n = t.needReadable;
      w("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, w("length less than watermark", n)), t.ended || t.reading ? (n = false, w("reading or ended", n)) : n && (w("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true), this._read(t.highWaterMark), t.sync = false, t.reading || (e = Hn(r, t)));
      var i;
      return e > 0 ? i = Xn(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && sr(this)), i !== null && this.emit("data", i), i;
    };
    function bs(e, t) {
      if (w("onEofChunk"), !t.ended) {
        if (t.decoder) {
          var r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? ut(e) : (t.needReadable = false, t.emittedReadable || (t.emittedReadable = true, Vn(e)));
      }
    }
    function ut(e) {
      var t = e._readableState;
      w("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (w("emitReadable", t.flowing), t.emittedReadable = true, process.nextTick(Vn, e));
    }
    function Vn(e) {
      var t = e._readableState;
      w("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, lr(e);
    }
    function fr(e, t) {
      t.readingMore || (t.readingMore = true, process.nextTick(_s, e, t));
    }
    function _s(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        var r = t.length;
        if (w("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    _2.prototype._read = function(e) {
      Ne(this, new ps("_read()"));
    };
    _2.prototype.pipe = function(e, t) {
      var r = this, n = this._readableState;
      switch (n.pipesCount) {
        case 0:
          n.pipes = e;
          break;
        case 1:
          n.pipes = [n.pipes, e];
          break;
        default:
          n.pipes.push(e);
          break;
      }
      n.pipesCount += 1, w("pipe count=%d opts=%j", n.pipesCount, t);
      var i = (!t || t.end !== false) && e !== process.stdout && e !== process.stderr, o = i ? s2 : E2;
      n.endEmitted ? process.nextTick(o) : r.once("end", o), e.on("unpipe", a2);
      function a2(v, m2) {
        w("onunpipe"), v === r && m2 && m2.hasUnpiped === false && (m2.hasUnpiped = true, h2());
      }
      function s2() {
        w("onend"), e.end();
      }
      var u2 = vs(r);
      e.on("drain", u2);
      var l2 = false;
      function h2() {
        w("cleanup"), e.removeListener("close", p2), e.removeListener("finish", g2), e.removeListener("drain", u2), e.removeListener("error", d2), e.removeListener("unpipe", a2), r.removeListener("end", s2), r.removeListener("end", E2), r.removeListener("data", c2), l2 = true, n.awaitDrain && (!e._writableState || e._writableState.needDrain) && u2();
      }
      r.on("data", c2);
      function c2(v) {
        w("ondata");
        var m2 = e.write(v);
        w("dest.write", m2), m2 === false && ((n.pipesCount === 1 && n.pipes === e || n.pipesCount > 1 && zn2(n.pipes, e) !== -1) && !l2 && (w("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
      }
      function d2(v) {
        w("onerror", v), E2(), e.removeListener("error", d2), $n(e, "error") === 0 && Ne(e, v);
      }
      gs(e, "error", d2);
      function p2() {
        e.removeListener("finish", g2), E2();
      }
      e.once("close", p2);
      function g2() {
        w("onfinish"), e.removeListener("close", p2), E2();
      }
      e.once("finish", g2);
      function E2() {
        w("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), n.flowing || (w("pipe resume"), r.resume()), e;
    };
    function vs(e) {
      return function() {
        var r = e._readableState;
        w("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && $n(e, "data") && (r.flowing = true, lr(e));
      };
    }
    _2.prototype.unpipe = function(e) {
      var t = this._readableState, r = { hasUnpiped: false };
      if (t.pipesCount === 0)
        return this;
      if (t.pipesCount === 1)
        return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = false, e && e.emit("unpipe", this, r), this);
      if (!e) {
        var { pipes: n, pipesCount: i } = t;
        t.pipes = null, t.pipesCount = 0, t.flowing = false;
        for (var o = 0;o < i; o++)
          n[o].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var a2 = zn2(t.pipes, e);
      return a2 === -1 ? this : (t.pipes.splice(a2, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    _2.prototype.on = function(e, t) {
      var r = Ue.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, w("on readable", n.length, n.reading), n.length ? ut(this) : n.reading || process.nextTick(Es, this)), r;
    };
    _2.prototype.addListener = _2.prototype.on;
    _2.prototype.removeListener = function(e, t) {
      var r = Ue.prototype.removeListener.call(this, e, t);
      return e === "readable" && process.nextTick(Yn, this), r;
    };
    _2.prototype.removeAllListeners = function(e) {
      var t = Ue.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && process.nextTick(Yn, this), t;
    };
    function Yn(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = true : e.listenerCount("data") > 0 && e.resume();
    }
    function Es(e) {
      w("readable nexttick read 0"), e.read(0);
    }
    _2.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (w("resume"), e.flowing = !e.readableListening, xs(this, e)), e.paused = false, this;
    };
    function xs(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, process.nextTick(Rs, e, t));
    }
    function Rs(e, t) {
      w("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), lr(e), t.flowing && !t.reading && e.read(0);
    }
    _2.prototype.pause = function() {
      return w("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (w("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function lr(e) {
      var t = e._readableState;
      for (w("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    _2.prototype.wrap = function(e) {
      var t = this, r = this._readableState, n = false;
      e.on("end", function() {
        if (w("wrapped end"), r.decoder && !r.ended) {
          var a2 = r.decoder.end();
          a2 && a2.length && t.push(a2);
        }
        t.push(null);
      }), e.on("data", function(a2) {
        if (w("wrapped data"), r.decoder && (a2 = r.decoder.write(a2)), !(r.objectMode && a2 == null) && !(!r.objectMode && (!a2 || !a2.length))) {
          var s2 = t.push(a2);
          s2 || (n = true, e.pause());
        }
      });
      for (var i in e)
        this[i] === undefined && typeof e[i] == "function" && (this[i] = function(s2) {
          return function() {
            return e[s2].apply(e, arguments);
          };
        }(i));
      for (var o = 0;o < or.length; o++)
        e.on(or[o], this.emit.bind(this, or[o]));
      return this._read = function(a2) {
        w("wrapped _read", a2), n && (n = false, e.resume());
      }, this;
    };
    typeof Symbol == "function" && (_2.prototype[Symbol.asyncIterator] = function() {
      return nr === undefined && (nr = Dn()), nr(this);
    });
    Object.defineProperty(_2.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(_2.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(_2.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } });
    _2._fromList = Xn;
    Object.defineProperty(_2.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Xn(e, t) {
      if (t.length === 0)
        return null;
      var r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function sr(e) {
      var t = e._readableState;
      w("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, process.nextTick(Ss, t, e));
    }
    function Ss(e, t) {
      if (w("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = true, t.readable = false, t.emit("end"), e.autoDestroy)) {
        var r = t._writableState;
        (!r || r.autoDestroy && r.finished) && t.destroy();
      }
    }
    typeof Symbol == "function" && (_2.from = function(e, t) {
      return ir2 === undefined && (ir2 = jn()), ir2(_2, e, t);
    });
    function zn2(e, t) {
      for (var r = 0, n = e.length;r < n; r++)
        if (e[r] === t)
          return r;
      return -1;
    }
  });
  hr2 = b3((tu, Qn) => {
    Qn.exports = z;
    var lt = fe2().codes, Ts = lt.ERR_METHOD_NOT_IMPLEMENTED, As = lt.ERR_MULTIPLE_CALLBACK, Bs = lt.ERR_TRANSFORM_ALREADY_TRANSFORMING, Is = lt.ERR_TRANSFORM_WITH_LENGTH_0, ht = ue2();
    Q2()(z, ht);
    function Cs(e, t) {
      var r = this._transformState;
      r.transforming = false;
      var n = r.writecb;
      if (n === null)
        return this.emit("error", new As);
      r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
      var i = this._readableState;
      i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
    function z(e) {
      if (!(this instanceof z))
        return new z(e);
      ht.call(this, e), this._transformState = { afterTransform: Cs.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Ls);
    }
    function Ls() {
      var e = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
        Jn(e, t, r);
      }) : Jn(this, null, null);
    }
    z.prototype.push = function(e, t) {
      return this._transformState.needTransform = false, ht.prototype.push.call(this, e, t);
    };
    z.prototype._transform = function(e, t, r) {
      r(new Ts("_transform()"));
    };
    z.prototype._write = function(e, t, r) {
      var n = this._transformState;
      if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
      }
    };
    z.prototype._read = function(e) {
      var t = this._transformState;
      t.writechunk !== null && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
    };
    z.prototype._destroy = function(e, t) {
      ht.prototype._destroy.call(this, e, function(r) {
        t(r);
      });
    };
    function Jn(e, t, r) {
      if (t)
        return e.emit("error", t);
      if (r != null && e.push(r), e._writableState.length)
        throw new Is;
      if (e._transformState.transforming)
        throw new Bs;
      return e.push(null);
    }
  });
  ri = b3((ru, ti2) => {
    ti2.exports = Pe;
    var ei = hr2();
    Q2()(Pe, ei);
    function Pe(e) {
      if (!(this instanceof Pe))
        return new Pe(e);
      ei.call(this, e);
    }
    Pe.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  si = b3((nu, ai) => {
    var cr2;
    function Ms(e) {
      var t = false;
      return function() {
        t || (t = true, e.apply(undefined, arguments));
      };
    }
    var oi = fe2().codes, Os = oi.ERR_MISSING_ARGS, Fs = oi.ERR_STREAM_DESTROYED;
    function ni(e) {
      if (e)
        throw e;
    }
    function Ns(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Us(e, t, r, n) {
      n = Ms(n);
      var i = false;
      e.on("close", function() {
        i = true;
      }), cr2 === undefined && (cr2 = it()), cr2(e, { readable: t, writable: r }, function(a2) {
        if (a2)
          return n(a2);
        i = true, n();
      });
      var o = false;
      return function(a2) {
        if (!i && !o) {
          if (o = true, Ns(e))
            return e.abort();
          if (typeof e.destroy == "function")
            return e.destroy();
          n(a2 || new Fs("pipe"));
        }
      };
    }
    function ii(e) {
      e();
    }
    function Ps(e, t) {
      return e.pipe(t);
    }
    function qs(e) {
      return !e.length || typeof e[e.length - 1] != "function" ? ni : e.pop();
    }
    function Ds() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      var n = qs(t);
      if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
        throw new Os("streams");
      var i, o = t.map(function(a2, s2) {
        var u2 = s2 < t.length - 1, l2 = s2 > 0;
        return Us(a2, u2, l2, function(h2) {
          i || (i = h2), h2 && o.forEach(ii), !u2 && (o.forEach(ii), n(i));
        });
      });
      return t.reduce(Ps);
    }
    ai.exports = Ds;
  });
  dr2 = b3((q, fi2) => {
    q = fi2.exports = Xt();
    q.Stream = q;
    q.Readable = q;
    q.Writable = Kt2();
    q.Duplex = ue2();
    q.Transform = hr2();
    q.PassThrough = ri();
    q.finished = it();
    q.pipeline = si();
  });
  gr = b3((yr2) => {
    var ui = xt(), ks = Q2(), li2 = dr2(), ct = yr2.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, pr2 = yr2.IncomingMessage = function(e, t, r, n) {
      var i = this;
      if (li2.Readable.call(i), i._mode = r, i.headers = {}, i.rawHeaders = [], i.trailers = {}, i.rawTrailers = [], i.on("end", function() {
        process.nextTick(function() {
          i.emit("close");
        });
      }), r === "fetch") {
        let c2 = function() {
          a2.read().then(function(d2) {
            if (!i._destroyed) {
              if (n(d2.done), d2.done) {
                i.push(null);
                return;
              }
              i.push(Buffer.from(d2.value)), c2();
            }
          }).catch(function(d2) {
            n(true), i._destroyed || i.emit("error", d2);
          });
        };
        var h2 = c2;
        if (i._fetchResponse = t, i.url = t.url, i.statusCode = t.status, i.statusMessage = t.statusText, t.headers.forEach(function(d2, p2) {
          i.headers[p2.toLowerCase()] = d2, i.rawHeaders.push(p2, d2);
        }), ui.writableStream) {
          var o = new WritableStream({ write: function(d2) {
            return n(false), new Promise(function(p2, g2) {
              i._destroyed ? g2() : i.push(Buffer.from(d2)) ? p2() : i._resumeFetch = p2;
            });
          }, close: function() {
            n(true), i._destroyed || i.push(null);
          }, abort: function(d2) {
            n(true), i._destroyed || i.emit("error", d2);
          } });
          try {
            t.body.pipeTo(o).catch(function(d2) {
              n(true), i._destroyed || i.emit("error", d2);
            });
            return;
          } catch {
          }
        }
        var a2 = t.body.getReader();
        c2();
      } else {
        i._xhr = e, i._pos = 0, i.url = e.responseURL, i.statusCode = e.status, i.statusMessage = e.statusText;
        var s2 = e.getAllResponseHeaders().split(/\r?\n/);
        if (s2.forEach(function(c2) {
          var d2 = c2.match(/^([^:]+):\s*(.*)/);
          if (d2) {
            var p2 = d2[1].toLowerCase();
            p2 === "set-cookie" ? (i.headers[p2] === undefined && (i.headers[p2] = []), i.headers[p2].push(d2[2])) : i.headers[p2] !== undefined ? i.headers[p2] += ", " + d2[2] : i.headers[p2] = d2[2], i.rawHeaders.push(d2[1], d2[2]);
          }
        }), i._charset = "x-user-defined", !ui.overrideMimeType) {
          var u2 = i.rawHeaders["mime-type"];
          if (u2) {
            var l2 = u2.match(/;\s*charset=([^;])(;|$)/);
            l2 && (i._charset = l2[1].toLowerCase());
          }
          i._charset || (i._charset = "utf-8");
        }
      }
    };
    ks(pr2, li2.Readable);
    pr2.prototype._read = function() {
      var e = this, t = e._resumeFetch;
      t && (e._resumeFetch = null, t());
    };
    pr2.prototype._onXHRProgress = function(e) {
      var t = this, r = t._xhr, n = null;
      switch (t._mode) {
        case "text":
          if (n = r.responseText, n.length > t._pos) {
            var i = n.substr(t._pos);
            if (t._charset === "x-user-defined") {
              for (var o = Buffer.alloc(i.length), a2 = 0;a2 < i.length; a2++)
                o[a2] = i.charCodeAt(a2) & 255;
              t.push(o);
            } else
              t.push(i, t._charset);
            t._pos = n.length;
          }
          break;
        case "arraybuffer":
          if (r.readyState !== ct.DONE || !r.response)
            break;
          n = r.response, t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "moz-chunked-arraybuffer":
          if (n = r.response, r.readyState !== ct.LOADING || !n)
            break;
          t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "ms-stream":
          if (n = r.response, r.readyState !== ct.LOADING)
            break;
          var s2 = new global.MSStreamReader;
          s2.onprogress = function() {
            s2.result.byteLength > t._pos && (t.push(Buffer.from(new Uint8Array(s2.result.slice(t._pos)))), t._pos = s2.result.byteLength);
          }, s2.onload = function() {
            e(true), t.push(null);
          }, s2.readAsArrayBuffer(n);
          break;
      }
      t._xhr.readyState === ct.DONE && t._mode !== "ms-stream" && (e(true), t.push(null));
    };
  });
  pi2 = b3((ou2, di2) => {
    var pe = xt(), js2 = Q2(), ci2 = gr(), wr = dr2(), Ws2 = ci2.IncomingMessage, hi = ci2.readyStates;
    function Hs2(e, t) {
      return pe.fetch && t ? "fetch" : pe.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : pe.msstream ? "ms-stream" : pe.arraybuffer && e ? "arraybuffer" : "text";
    }
    var M2 = di2.exports = function(e) {
      var t = this;
      wr.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(i) {
        t.setHeader(i, e.headers[i]);
      });
      var r, n = true;
      if (e.mode === "disable-fetch" || "requestTimeout" in e && !pe.abortController)
        n = false, r = true;
      else if (e.mode === "prefer-streaming")
        r = false;
      else if (e.mode === "allow-wrong-content-type")
        r = !pe.overrideMimeType;
      else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
        r = true;
      else
        throw new Error("Invalid value for opts.mode");
      t._mode = Hs2(r, n), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
        t._onFinish();
      });
    };
    js2(M2, wr.Writable);
    M2.prototype.setHeader = function(e, t) {
      var r = this, n = e.toLowerCase();
      Gs2.indexOf(n) === -1 && (r._headers[n] = { name: e, value: t });
    };
    M2.prototype.getHeader = function(e) {
      var t = this._headers[e.toLowerCase()];
      return t ? t.value : null;
    };
    M2.prototype.removeHeader = function(e) {
      var t = this;
      delete t._headers[e.toLowerCase()];
    };
    M2.prototype._onFinish = function() {
      var e = this;
      if (!e._destroyed) {
        var t = e._opts;
        "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
        var r = e._headers, n = null;
        t.method !== "GET" && t.method !== "HEAD" && (n = new Blob(e._body, { type: (r["content-type"] || {}).value || "" }));
        var i = [];
        if (Object.keys(r).forEach(function(u2) {
          var l2 = r[u2].name, h2 = r[u2].value;
          Array.isArray(h2) ? h2.forEach(function(c2) {
            i.push([l2, c2]);
          }) : i.push([l2, h2]);
        }), e._mode === "fetch") {
          var o = null;
          if (pe.abortController) {
            var a2 = new AbortController;
            o = a2.signal, e._fetchAbortController = a2, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = global.setTimeout(function() {
              e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
            }, t.requestTimeout));
          }
          global.fetch(e._opts.url, { method: e._opts.method, headers: i, body: n || undefined, mode: "cors", credentials: t.withCredentials ? "include" : "same-origin", signal: o }).then(function(u2) {
            e._fetchResponse = u2, e._resetTimers(false), e._connect();
          }, function(u2) {
            e._resetTimers(true), e._destroyed || e.emit("error", u2);
          });
        } else {
          var s2 = e._xhr = new global.XMLHttpRequest;
          try {
            s2.open(e._opts.method, e._opts.url, true);
          } catch (u2) {
            process.nextTick(function() {
              e.emit("error", u2);
            });
            return;
          }
          "responseType" in s2 && (s2.responseType = e._mode), "withCredentials" in s2 && (s2.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in s2 && s2.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (s2.timeout = t.requestTimeout, s2.ontimeout = function() {
            e.emit("requestTimeout");
          }), i.forEach(function(u2) {
            s2.setRequestHeader(u2[0], u2[1]);
          }), e._response = null, s2.onreadystatechange = function() {
            switch (s2.readyState) {
              case hi.LOADING:
              case hi.DONE:
                e._onXHRProgress();
                break;
            }
          }, e._mode === "moz-chunked-arraybuffer" && (s2.onprogress = function() {
            e._onXHRProgress();
          }), s2.onerror = function() {
            e._destroyed || (e._resetTimers(true), e.emit("error", new Error("XHR error")));
          };
          try {
            s2.send(n);
          } catch (u2) {
            process.nextTick(function() {
              e.emit("error", u2);
            });
            return;
          }
        }
      }
    };
    function $s2(e) {
      try {
        var t = e.status;
        return t !== null && t !== 0;
      } catch {
        return false;
      }
    }
    M2.prototype._onXHRProgress = function() {
      var e = this;
      e._resetTimers(false), !(!$s2(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
    };
    M2.prototype._connect = function() {
      var e = this;
      e._destroyed || (e._response = new Ws2(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
        e.emit("error", t);
      }), e.emit("response", e._response));
    };
    M2.prototype._write = function(e, t, r) {
      var n = this;
      n._body.push(e), r();
    };
    M2.prototype._resetTimers = function(e) {
      var t = this;
      global.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (global.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = global.setTimeout(function() {
        t.emit("timeout");
      }, t._socketTimeout));
    };
    M2.prototype.abort = M2.prototype.destroy = function(e) {
      var t = this;
      t._destroyed = true, t._resetTimers(true), t._response && (t._response._destroyed = true), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
    };
    M2.prototype.end = function(e, t, r) {
      var n = this;
      typeof e == "function" && (r = e, e = undefined), wr.Writable.prototype.end.call(n, e, t, r);
    };
    M2.prototype.setTimeout = function(e, t) {
      var r = this;
      t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(false);
    };
    M2.prototype.flushHeaders = function() {
    };
    M2.prototype.setNoDelay = function() {
    };
    M2.prototype.setSocketKeepAlive = function() {
    };
    var Gs2 = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  });
  gi2 = b3((au2, yi2) => {
    yi2.exports = Vs2;
    var Ks2 = Object.prototype.hasOwnProperty;
    function Vs2() {
      for (var e = {}, t = 0;t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r)
          Ks2.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }
  });
  mi2 = b3((su2, wi2) => {
    wi2.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
  });
  Ti = {};
  mt(Ti, { decode: () => vr2, default: () => tf, encode: () => Er2, toASCII: () => Si2, toUnicode: () => Ri, ucs2decode: () => _r2, ucs2encode: () => Ei });
  Ai = Cr(() => {
    _i2 = "-", Ys2 = /^xn--/, Xs = /[^\0-\x7F]/, zs = /[\x2E\u3002\uFF0E\uFF61]/g, Zs = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, mr = 36 - 1, K2 = Math.floor, br = String.fromCharCode;
    Ei = (e) => String.fromCodePoint(...e), Qs = function(e) {
      return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : 36;
    }, bi2 = function(e, t) {
      return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
    }, xi2 = function(e, t, r) {
      let n = 0;
      for (e = r ? K2(e / 700) : e >> 1, e += K2(e / t);e > mr * 26 >> 1; n += 36)
        e = K2(e / mr);
      return K2(n + (mr + 1) * e / (e + 38));
    }, vr2 = function(e) {
      let t = [], r = e.length, n = 0, i = 128, o = 72, a2 = e.lastIndexOf(_i2);
      a2 < 0 && (a2 = 0);
      for (let s2 = 0;s2 < a2; ++s2)
        e.charCodeAt(s2) >= 128 && oe2("not-basic"), t.push(e.charCodeAt(s2));
      for (let s2 = a2 > 0 ? a2 + 1 : 0;s2 < r; ) {
        let u2 = n;
        for (let h2 = 1, c2 = 36;; c2 += 36) {
          s2 >= r && oe2("invalid-input");
          let d2 = Qs(e.charCodeAt(s2++));
          d2 >= 36 && oe2("invalid-input"), d2 > K2((2147483647 - n) / h2) && oe2("overflow"), n += d2 * h2;
          let p2 = c2 <= o ? 1 : c2 >= o + 26 ? 26 : c2 - o;
          if (d2 < p2)
            break;
          let g2 = 36 - p2;
          h2 > K2(2147483647 / g2) && oe2("overflow"), h2 *= g2;
        }
        let l2 = t.length + 1;
        o = xi2(n - u2, l2, u2 == 0), K2(n / l2) > 2147483647 - i && oe2("overflow"), i += K2(n / l2), n %= l2, t.splice(n++, 0, i);
      }
      return String.fromCodePoint(...t);
    }, Er2 = function(e) {
      let t = [];
      e = _r2(e);
      let r = e.length, n = 128, i = 0, o = 72;
      for (let u2 of e)
        u2 < 128 && t.push(br(u2));
      let a2 = t.length, s2 = a2;
      for (a2 && t.push(_i2);s2 < r; ) {
        let u2 = 2147483647;
        for (let h2 of e)
          h2 >= n && h2 < u2 && (u2 = h2);
        let l2 = s2 + 1;
        u2 - n > K2((2147483647 - i) / l2) && oe2("overflow"), i += (u2 - n) * l2, n = u2;
        for (let h2 of e)
          if (h2 < n && ++i > 2147483647 && oe2("overflow"), h2 === n) {
            let c2 = i;
            for (let d2 = 36;; d2 += 36) {
              let p2 = d2 <= o ? 1 : d2 >= o + 26 ? 26 : d2 - o;
              if (c2 < p2)
                break;
              let g2 = c2 - p2, E2 = 36 - p2;
              t.push(br(bi2(p2 + g2 % E2, 0))), c2 = K2(g2 / E2);
            }
            t.push(br(bi2(c2, 0))), o = xi2(i, l2, s2 === a2), i = 0, ++s2;
          }
        ++i, ++n;
      }
      return t.join("");
    }, Ri = function(e) {
      return vi2(e, function(t) {
        return Ys2.test(t) ? vr2(t.slice(4).toLowerCase()) : t;
      });
    }, Si2 = function(e) {
      return vi2(e, function(t) {
        return Xs.test(t) ? "xn--" + Er2(t) : t;
      });
    }, ef = { version: "2.1.0", ucs2: { decode: _r2, encode: Ei }, decode: vr2, encode: Er2, toASCII: Si2, toUnicode: Ri }, tf = ef;
  });
  Ii = b3((fu2, Bi) => {
    Bi.exports = { isString: function(e) {
      return typeof e == "string";
    }, isObject: function(e) {
      return typeof e == "object" && e !== null;
    }, isNull: function(e) {
      return e === null;
    }, isNullOrUndefined: function(e) {
      return e == null;
    } };
  });
  Li = b3((uu2, Ci) => {
    var rf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, nf = Object.keys || function() {
      var e = Object.prototype.hasOwnProperty, t = !{ toString: null }.propertyIsEnumerable("toString"), r = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], n = r.length;
      return function(i) {
        if (typeof i != "function" && ((typeof i > "u" ? "undefined" : rf(i)) !== "object" || i === null))
          throw new TypeError("Object.keys called on non-object");
        var o = [], a2, s2;
        for (a2 in i)
          e.call(i, a2) && o.push(a2);
        if (t)
          for (s2 = 0;s2 < n; s2++)
            e.call(i, r[s2]) && o.push(r[s2]);
        return o;
      };
    }();
    Ci.exports = nf;
  });
  ji = b3((lu2, ki) => {
    var Pi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, pt = ki.exports = { unescapeBuffer: ff, unescape: Di2, escape: lf, stringify: Fi, encode: Fi, parse: Ui, decode: Ui }, of = _e2().Buffer, af = Li(), sf = function(t) {
      return Object.prototype.toString.call(t) === "[object Array]";
    }, Mi = function(t, r, n) {
      var i;
      if (t == null)
        throw new TypeError('"arr" is null or not defined');
      var o = Object(t), a2 = o.length >>> 0;
      if (a2 === 0)
        return -1;
      var s2 = n | 0;
      if (s2 >= a2)
        return -1;
      for (i = Math.max(s2 >= 0 ? s2 : a2 - Math.abs(s2), 0);i < a2; ) {
        if (i in o && o[i] === r)
          return i;
        i++;
      }
      return -1;
    };
    function qi() {
    }
    qi.prototype = Object.create ? Object.create(null) : {};
    var Oi = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    function ff(e, t) {
      for (var r = of.allocUnsafe(e.length), n = 0, i, o, a2, s2, u2 = 0, l2 = 0;; u2++) {
        if (u2 < e.length)
          s2 = e.charCodeAt(u2);
        else {
          n > 0 && (r[l2++] = 37, n === 2 && (r[l2++] = a2));
          break;
        }
        switch (n) {
          case 0:
            switch (s2) {
              case 37:
                i = 0, o = 0, n = 1;
                break;
              case 43:
                t && (s2 = 32);
              default:
                r[l2++] = s2;
                break;
            }
            break;
          case 1:
            if (a2 = s2, i = Oi[s2], !(i >= 0)) {
              r[l2++] = 37, r[l2++] = s2, n = 0;
              break;
            }
            n = 2;
            break;
          case 2:
            if (n = 0, o = Oi[s2], !(o >= 0)) {
              r[l2++] = 37, r[l2++] = a2, r[l2++] = s2;
              break;
            }
            r[l2++] = 16 * i + o;
            break;
        }
      }
      return r.slice(0, l2);
    }
    function Di2(e, t) {
      try {
        return decodeURIComponent(e);
      } catch {
        return pt.unescapeBuffer(e, t).toString();
      }
    }
    var k2 = [];
    for (Se = 0;Se < 256; ++Se)
      k2[Se] = "%" + ((Se < 16 ? "0" : "") + Se.toString(16)).toUpperCase();
    var Se, uf = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0];
    function lf(e) {
      typeof e != "string" && ((typeof e > "u" ? "undefined" : Pi(e)) === "object" ? e = String(e) : e += "");
      for (var t = "", r = 0, n = 0;n < e.length; ++n) {
        var i = e.charCodeAt(n);
        if (i < 128) {
          if (uf[i] === 1)
            continue;
          r < n && (t += e.slice(r, n)), r = n + 1, t += k2[i];
          continue;
        }
        if (r < n && (t += e.slice(r, n)), i < 2048) {
          r = n + 1, t += k2[192 | i >> 6] + k2[128 | i & 63];
          continue;
        }
        if (i < 55296 || i >= 57344) {
          r = n + 1, t += k2[224 | i >> 12] + k2[128 | i >> 6 & 63] + k2[128 | i & 63];
          continue;
        }
        ++n;
        var o;
        if (n < e.length)
          o = e.charCodeAt(n) & 1023;
        else
          throw new URIError("URI malformed");
        r = n + 1, i = 65536 + ((i & 1023) << 10 | o), t += k2[240 | i >> 18] + k2[128 | i >> 12 & 63] + k2[128 | i >> 6 & 63] + k2[128 | i & 63];
      }
      return r === 0 ? e : r < e.length ? t + e.slice(r) : t;
    }
    function xr2(e) {
      return typeof e == "string" ? e : typeof e == "number" && isFinite(e) ? "" + e : typeof e == "boolean" ? e ? "true" : "false" : "";
    }
    function Fi(e, t, r, n) {
      t = t || "&", r = r || "=";
      var i = pt.escape;
      if (n && typeof n.encodeURIComponent == "function" && (i = n.encodeURIComponent), e !== null && (typeof e > "u" ? "undefined" : Pi(e)) === "object") {
        for (var o = af(e), a2 = o.length, s2 = a2 - 1, u2 = "", l2 = 0;l2 < a2; ++l2) {
          var h2 = o[l2], c2 = e[h2], d2 = i(xr2(h2)) + r;
          if (sf(c2)) {
            for (var p2 = c2.length, g2 = p2 - 1, E2 = 0;E2 < p2; ++E2)
              u2 += d2 + i(xr2(c2[E2])), E2 < g2 && (u2 += t);
            p2 && l2 < s2 && (u2 += t);
          } else
            u2 += d2 + i(xr2(c2)), l2 < s2 && (u2 += t);
        }
        return u2;
      }
      return "";
    }
    function Ni2(e) {
      if (e.length === 0)
        return [];
      if (e.length === 1)
        return [e.charCodeAt(0)];
      for (var t = [], r = 0;r < e.length; ++r)
        t[t.length] = e.charCodeAt(r);
      return t;
    }
    var hf = [38], cf = [61];
    function Ui(e, t, r, n) {
      var i = new qi;
      if (typeof e != "string" || e.length === 0)
        return i;
      var o = t ? Ni2(t + "") : hf, a2 = r ? Ni2(r + "") : cf, s2 = o.length, u2 = a2.length, l2 = 1000;
      n && typeof n.maxKeys == "number" && (l2 = n.maxKeys > 0 ? n.maxKeys : -1);
      var h2 = pt.unescape;
      n && typeof n.decodeURIComponent == "function" && (h2 = n.decodeURIComponent);
      for (var c2 = h2 !== Di2, d2 = [], p2 = 0, g2 = 0, E2 = 0, v = 0, m2 = "", y2 = "", R = c2, C = c2, T = 0, S = 0;S < e.length; ++S) {
        var B2 = e.charCodeAt(S);
        if (B2 === o[E2]) {
          if (++E2 === s2) {
            var F = S - E2 + 1;
            if (v < u2 ? g2 < F && (m2 += e.slice(g2, F)) : g2 < F && (y2 += e.slice(g2, F)), R && (m2 = dt2(m2, h2)), C && (y2 = dt2(y2, h2)), m2 || y2 || g2 - p2 > s2 || S === 0)
              if (Mi(d2, m2) === -1)
                i[m2] = y2, d2[d2.length] = m2;
              else {
                var L2 = i[m2] || "";
                L2.pop ? L2[L2.length] = y2 : L2 && (i[m2] = [L2, y2]);
              }
            else
              S === 1 && delete i[m2];
            if (--l2 === 0)
              break;
            R = C = c2, T = 0, m2 = y2 = "", p2 = g2, g2 = S + 1, E2 = v = 0;
          }
          continue;
        } else
          E2 = 0, C || (B2 === 37 ? T = 1 : T > 0 && (B2 >= 48 && B2 <= 57 || B2 >= 65 && B2 <= 70 || B2 >= 97 && B2 <= 102) ? ++T === 3 && (C = true) : T = 0);
        if (v < u2)
          if (B2 === a2[v]) {
            if (++v === u2) {
              var Y = S - v + 1;
              g2 < Y && (m2 += e.slice(g2, Y)), T = 0, g2 = S + 1;
            }
            continue;
          } else
            v = 0, R || (B2 === 37 ? T = 1 : T > 0 && (B2 >= 48 && B2 <= 57 || B2 >= 65 && B2 <= 70 || B2 >= 97 && B2 <= 102) ? ++T === 3 && (R = true) : T = 0);
        B2 === 43 && (v < u2 ? (g2 < S && (m2 += e.slice(g2, S)), m2 += "%20", R = true) : (g2 < S && (y2 += e.slice(g2, S)), y2 += "%20", C = true), g2 = S + 1);
      }
      if (l2 !== 0 && (g2 < e.length || v > 0))
        if (g2 < e.length && (v < u2 ? m2 += e.slice(g2) : E2 < s2 && (y2 += e.slice(g2))), R && (m2 = dt2(m2, h2)), C && (y2 = dt2(y2, h2)), Mi(d2, m2) === -1)
          i[m2] = y2, d2[d2.length] = m2;
        else {
          var Z = i[m2];
          Z.pop ? Z[Z.length] = y2 : i[m2] = [Z, y2];
        }
      return i;
    }
    function dt2(e, t) {
      try {
        return t(e);
      } catch {
        return pt.unescape(e, true);
      }
    }
  });
  Ar = b3((Ae) => {
    var df = (Ai(), _t2(Ti)), V2 = Ii();
    Ae.parse = qe;
    Ae.resolve = xf;
    Ae.resolveObject = Rf;
    Ae.format = Ef;
    Ae.Url = D;
    function D() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var pf = /^([a-z0-9.+-]+:)/i, yf = /:[0-9]*$/, gf = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, wf = ["<", ">", '"', "`", " ", "\r", `
`, "	"], mf = ["{", "}", "|", "\\", "^", "`"].concat(wf), Rr2 = ["'"].concat(mf), Wi = ["%", "/", "?", ";", "#"].concat(Rr2), Hi2 = ["/", "?", "#"], bf = 255, $i = /^[+a-z0-9A-Z_-]{0,63}$/, _f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, vf = { javascript: true, "javascript:": true }, Sr = { javascript: true, "javascript:": true }, Te = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, Tr = ji();
    function qe(e, t, r) {
      if (e && V2.isObject(e) && e instanceof D)
        return e;
      var n = new D;
      return n.parse(e, t, r), n;
    }
    D.prototype.parse = function(e, t, r) {
      if (!V2.isString(e))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
      var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", o = e.split(i), a2 = /\\/g;
      o[0] = o[0].replace(a2, "/"), e = o.join(i);
      var s2 = e;
      if (s2 = s2.trim(), !r && e.split("#").length === 1) {
        var u2 = gf.exec(s2);
        if (u2)
          return this.path = s2, this.href = s2, this.pathname = u2[1], u2[2] ? (this.search = u2[2], t ? this.query = Tr.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
      }
      var l2 = pf.exec(s2);
      if (l2) {
        l2 = l2[0];
        var h2 = l2.toLowerCase();
        this.protocol = h2, s2 = s2.substr(l2.length);
      }
      if (r || l2 || s2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var c2 = s2.substr(0, 2) === "//";
        c2 && !(l2 && Sr[l2]) && (s2 = s2.substr(2), this.slashes = true);
      }
      if (!Sr[l2] && (c2 || l2 && !Te[l2])) {
        for (var d2 = -1, p2 = 0;p2 < Hi2.length; p2++) {
          var g2 = s2.indexOf(Hi2[p2]);
          g2 !== -1 && (d2 === -1 || g2 < d2) && (d2 = g2);
        }
        var E2, v;
        d2 === -1 ? v = s2.lastIndexOf("@") : v = s2.lastIndexOf("@", d2), v !== -1 && (E2 = s2.slice(0, v), s2 = s2.slice(v + 1), this.auth = decodeURIComponent(E2)), d2 = -1;
        for (var p2 = 0;p2 < Wi.length; p2++) {
          var g2 = s2.indexOf(Wi[p2]);
          g2 !== -1 && (d2 === -1 || g2 < d2) && (d2 = g2);
        }
        d2 === -1 && (d2 = s2.length), this.host = s2.slice(0, d2), s2 = s2.slice(d2), this.parseHost(), this.hostname = this.hostname || "";
        var m2 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!m2)
          for (var y2 = this.hostname.split(/\./), p2 = 0, R = y2.length;p2 < R; p2++) {
            var C = y2[p2];
            if (!!C && !C.match($i)) {
              for (var T = "", S = 0, B2 = C.length;S < B2; S++)
                C.charCodeAt(S) > 127 ? T += "x" : T += C[S];
              if (!T.match($i)) {
                var F = y2.slice(0, p2), L2 = y2.slice(p2 + 1), Y = C.match(_f);
                Y && (F.push(Y[1]), L2.unshift(Y[2])), L2.length && (s2 = "/" + L2.join(".") + s2), this.hostname = F.join(".");
                break;
              }
            }
          }
        this.hostname.length > bf ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m2 || (this.hostname = df.toASCII(this.hostname));
        var Z = this.port ? ":" + this.port : "", zi = this.hostname || "";
        this.host = zi + Z, this.href += this.host, m2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s2[0] !== "/" && (s2 = "/" + s2));
      }
      if (!vf[h2])
        for (var p2 = 0, R = Rr2.length;p2 < R; p2++) {
          var Be = Rr2[p2];
          if (s2.indexOf(Be) !== -1) {
            var gt2 = encodeURIComponent(Be);
            gt2 === Be && (gt2 = escape(Be)), s2 = s2.split(Be).join(gt2);
          }
        }
      var wt = s2.indexOf("#");
      wt !== -1 && (this.hash = s2.substr(wt), s2 = s2.slice(0, wt));
      var je = s2.indexOf("?");
      if (je !== -1 ? (this.search = s2.substr(je), this.query = s2.substr(je + 1), t && (this.query = Tr.parse(this.query)), s2 = s2.slice(0, je)) : t && (this.search = "", this.query = {}), s2 && (this.pathname = s2), Te[h2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var Z = this.pathname || "", Zi = this.search || "";
        this.path = Z + Zi;
      }
      return this.href = this.format(), this;
    };
    function Ef(e) {
      return V2.isString(e) && (e = qe(e)), e instanceof D ? e.format() : D.prototype.format.call(e);
    }
    D.prototype.format = function() {
      var e = this.auth || "";
      e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
      var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = false, o = "";
      this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && V2.isObject(this.query) && Object.keys(this.query).length && (o = Tr.stringify(this.query));
      var a2 = this.search || o && "?" + o || "";
      return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Te[t]) && i !== false ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a2 && a2.charAt(0) !== "?" && (a2 = "?" + a2), r = r.replace(/[?#]/g, function(s2) {
        return encodeURIComponent(s2);
      }), a2 = a2.replace("#", "%23"), t + i + r + a2 + n;
    };
    function xf(e, t) {
      return qe(e, false, true).resolve(t);
    }
    D.prototype.resolve = function(e) {
      return this.resolveObject(qe(e, false, true)).format();
    };
    function Rf(e, t) {
      return e ? qe(e, false, true).resolveObject(t) : t;
    }
    D.prototype.resolveObject = function(e) {
      if (V2.isString(e)) {
        var t = new D;
        t.parse(e, false, true), e = t;
      }
      for (var r = new D, n = Object.keys(this), i = 0;i < n.length; i++) {
        var o = n[i];
        r[o] = this[o];
      }
      if (r.hash = e.hash, e.href === "")
        return r.href = r.format(), r;
      if (e.slashes && !e.protocol) {
        for (var a2 = Object.keys(e), s2 = 0;s2 < a2.length; s2++) {
          var u2 = a2[s2];
          u2 !== "protocol" && (r[u2] = e[u2]);
        }
        return Te[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
      }
      if (e.protocol && e.protocol !== r.protocol) {
        if (!Te[e.protocol]) {
          for (var l2 = Object.keys(e), h2 = 0;h2 < l2.length; h2++) {
            var c2 = l2[h2];
            r[c2] = e[c2];
          }
          return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !Sr[e.protocol]) {
          for (var R = (e.pathname || "").split("/");R.length && !(e.host = R.shift()); )
            ;
          e.host || (e.host = ""), e.hostname || (e.hostname = ""), R[0] !== "" && R.unshift(""), R.length < 2 && R.unshift(""), r.pathname = R.join("/");
        } else
          r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
          var d2 = r.pathname || "", p2 = r.search || "";
          r.path = d2 + p2;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
      }
      var g2 = r.pathname && r.pathname.charAt(0) === "/", E2 = e.host || e.pathname && e.pathname.charAt(0) === "/", v = E2 || g2 || r.host && e.pathname, m2 = v, y2 = r.pathname && r.pathname.split("/") || [], R = e.pathname && e.pathname.split("/") || [], C = r.protocol && !Te[r.protocol];
      if (C && (r.hostname = "", r.port = null, r.host && (y2[0] === "" ? y2[0] = r.host : y2.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (R[0] === "" ? R[0] = e.host : R.unshift(e.host)), e.host = null), v = v && (R[0] === "" || y2[0] === "")), E2)
        r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, y2 = R;
      else if (R.length)
        y2 || (y2 = []), y2.pop(), y2 = y2.concat(R), r.search = e.search, r.query = e.query;
      else if (!V2.isNullOrUndefined(e.search)) {
        if (C) {
          r.hostname = r.host = y2.shift();
          var T = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
          T && (r.auth = T.shift(), r.host = r.hostname = T.shift());
        }
        return r.search = e.search, r.query = e.query, (!V2.isNull(r.pathname) || !V2.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
      }
      if (!y2.length)
        return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
      for (var S = y2.slice(-1)[0], B2 = (r.host || e.host || y2.length > 1) && (S === "." || S === "..") || S === "", F = 0, L2 = y2.length;L2 >= 0; L2--)
        S = y2[L2], S === "." ? y2.splice(L2, 1) : S === ".." ? (y2.splice(L2, 1), F++) : F && (y2.splice(L2, 1), F--);
      if (!v && !m2)
        for (;F--; F)
          y2.unshift("..");
      v && y2[0] !== "" && (!y2[0] || y2[0].charAt(0) !== "/") && y2.unshift(""), B2 && y2.join("/").substr(-1) !== "/" && y2.push("");
      var Y = y2[0] === "" || y2[0] && y2[0].charAt(0) === "/";
      if (C) {
        r.hostname = r.host = Y ? "" : y2.length ? y2.shift() : "";
        var T = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
        T && (r.auth = T.shift(), r.host = r.hostname = T.shift());
      }
      return v = v || r.host && y2.length, v && !Y && y2.unshift(""), y2.length ? r.pathname = y2.join("/") : (r.pathname = null, r.path = null), (!V2.isNull(r.pathname) || !V2.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    };
    D.prototype.parseHost = function() {
      var e = this.host, t = yf.exec(e);
      t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
    };
  });
  Vi2 = b3((Ki2) => {
    var Gi2 = pi2(), Sf = gr(), Tf = gi2(), Af = mi2(), Bf = Ar(), j2 = Ki2;
    j2.request = function(e, t) {
      typeof e == "string" ? e = Bf.parse(e) : e = Tf(e);
      var r = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", n = e.protocol || r, i = e.hostname || e.host, o = e.port, a2 = e.path || "/";
      i && i.indexOf(":") !== -1 && (i = "[" + i + "]"), e.url = (i ? n + "//" + i : "") + (o ? ":" + o : "") + a2, e.method = (e.method || "GET").toUpperCase(), e.headers = e.headers || {};
      var s2 = new Gi2(e);
      return t && s2.on("response", t), s2;
    };
    j2.get = function(t, r) {
      var n = j2.request(t, r);
      return n.end(), n;
    };
    j2.ClientRequest = Gi2;
    j2.IncomingMessage = Sf.IncomingMessage;
    j2.Agent = function() {
    };
    j2.Agent.defaultMaxSockets = 4;
    j2.globalAgent = new j2.Agent;
    j2.STATUS_CODES = Af;
    j2.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  });
  Ir = b3((du, Xi2) => {
    var De = Vi2(), If = Ar(), Br = Xi2.exports;
    for (yt in De)
      De.hasOwnProperty(yt) && (Br[yt] = De[yt]);
    var yt;
    Br.request = function(e, t) {
      return e = Yi2(e), De.request.call(this, e, t);
    };
    Br.get = function(e, t) {
      return e = Yi2(e), De.get.call(this, e, t);
    };
    function Yi2(e) {
      if (typeof e == "string" && (e = If.parse(e)), e.protocol || (e.protocol = "https:"), e.protocol !== "https:")
        throw new Error('Protocol "' + e.protocol + '" not supported. Expected "https:"');
      return e;
    }
  });
  ke2 = {};
  mt(ke2, { default: () => Cf });
  $e(ke2, bt2(Ir()));
  Cf = bt2(Ir());
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node:url
var exports_url = {};
__export(exports_url, {
  resolveObject: () => {
    {
      return it2;
    }
  },
  resolve: () => {
    {
      return nt2;
    }
  },
  pathToFileURL: () => {
    {
      return V2;
    }
  },
  parse: () => {
    {
      return L2;
    }
  },
  format: () => {
    {
      return at;
    }
  },
  fileURLToPath: () => {
    {
      return W;
    }
  },
  default: () => {
    {
      return ft;
    }
  },
  Url: () => {
    {
      return m2;
    }
  },
  URLSearchParams: () => {
    {
      return k2;
    }
  },
  URL: () => {
    {
      return K3;
    }
  }
});
var M2, S, I2, H, m2, L2, at, nt2, it2, K3, k2, F, Q3, E2, tt, st, ht, B2, D, G, et2, J, rt, ot, N2, R, Z, V2, W, ft;
var init_url = __esm(() => {
  M2 = function(s2) {
    return typeof s2 == "string";
  };
  S = function(s2) {
    return typeof s2 == "object" && s2 !== null;
  };
  I2 = function(s2) {
    return s2 === null;
  };
  H = function(s2) {
    return s2 == null;
  };
  m2 = function() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  };
  L2 = function(s2, r, t) {
    if (s2 && S(s2) && s2 instanceof m2)
      return s2;
    var o = new m2;
    return o.parse(s2, r, t), o;
  };
  at = function(s2) {
    return M2(s2) && (s2 = L2(s2)), s2 instanceof m2 ? s2.format() : m2.prototype.format.call(s2);
  };
  nt2 = function(s2, r) {
    return L2(s2, false, true).resolve(r);
  };
  it2 = function(s2, r) {
    return s2 ? L2(s2, false, true).resolveObject(r) : r;
  };
  ({ URL: K3, URLSearchParams: k2, [Symbol.for("Bun.lazy")]: F } = globalThis);
  Q3 = /^([a-z0-9.+-]+:)/i;
  E2 = /:[0-9]*$/;
  tt = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  st = ["<", ">", '"', "`", " ", "\r", `
`, "	"];
  ht = ["{", "}", "|", "\\", "^", "`"].concat(st);
  B2 = ["'"].concat(ht);
  D = ["%", "/", "?", ";", "#"].concat(B2);
  G = ["/", "?", "#"];
  et2 = 255;
  J = /^[+a-z0-9A-Z_-]{0,63}$/;
  rt = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  ot = { javascript: true, "javascript:": true };
  N2 = { javascript: true, "javascript:": true };
  R = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
  Z = { parse(s2) {
    var r = decodeURIComponent;
    return (s2 + "").replace(/\+/g, " ").split("&").filter(Boolean).reduce(function(t, o, a2) {
      var l2 = o.split("="), f2 = r(l2[0] || ""), h2 = r(l2[1] || ""), y2 = t[f2];
      return t[f2] = y2 === undefined ? h2 : [].concat(y2, h2), t;
    }, {});
  }, stringify(s2) {
    var r = encodeURIComponent;
    return Object.keys(s2 || {}).reduce(function(t, o) {
      return [].concat(s2[o]).forEach(function(a2) {
        t.push(r(o) + "=" + r(a2));
      }), t;
    }, []).join("&").replace(/\s/g, "+");
  } };
  m2.prototype.parse = function(s2, r, t) {
    if (!M2(s2))
      throw new TypeError("Parameter 'url' must be a string, not " + typeof s2);
    var o = s2.indexOf("?"), a2 = o !== -1 && o < s2.indexOf("#") ? "?" : "#", l2 = s2.split(a2), f2 = /\\/g;
    l2[0] = l2[0].replace(f2, "/"), s2 = l2.join(a2);
    var h2 = s2;
    if (h2 = h2.trim(), !t && s2.split("#").length === 1) {
      var y2 = tt.exec(h2);
      if (y2)
        return this.path = h2, this.href = h2, this.pathname = y2[1], y2[2] ? (this.search = y2[2], r ? this.query = Z.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : r && (this.search = "", this.query = {}), this;
    }
    var c2 = Q3.exec(h2);
    if (c2) {
      c2 = c2[0];
      var v = c2.toLowerCase();
      this.protocol = v, h2 = h2.substr(c2.length);
    }
    if (t || c2 || h2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var A2 = h2.substr(0, 2) === "//";
      A2 && !(c2 && N2[c2]) && (h2 = h2.substr(2), this.slashes = true);
    }
    if (!N2[c2] && (A2 || c2 && !R[c2])) {
      for (var u2 = -1, n = 0;n < G.length; n++) {
        var b4 = h2.indexOf(G[n]);
        b4 !== -1 && (u2 === -1 || b4 < u2) && (u2 = b4);
      }
      var j2, p2;
      u2 === -1 ? p2 = h2.lastIndexOf("@") : p2 = h2.lastIndexOf("@", u2), p2 !== -1 && (j2 = h2.slice(0, p2), h2 = h2.slice(p2 + 1), this.auth = decodeURIComponent(j2)), u2 = -1;
      for (var n = 0;n < D.length; n++) {
        var b4 = h2.indexOf(D[n]);
        b4 !== -1 && (u2 === -1 || b4 < u2) && (u2 = b4);
      }
      u2 === -1 && (u2 = h2.length), this.host = h2.slice(0, u2), h2 = h2.slice(u2), this.parseHost(), this.hostname = this.hostname || "";
      var P = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!P)
        for (var e = this.hostname.split(/\./), n = 0, i = e.length;n < i; n++) {
          var d2 = e[n];
          if (!!d2 && !d2.match(J)) {
            for (var g2 = "", x2 = 0, _2 = d2.length;x2 < _2; x2++)
              d2.charCodeAt(x2) > 127 ? g2 += "x" : g2 += d2[x2];
            if (!g2.match(J)) {
              var q = e.slice(0, n), O2 = e.slice(n + 1), U2 = d2.match(rt);
              U2 && (q.push(U2[1]), O2.unshift(U2[2])), O2.length && (h2 = "/" + O2.join(".") + h2), this.hostname = q.join(".");
              break;
            }
          }
        }
      this.hostname.length > et2 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), P || (this.hostname = new K3(`https://${this.hostname}`).hostname);
      var w = this.port ? ":" + this.port : "", X2 = this.hostname || "";
      this.host = X2 + w, this.href += this.host, P && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), h2[0] !== "/" && (h2 = "/" + h2));
    }
    if (!ot[v])
      for (var n = 0, i = B2.length;n < i; n++) {
        var C = B2[n];
        if (h2.indexOf(C) !== -1) {
          var z = encodeURIComponent(C);
          z === C && (z = escape(C)), h2 = h2.split(C).join(z);
        }
      }
    var $ = h2.indexOf("#");
    $ !== -1 && (this.hash = h2.substr($), h2 = h2.slice(0, $));
    var T = h2.indexOf("?");
    if (T !== -1 ? (this.search = h2.substr(T), this.query = h2.substr(T + 1), r && (this.query = Z.parse(this.query)), h2 = h2.slice(0, T)) : r && (this.search = "", this.query = {}), h2 && (this.pathname = h2), R[v] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      var w = this.pathname || "", Y = this.search || "";
      this.path = w + Y;
    }
    return this.href = this.format(), this;
  };
  m2.prototype.format = function() {
    var s2 = this.auth || "";
    s2 && (s2 = encodeURIComponent(s2), s2 = s2.replace(/%3A/i, ":"), s2 += "@");
    var r = this.protocol || "", t = this.pathname || "", o = this.hash || "", a2 = false, l2 = "";
    this.host ? a2 = s2 + this.host : this.hostname && (a2 = s2 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (a2 += ":" + this.port)), this.query && S(this.query) && Object.keys(this.query).length && (l2 = Z.stringify(this.query));
    var f2 = this.search || l2 && "?" + l2 || "";
    return r && r.substr(-1) !== ":" && (r += ":"), this.slashes || (!r || R[r]) && a2 !== false ? (a2 = "//" + (a2 || ""), t && t.charAt(0) !== "/" && (t = "/" + t)) : a2 || (a2 = ""), o && o.charAt(0) !== "#" && (o = "#" + o), f2 && f2.charAt(0) !== "?" && (f2 = "?" + f2), t = t.replace(/[?#]/g, function(h2) {
      return encodeURIComponent(h2);
    }), f2 = f2.replace("#", "%23"), r + a2 + t + f2 + o;
  };
  m2.prototype.resolve = function(s2) {
    return this.resolveObject(L2(s2, false, true)).format();
  };
  m2.prototype.resolveObject = function(s2) {
    if (M2(s2)) {
      var r = new m2;
      r.parse(s2, false, true), s2 = r;
    }
    for (var t = new m2, o = Object.keys(this), a2 = 0;a2 < o.length; a2++) {
      var l2 = o[a2];
      t[l2] = this[l2];
    }
    if (t.hash = s2.hash, s2.href === "")
      return t.href = t.format(), t;
    if (s2.slashes && !s2.protocol) {
      for (var f2 = Object.keys(s2), h2 = 0;h2 < f2.length; h2++) {
        var y2 = f2[h2];
        y2 !== "protocol" && (t[y2] = s2[y2]);
      }
      return R[t.protocol] && t.hostname && !t.pathname && (t.path = t.pathname = "/"), t.href = t.format(), t;
    }
    if (s2.protocol && s2.protocol !== t.protocol) {
      if (!R[s2.protocol]) {
        for (var c2 = Object.keys(s2), v = 0;v < c2.length; v++) {
          var A2 = c2[v];
          t[A2] = s2[A2];
        }
        return t.href = t.format(), t;
      }
      if (t.protocol = s2.protocol, !s2.host && !N2[s2.protocol]) {
        for (var i = (s2.pathname || "").split("/");i.length && !(s2.host = i.shift()); )
          ;
        s2.host || (s2.host = ""), s2.hostname || (s2.hostname = ""), i[0] !== "" && i.unshift(""), i.length < 2 && i.unshift(""), t.pathname = i.join("/");
      } else
        t.pathname = s2.pathname;
      if (t.search = s2.search, t.query = s2.query, t.host = s2.host || "", t.auth = s2.auth, t.hostname = s2.hostname || s2.host, t.port = s2.port, t.pathname || t.search) {
        var u2 = t.pathname || "", n = t.search || "";
        t.path = u2 + n;
      }
      return t.slashes = t.slashes || s2.slashes, t.href = t.format(), t;
    }
    var b4 = t.pathname && t.pathname.charAt(0) === "/", j2 = s2.host || s2.pathname && s2.pathname.charAt(0) === "/", p2 = j2 || b4 || t.host && s2.pathname, P = p2, e = t.pathname && t.pathname.split("/") || [], i = s2.pathname && s2.pathname.split("/") || [], d2 = t.protocol && !R[t.protocol];
    if (d2 && (t.hostname = "", t.port = null, t.host && (e[0] === "" ? e[0] = t.host : e.unshift(t.host)), t.host = "", s2.protocol && (s2.hostname = null, s2.port = null, s2.host && (i[0] === "" ? i[0] = s2.host : i.unshift(s2.host)), s2.host = null), p2 = p2 && (i[0] === "" || e[0] === "")), j2)
      t.host = s2.host || s2.host === "" ? s2.host : t.host, t.hostname = s2.hostname || s2.hostname === "" ? s2.hostname : t.hostname, t.search = s2.search, t.query = s2.query, e = i;
    else if (i.length)
      e || (e = []), e.pop(), e = e.concat(i), t.search = s2.search, t.query = s2.query;
    else if (!H(s2.search)) {
      if (d2) {
        t.hostname = t.host = e.shift();
        var g2 = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : false;
        g2 && (t.auth = g2.shift(), t.host = t.hostname = g2.shift());
      }
      return t.search = s2.search, t.query = s2.query, (!I2(t.pathname) || !I2(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t;
    }
    if (!e.length)
      return t.pathname = null, t.search ? t.path = "/" + t.search : t.path = null, t.href = t.format(), t;
    for (var x2 = e.slice(-1)[0], _2 = (t.host || s2.host || e.length > 1) && (x2 === "." || x2 === "..") || x2 === "", q = 0, O2 = e.length;O2 >= 0; O2--)
      x2 = e[O2], x2 === "." ? e.splice(O2, 1) : x2 === ".." ? (e.splice(O2, 1), q++) : q && (e.splice(O2, 1), q--);
    if (!p2 && !P)
      for (;q--; q)
        e.unshift("..");
    p2 && e[0] !== "" && (!e[0] || e[0].charAt(0) !== "/") && e.unshift(""), _2 && e.join("/").substr(-1) !== "/" && e.push("");
    var U2 = e[0] === "" || e[0] && e[0].charAt(0) === "/";
    if (d2) {
      t.hostname = t.host = U2 ? "" : e.length ? e.shift() : "";
      var g2 = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : false;
      g2 && (t.auth = g2.shift(), t.host = t.hostname = g2.shift());
    }
    return p2 = p2 || t.host && e.length, p2 && !U2 && e.unshift(""), e.length ? t.pathname = e.join("/") : (t.pathname = null, t.path = null), (!I2(t.pathname) || !I2(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = s2.auth || t.auth, t.slashes = t.slashes || s2.slashes, t.href = t.format(), t;
  };
  m2.prototype.parseHost = function() {
    var s2 = this.host, r = E2.exec(s2);
    r && (r = r[0], r !== ":" && (this.port = r.substr(1)), s2 = s2.substr(0, s2.length - r.length)), s2 && (this.hostname = s2);
  };
  F && (V2 = F("pathToFileURL"), W = F("fileURLToPath"));
  ft = { parse: L2, resolve: nt2, resolveObject: it2, format: at, Url: m2, pathToFileURL: V2, fileURLToPath: W, URL: K3, URLSearchParams: k2 };
});

// node_modules/clean-css/lib/utils/is-http-resource.js
var require_is_http_resource = __commonJS((exports, module) => {
  var isHttpResource = function(uri) {
    return HTTP_RESOURCE_PATTERN.test(uri);
  };
  var HTTP_RESOURCE_PATTERN = /^http:\/\//;
  module.exports = isHttpResource;
});

// node_modules/clean-css/lib/utils/is-https-resource.js
var require_is_https_resource = __commonJS((exports, module) => {
  var isHttpsResource = function(uri) {
    return HTTPS_RESOURCE_PATTERN.test(uri);
  };
  var HTTPS_RESOURCE_PATTERN = /^https:\/\//;
  module.exports = isHttpsResource;
});

// node_modules/clean-css/lib/reader/load-remote-resource.js
var require_load_remote_resource = __commonJS((exports, module) => {
  var loadRemoteResource = function(uri, inlineRequest, inlineTimeout, callback) {
    var proxyProtocol = inlineRequest.protocol || inlineRequest.hostname;
    var errorHandled = false;
    var requestOptions;
    var fetch;
    requestOptions = override(url.parse(uri), inlineRequest || {});
    if (inlineRequest.hostname !== undefined) {
      requestOptions.protocol = inlineRequest.protocol || HTTP_PROTOCOL;
      requestOptions.path = requestOptions.href;
    }
    fetch = proxyProtocol && !isHttpsResource(proxyProtocol) || isHttpResource(uri) ? http.get : https.get;
    fetch(requestOptions, function(res) {
      var chunks = [];
      var movedUri;
      if (errorHandled) {
        return;
      }
      if (res.statusCode < 200 || res.statusCode > 399) {
        return callback(res.statusCode, null);
      } else if (res.statusCode > 299) {
        movedUri = url.resolve(uri, res.headers.location);
        return loadRemoteResource(movedUri, inlineRequest, inlineTimeout, callback);
      }
      res.on("data", function(chunk) {
        chunks.push(chunk.toString());
      });
      res.on("end", function() {
        var body = chunks.join("");
        callback(null, body);
      });
    }).on("error", function(res) {
      if (errorHandled) {
        return;
      }
      errorHandled = true;
      callback(res.message, null);
    }).on("timeout", function() {
      if (errorHandled) {
        return;
      }
      errorHandled = true;
      callback("timeout", null);
    }).setTimeout(inlineTimeout);
  };
  var http = (init_http(), __toCommonJS(exports_http));
  var https = (init_https(), __toCommonJS(exports_https));
  var url = (init_url(), __toCommonJS(exports_url));
  var isHttpResource = require_is_http_resource();
  var isHttpsResource = require_is_https_resource();
  var override = require_override();
  var HTTP_PROTOCOL = "http:";
  module.exports = loadRemoteResource;
});

// node_modules/clean-css/lib/options/fetch.js
var require_fetch = __commonJS((exports, module) => {
  var fetchFrom = function(callback) {
    return callback || loadRemoteResource;
  };
  var loadRemoteResource = require_load_remote_resource();
  module.exports = fetchFrom;
});

// node_modules/clean-css/lib/options/inline.js
var require_inline = __commonJS((exports, module) => {
  var inlineOptionsFrom = function(rules) {
    if (Array.isArray(rules)) {
      return rules;
    }
    if (rules === false) {
      return ["none"];
    }
    return rules === undefined ? ["local"] : rules.split(",");
  };
  module.exports = inlineOptionsFrom;
});

// node_modules/clean-css/lib/options/inline-request.js
var require_inline_request = __commonJS((exports, module) => {
  var inlineRequestFrom = function(option) {
    return override(proxyOptionsFrom(process.env.HTTP_PROXY || process.env.http_proxy), option || {});
  };
  var proxyOptionsFrom = function(httpProxy) {
    return httpProxy ? {
      hostname: url.parse(httpProxy).hostname,
      port: parseInt(url.parse(httpProxy).port)
    } : {};
  };
  var url = (init_url(), __toCommonJS(exports_url));
  var override = require_override();
  module.exports = inlineRequestFrom;
});

// node_modules/clean-css/lib/options/inline-timeout.js
var require_inline_timeout = __commonJS((exports, module) => {
  var inlineTimeoutFrom = function(option) {
    return option || DEFAULT_TIMEOUT;
  };
  var DEFAULT_TIMEOUT = 5000;
  module.exports = inlineTimeoutFrom;
});

// node_modules/clean-css/lib/options/plugins.js
var require_plugins = __commonJS((exports, module) => {
  var pluginsFrom = function(plugins) {
    var flatPlugins = {
      level1Value: [],
      level1Property: [],
      level2Block: []
    };
    plugins = plugins || [];
    flatPlugins.level1Value = plugins.map(function(plugin) {
      return plugin.level1 && plugin.level1.value;
    }).filter(function(plugin) {
      return plugin != null;
    });
    flatPlugins.level1Property = plugins.map(function(plugin) {
      return plugin.level1 && plugin.level1.property;
    }).filter(function(plugin) {
      return plugin != null;
    });
    flatPlugins.level2Block = plugins.map(function(plugin) {
      return plugin.level2 && plugin.level2.block;
    }).filter(function(plugin) {
      return plugin != null;
    });
    return flatPlugins;
  };
  module.exports = pluginsFrom;
});

// node_modules/clean-css/lib/options/rebase.js
var require_rebase = __commonJS((exports, module) => {
  var rebaseFrom = function(rebaseOption, rebaseToOption) {
    if (rebaseToOption !== undefined) {
      return true;
    } else if (rebaseOption === undefined) {
      return false;
    } else {
      return !!rebaseOption;
    }
  };
  module.exports = rebaseFrom;
});

// node:path
var exports_path = {};
__export(exports_path, {
  default: () => {
    {
      return q;
    }
  }
});
var L3, b4, z, D2, T, R2, _2, E3, C, A2, y2, h2, m3, q;
var init_path = __esm(() => {
  L3 = Object.create;
  b4 = Object.defineProperty;
  z = Object.getOwnPropertyDescriptor;
  D2 = Object.getOwnPropertyNames;
  T = Object.getPrototypeOf;
  R2 = Object.prototype.hasOwnProperty;
  _2 = (f2, e) => () => (e || f2((e = { exports: {} }).exports, e), e.exports);
  E3 = (f2, e) => {
    for (var r in e)
      b4(f2, r, { get: e[r], enumerable: true });
  };
  C = (f2, e, r, l2) => {
    if (e && typeof e == "object" || typeof e == "function")
      for (let i of D2(e))
        !R2.call(f2, i) && i !== r && b4(f2, i, { get: () => e[i], enumerable: !(l2 = z(e, i)) || l2.enumerable });
    return f2;
  };
  A2 = (f2, e, r) => (C(f2, e, "default"), r && C(r, e, "default"));
  y2 = (f2, e, r) => (r = f2 != null ? L3(T(f2)) : {}, C(e || !f2 || !f2.__esModule ? b4(r, "default", { value: f2, enumerable: true }) : r, f2));
  h2 = _2((F2, S2) => {
    function c2(f2) {
      if (typeof f2 != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(f2));
    }
    function w(f2, e) {
      for (var r = "", l2 = 0, i = -1, s2 = 0, n, t = 0;t <= f2.length; ++t) {
        if (t < f2.length)
          n = f2.charCodeAt(t);
        else {
          if (n === 47)
            break;
          n = 47;
        }
        if (n === 47) {
          if (!(i === t - 1 || s2 === 1))
            if (i !== t - 1 && s2 === 2) {
              if (r.length < 2 || l2 !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                if (r.length > 2) {
                  var a2 = r.lastIndexOf("/");
                  if (a2 !== r.length - 1) {
                    a2 === -1 ? (r = "", l2 = 0) : (r = r.slice(0, a2), l2 = r.length - 1 - r.lastIndexOf("/")), i = t, s2 = 0;
                    continue;
                  }
                } else if (r.length === 2 || r.length === 1) {
                  r = "", l2 = 0, i = t, s2 = 0;
                  continue;
                }
              }
              e && (r.length > 0 ? r += "/.." : r = "..", l2 = 2);
            } else
              r.length > 0 ? r += "/" + f2.slice(i + 1, t) : r = f2.slice(i + 1, t), l2 = t - i - 1;
          i = t, s2 = 0;
        } else
          n === 46 && s2 !== -1 ? ++s2 : s2 = -1;
      }
      return r;
    }
    function J2(f2, e) {
      var r = e.dir || e.root, l2 = e.base || (e.name || "") + (e.ext || "");
      return r ? r === e.root ? r + l2 : r + f2 + l2 : l2;
    }
    var g2 = { resolve: function() {
      for (var e = "", r = false, l2, i = arguments.length - 1;i >= -1 && !r; i--) {
        var s2;
        i >= 0 ? s2 = arguments[i] : (l2 === undefined && (l2 = process.cwd()), s2 = l2), c2(s2), s2.length !== 0 && (e = s2 + "/" + e, r = s2.charCodeAt(0) === 47);
      }
      return e = w(e, !r), r ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
    }, normalize: function(e) {
      if (c2(e), e.length === 0)
        return ".";
      var r = e.charCodeAt(0) === 47, l2 = e.charCodeAt(e.length - 1) === 47;
      return e = w(e, !r), e.length === 0 && !r && (e = "."), e.length > 0 && l2 && (e += "/"), r ? "/" + e : e;
    }, isAbsolute: function(e) {
      return c2(e), e.length > 0 && e.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var e, r = 0;r < arguments.length; ++r) {
        var l2 = arguments[r];
        c2(l2), l2.length > 0 && (e === undefined ? e = l2 : e += "/" + l2);
      }
      return e === undefined ? "." : g2.normalize(e);
    }, relative: function(e, r) {
      if (c2(e), c2(r), e === r || (e = g2.resolve(e), r = g2.resolve(r), e === r))
        return "";
      for (var l2 = 1;l2 < e.length && e.charCodeAt(l2) === 47; ++l2)
        ;
      for (var i = e.length, s2 = i - l2, n = 1;n < r.length && r.charCodeAt(n) === 47; ++n)
        ;
      for (var t = r.length, a2 = t - n, v = s2 < a2 ? s2 : a2, u2 = -1, o = 0;o <= v; ++o) {
        if (o === v) {
          if (a2 > v) {
            if (r.charCodeAt(n + o) === 47)
              return r.slice(n + o + 1);
            if (o === 0)
              return r.slice(n + o);
          } else
            s2 > v && (e.charCodeAt(l2 + o) === 47 ? u2 = o : o === 0 && (u2 = 0));
          break;
        }
        var k3 = e.charCodeAt(l2 + o), P = r.charCodeAt(n + o);
        if (k3 !== P)
          break;
        k3 === 47 && (u2 = o);
      }
      var d2 = "";
      for (o = l2 + u2 + 1;o <= i; ++o)
        (o === i || e.charCodeAt(o) === 47) && (d2.length === 0 ? d2 += ".." : d2 += "/..");
      return d2.length > 0 ? d2 + r.slice(n + u2) : (n += u2, r.charCodeAt(n) === 47 && ++n, r.slice(n));
    }, _makeLong: function(e) {
      return e;
    }, dirname: function(e) {
      if (c2(e), e.length === 0)
        return ".";
      for (var r = e.charCodeAt(0), l2 = r === 47, i = -1, s2 = true, n = e.length - 1;n >= 1; --n)
        if (r = e.charCodeAt(n), r === 47) {
          if (!s2) {
            i = n;
            break;
          }
        } else
          s2 = false;
      return i === -1 ? l2 ? "/" : "." : l2 && i === 1 ? "//" : e.slice(0, i);
    }, basename: function(e, r) {
      if (r !== undefined && typeof r != "string")
        throw new TypeError('"ext" argument must be a string');
      c2(e);
      var l2 = 0, i = -1, s2 = true, n;
      if (r !== undefined && r.length > 0 && r.length <= e.length) {
        if (r.length === e.length && r === e)
          return "";
        var t = r.length - 1, a2 = -1;
        for (n = e.length - 1;n >= 0; --n) {
          var v = e.charCodeAt(n);
          if (v === 47) {
            if (!s2) {
              l2 = n + 1;
              break;
            }
          } else
            a2 === -1 && (s2 = false, a2 = n + 1), t >= 0 && (v === r.charCodeAt(t) ? --t === -1 && (i = n) : (t = -1, i = a2));
        }
        return l2 === i ? i = a2 : i === -1 && (i = e.length), e.slice(l2, i);
      } else {
        for (n = e.length - 1;n >= 0; --n)
          if (e.charCodeAt(n) === 47) {
            if (!s2) {
              l2 = n + 1;
              break;
            }
          } else
            i === -1 && (s2 = false, i = n + 1);
        return i === -1 ? "" : e.slice(l2, i);
      }
    }, extname: function(e) {
      c2(e);
      for (var r = -1, l2 = 0, i = -1, s2 = true, n = 0, t = e.length - 1;t >= 0; --t) {
        var a2 = e.charCodeAt(t);
        if (a2 === 47) {
          if (!s2) {
            l2 = t + 1;
            break;
          }
          continue;
        }
        i === -1 && (s2 = false, i = t + 1), a2 === 46 ? r === -1 ? r = t : n !== 1 && (n = 1) : r !== -1 && (n = -1);
      }
      return r === -1 || i === -1 || n === 0 || n === 1 && r === i - 1 && r === l2 + 1 ? "" : e.slice(r, i);
    }, format: function(e) {
      if (e === null || typeof e != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
      return J2("/", e);
    }, parse: function(e) {
      c2(e);
      var r = { root: "", dir: "", base: "", ext: "", name: "" };
      if (e.length === 0)
        return r;
      var l2 = e.charCodeAt(0), i = l2 === 47, s2;
      i ? (r.root = "/", s2 = 1) : s2 = 0;
      for (var n = -1, t = 0, a2 = -1, v = true, u2 = e.length - 1, o = 0;u2 >= s2; --u2) {
        if (l2 = e.charCodeAt(u2), l2 === 47) {
          if (!v) {
            t = u2 + 1;
            break;
          }
          continue;
        }
        a2 === -1 && (v = false, a2 = u2 + 1), l2 === 46 ? n === -1 ? n = u2 : o !== 1 && (o = 1) : n !== -1 && (o = -1);
      }
      return n === -1 || a2 === -1 || o === 0 || o === 1 && n === a2 - 1 && n === t + 1 ? a2 !== -1 && (t === 0 && i ? r.base = r.name = e.slice(1, a2) : r.base = r.name = e.slice(t, a2)) : (t === 0 && i ? (r.name = e.slice(1, n), r.base = e.slice(1, a2)) : (r.name = e.slice(t, n), r.base = e.slice(t, a2)), r.ext = e.slice(n, a2)), t > 0 ? r.dir = e.slice(0, t - 1) : i && (r.dir = "/"), r;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    g2.posix = g2;
    S2.exports = g2;
  });
  m3 = {};
  E3(m3, { default: () => q });
  A2(m3, y2(h2()));
  q = y2(h2());
});

// node_modules/clean-css/lib/options/rebase-to.js
var require_rebase_to = __commonJS((exports, module) => {
  var rebaseToFrom = function(option) {
    return option ? path.resolve(option) : process.cwd();
  };
  var path = (init_path(), __toCommonJS(exports_path));
  module.exports = rebaseToFrom;
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
  var toVLQSigned = function(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  };
  var fromVLQSigned = function(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  };
  var base64 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS((exports) => {
  var getArg = function(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  };
  var urlParse = function(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  };
  var urlGenerate = function(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  };
  var normalize = function(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1;i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  };
  var join = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  };
  var relative = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  };
  var identity = function(s2) {
    return s2;
  };
  var toSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  };
  var fromSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  };
  var isProtoString = function(s2) {
    if (!s2) {
      return false;
    }
    var length = s2.length;
    if (length < 9) {
      return false;
    }
    if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10;i >= 0; i--) {
      if (s2.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  };
  var compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var strcmp = function(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  };
  var compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var parseSourceMapInput = function(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  };
  var computeSourceURL = function(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  };
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  exports.urlParse = urlParse;
  exports.urlGenerate = urlGenerate;
  exports.normalize = normalize;
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  exports.toSetString = supportsNullProto ? identity : toSetString;
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  exports.compareByOriginalPositions = compareByOriginalPositions;
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  exports.parseSourceMapInput = parseSourceMapInput;
  exports.computeSourceURL = computeSourceURL;
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS((exports) => {
  var ArraySet = function() {
    this._array = [];
    this._set = hasNativeMap ? new Map : Object.create(null);
  };
  var util = require_util();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet;
    for (var i = 0, len = aArray.length;i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
  var generatedPositionAfter = function(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  };
  var MappingList = function() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  };
  var util = require_util();
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports) => {
  var SourceMapGenerator = function(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet;
    this._names = new ArraySet;
    this._mappings = new MappingList;
    this._sourcesContents = null;
  };
  var base64VLQ = require_base64_vlq();
  var util = require_util();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet;
    var newNames = new ArraySet;
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length;i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS((exports) => {
  var recursiveSearch = function(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  };
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS((exports) => {
  var swap = function(ary, x2, y3) {
    var temp = ary[x2];
    ary[x2] = ary[y3];
    ary[y3] = temp;
  };
  var randomIntInRange = function(low, high) {
    return Math.round(low + Math.random() * (high - low));
  };
  var doQuickSort = function(ary, comparator, p2, r) {
    if (p2 < r) {
      var pivotIndex = randomIntInRange(p2, r);
      var i = p2 - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j2 = p2;j2 < r; j2++) {
        if (comparator(ary[j2], pivot) <= 0) {
          i += 1;
          swap(ary, i, j2);
        }
      }
      swap(ary, i + 1, j2);
      var q2 = i + 1;
      doQuickSort(ary, comparator, p2, q2 - 1);
      doQuickSort(ary, comparator, q2 + 1, r);
    }
  };
  exports.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports) => {
  var SourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  };
  var BasicSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s2) {
      return util.computeSourceURL(sourceRoot, s2, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  };
  var Mapping = function() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  };
  var IndexedSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet;
    this._names = new ArraySet;
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s2) {
      if (s2.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s2, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s2, "map"), aSourceMapURL)
      };
    });
  };
  var util = require_util();
  var binarySearch = require_binary_search();
  var ArraySet = require_array_set().ArraySet;
  var base64VLQ = require_base64_vlq();
  var quickSort = require_quick_sort().quickSort;
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c2 = aStr.charAt(index);
    return c2 === ";" || c2 === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports.SourceMapConsumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0;i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s2) {
      return util.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length;i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping;
        mapping.generatedLine = generatedLine;
        for (end = index;end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0;index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0;i < this._sections.length; i++) {
        for (var j2 = 0;j2 < this._sections[i].consumer.sources.length; j2++) {
          sources.push(this._sections[i].consumer.sources[j2]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s2) {
      return s2.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j2 = 0;j2 < sectionMappings.length; j2++) {
        var mapping = sectionMappings[j2];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS((exports) => {
  var SourceNode = function(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  };
  var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  var util = require_util();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode;
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1;i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length;i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0;i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length;i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length;i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length;idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map };
  };
  exports.SourceNode = SourceNode;
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS((exports) => {
  exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
  exports.SourceNode = require_source_node().SourceNode;
});

// node_modules/clean-css/lib/reader/input-source-map-tracker.js
var require_input_source_map_tracker = __commonJS((exports, module) => {
  var inputSourceMapTracker = function() {
    var maps = {};
    return {
      all: all2.bind(null, maps),
      isTracking: isTracking.bind(null, maps),
      originalPositionFor: originalPositionFor.bind(null, maps),
      track: track.bind(null, maps)
    };
  };
  var all2 = function(maps) {
    return maps;
  };
  var isTracking = function(maps, source) {
    return source in maps;
  };
  var originalPositionFor = function(maps, metadata, range, selectorFallbacks) {
    var line = metadata[0];
    var column = metadata[1];
    var source = metadata[2];
    var position = {
      line,
      column: column + range
    };
    var originalPosition;
    while (!originalPosition && position.column > column) {
      position.column--;
      originalPosition = maps[source].originalPositionFor(position);
    }
    if (!originalPosition || originalPosition.column < 0) {
      return metadata;
    }
    if (originalPosition.line === null && line > 1 && selectorFallbacks > 0) {
      return originalPositionFor(maps, [line - 1, column, source], range, selectorFallbacks - 1);
    }
    return originalPosition.line !== null ? toMetadata(originalPosition) : metadata;
  };
  var toMetadata = function(asHash) {
    return [asHash.line, asHash.column, asHash.source];
  };
  var track = function(maps, source, data) {
    maps[source] = new SourceMapConsumer(data);
  };
  var SourceMapConsumer = require_source_map().SourceMapConsumer;
  module.exports = inputSourceMapTracker;
});

// node_modules/clean-css/lib/utils/is-remote-resource.js
var require_is_remote_resource = __commonJS((exports, module) => {
  var isRemoteResource = function(uri) {
    return REMOTE_RESOURCE_PATTERN.test(uri);
  };
  var REMOTE_RESOURCE_PATTERN = /^(\w+:\/\/|\/\/)/;
  module.exports = isRemoteResource;
});

// node_modules/clean-css/lib/utils/has-protocol.js
var require_has_protocol = __commonJS((exports, module) => {
  var hasProtocol = function(uri) {
    return !NO_PROTOCOL_RESOURCE_PATTERN.test(uri);
  };
  var NO_PROTOCOL_RESOURCE_PATTERN = /^\/\//;
  module.exports = hasProtocol;
});

// node_modules/clean-css/lib/reader/is-allowed-resource.js
var require_is_allowed_resource = __commonJS((exports, module) => {
  var isAllowedResource = function(uri, isRemote, rules) {
    var match;
    var absoluteUri;
    var allowed = isRemote ? false : true;
    var rule;
    var isNegated;
    var normalizedRule;
    var i;
    if (rules.length === 0) {
      return false;
    }
    if (isRemote && !hasProtocol(uri)) {
      uri = HTTP_PROTOCOL + uri;
    }
    match = isRemote ? url.parse(uri).host : uri;
    absoluteUri = isRemote ? uri : path.resolve(uri);
    for (i = 0;i < rules.length; i++) {
      rule = rules[i];
      isNegated = rule[0] == "!";
      normalizedRule = rule.substring(1);
      if (isNegated && isRemote && isRemoteRule(normalizedRule)) {
        allowed = allowed && !isAllowedResource(uri, true, [normalizedRule]);
      } else if (isNegated && !isRemote && !isRemoteRule(normalizedRule)) {
        allowed = allowed && !isAllowedResource(uri, false, [normalizedRule]);
      } else if (isNegated) {
        allowed = allowed && true;
      } else if (rule == "all") {
        allowed = true;
      } else if (isRemote && rule == "local") {
        allowed = allowed || false;
      } else if (isRemote && rule == "remote") {
        allowed = true;
      } else if (!isRemote && rule == "remote") {
        allowed = false;
      } else if (!isRemote && rule == "local") {
        allowed = true;
      } else if (rule === match) {
        allowed = true;
      } else if (rule === uri) {
        allowed = true;
      } else if (isRemote && absoluteUri.indexOf(rule) === 0) {
        allowed = true;
      } else if (!isRemote && absoluteUri.indexOf(path.resolve(rule)) === 0) {
        allowed = true;
      } else if (isRemote != isRemoteRule(normalizedRule)) {
        allowed = allowed && true;
      } else {
        allowed = false;
      }
    }
    return allowed;
  };
  var isRemoteRule = function(rule) {
    return isRemoteResource(rule) || url.parse(HTTP_PROTOCOL + "//" + rule).host == rule;
  };
  var path = (init_path(), __toCommonJS(exports_path));
  var url = (init_url(), __toCommonJS(exports_url));
  var isRemoteResource = require_is_remote_resource();
  var hasProtocol = require_has_protocol();
  var HTTP_PROTOCOL = "http:";
  module.exports = isAllowedResource;
});

// node_modules/clean-css/lib/reader/match-data-uri.js
var require_match_data_uri = __commonJS((exports, module) => {
  var matchDataUri = function(uri) {
    return DATA_URI_PATTERN.exec(uri);
  };
  var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;
  module.exports = matchDataUri;
});

// node_modules/clean-css/lib/reader/rebase-local-map.js
var require_rebase_local_map = __commonJS((exports, module) => {
  var rebaseLocalMap = function(sourceMap, sourceUri, rebaseTo) {
    var currentPath = path.resolve("");
    var absoluteUri = path.resolve(currentPath, sourceUri);
    var absoluteUriDirectory = path.dirname(absoluteUri);
    sourceMap.sources = sourceMap.sources.map(function(source) {
      return path.relative(rebaseTo, path.resolve(absoluteUriDirectory, source));
    });
    return sourceMap;
  };
  var path = (init_path(), __toCommonJS(exports_path));
  module.exports = rebaseLocalMap;
});

// node_modules/clean-css/lib/reader/rebase-remote-map.js
var require_rebase_remote_map = __commonJS((exports, module) => {
  var rebaseRemoteMap = function(sourceMap, sourceUri) {
    var sourceDirectory = path.dirname(sourceUri);
    sourceMap.sources = sourceMap.sources.map(function(source) {
      return url.resolve(sourceDirectory, source);
    });
    return sourceMap;
  };
  var path = (init_path(), __toCommonJS(exports_path));
  var url = (init_url(), __toCommonJS(exports_url));
  module.exports = rebaseRemoteMap;
});

// node_modules/clean-css/lib/utils/is-data-uri-resource.js
var require_is_data_uri_resource = __commonJS((exports, module) => {
  var isDataUriResource = function(uri) {
    return DATA_URI_PATTERN.test(uri);
  };
  var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;
  module.exports = isDataUriResource;
});

// node_modules/clean-css/lib/reader/apply-source-maps.js
var require_apply_source_maps = __commonJS((exports, module) => {
  var applySourceMaps = function(tokens, context, callback) {
    var applyContext = {
      callback,
      fetch: context.options.fetch,
      index: 0,
      inline: context.options.inline,
      inlineRequest: context.options.inlineRequest,
      inlineTimeout: context.options.inlineTimeout,
      inputSourceMapTracker: context.inputSourceMapTracker,
      localOnly: context.localOnly,
      processedTokens: [],
      rebaseTo: context.options.rebaseTo,
      sourceTokens: tokens,
      warnings: context.warnings
    };
    return context.options.sourceMap && tokens.length > 0 ? doApplySourceMaps(applyContext) : callback(tokens);
  };
  var doApplySourceMaps = function(applyContext) {
    var singleSourceTokens = [];
    var lastSource = findTokenSource(applyContext.sourceTokens[0]);
    var source;
    var token;
    var l2;
    for (l2 = applyContext.sourceTokens.length;applyContext.index < l2; applyContext.index++) {
      token = applyContext.sourceTokens[applyContext.index];
      source = findTokenSource(token);
      if (source != lastSource) {
        singleSourceTokens = [];
        lastSource = source;
      }
      singleSourceTokens.push(token);
      applyContext.processedTokens.push(token);
      if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {
        return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);
      }
    }
    return applyContext.callback(applyContext.processedTokens);
  };
  var findTokenSource = function(token) {
    var scope;
    var metadata;
    if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT || token[0] == Token.RAW) {
      metadata = token[2][0];
    } else {
      scope = token[1][0];
      metadata = scope[2][0];
    }
    return metadata[2];
  };
  var fetchAndApplySourceMap = function(sourceMapComment, source, singleSourceTokens, applyContext) {
    return extractInputSourceMapFrom(sourceMapComment, applyContext, function(inputSourceMap) {
      if (inputSourceMap) {
        applyContext.inputSourceMapTracker.track(source, inputSourceMap);
        applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);
      }
      applyContext.index++;
      return doApplySourceMaps(applyContext);
    });
  };
  var extractInputSourceMapFrom = function(sourceMapComment, applyContext, whenSourceMapReady) {
    var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];
    var absoluteUri;
    var sourceMap;
    var rebasedMap;
    if (isDataUriResource(uri)) {
      sourceMap = extractInputSourceMapFromDataUri(uri);
      return whenSourceMapReady(sourceMap);
    } else if (isRemoteResource(uri)) {
      return loadInputSourceMapFromRemoteUri(uri, applyContext, function(sourceMap2) {
        var parsedMap;
        if (sourceMap2) {
          parsedMap = JSON.parse(sourceMap2);
          rebasedMap = rebaseRemoteMap(parsedMap, uri);
          whenSourceMapReady(rebasedMap);
        } else {
          whenSourceMapReady(null);
        }
      });
    } else {
      absoluteUri = path.resolve(applyContext.rebaseTo, uri);
      sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);
      if (sourceMap) {
        rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);
        return whenSourceMapReady(rebasedMap);
      } else {
        return whenSourceMapReady(null);
      }
    }
  };
  var extractInputSourceMapFromDataUri = function(uri) {
    var dataUriMatch = matchDataUri(uri);
    var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : "us-ascii";
    var encoding = dataUriMatch[3] ? dataUriMatch[3].split(";")[1] : "utf8";
    var data = encoding == "utf8" ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];
    var buffer = Buffer.from(data, encoding);
    buffer.charset = charset;
    return JSON.parse(buffer.toString());
  };
  var loadInputSourceMapFromRemoteUri = function(uri, applyContext, whenLoaded) {
    var isAllowed = isAllowedResource(uri, true, applyContext.inline);
    var isRuntimeResource = !hasProtocol(uri);
    if (applyContext.localOnly) {
      applyContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
      return whenLoaded(null);
    } else if (isRuntimeResource) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
      return whenLoaded(null);
    } else if (!isAllowed) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return whenLoaded(null);
    }
    applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function(error, body) {
      if (error) {
        applyContext.warnings.push('Missing source map at "' + uri + '" - ' + error);
        return whenLoaded(null);
      }
      whenLoaded(body);
    });
  };
  var loadInputSourceMapFromLocalUri = function(uri, applyContext) {
    var isAllowed = isAllowedResource(uri, false, applyContext.inline);
    var sourceMap;
    if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {
      applyContext.warnings.push('Ignoring local source map at "' + uri + '" as resource is missing.');
      return null;
    } else if (!isAllowed) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return null;
    }
    sourceMap = fs.readFileSync(uri, "utf-8");
    return JSON.parse(sourceMap);
  };
  var applySourceMapRecursively = function(tokens, inputSourceMapTracker) {
    var token;
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.AT_RULE_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.AT_RULE_BLOCK_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.NESTED_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.NESTED_BLOCK_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.COMMENT:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY:
          applySourceMapRecursively(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          break;
        case Token.PROPERTY_NAME:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY_VALUE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.RULE:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.RULE_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
      }
    }
    return tokens;
  };
  var applySourceMapTo = function(token, inputSourceMapTracker) {
    var value = token[1];
    var metadata = token[2];
    var newMetadata = [];
    var i, l2;
    for (i = 0, l2 = metadata.length;i < l2; i++) {
      newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));
    }
    token[2] = newMetadata;
  };
  var fs = (()=>({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var isAllowedResource = require_is_allowed_resource();
  var matchDataUri = require_match_data_uri();
  var rebaseLocalMap = require_rebase_local_map();
  var rebaseRemoteMap = require_rebase_remote_map();
  var Token = require_token();
  var hasProtocol = require_has_protocol();
  var isDataUriResource = require_is_data_uri_resource();
  var isRemoteResource = require_is_remote_resource();
  var MAP_MARKER_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;
  module.exports = applySourceMaps;
});

// node_modules/clean-css/lib/reader/extract-import-url-and-media.js
var require_extract_import_url_and_media = __commonJS((exports, module) => {
  var extractImportUrlAndMedia = function(atRuleValue) {
    var uri;
    var mediaQuery;
    var stripped;
    var parts;
    stripped = atRuleValue.replace(IMPORT_PREFIX_PATTERN, "").trim().replace(URL_PREFIX_PATTERN, "(").replace(URL_SUFFIX_PATTERN, ")").replace(QUOTE_PREFIX_PATTERN, "").replace(QUOTE_SUFFIX_PATTERN, "");
    parts = split(stripped, " ");
    uri = parts[0].replace(BRACE_PREFIX, "").replace(BRACE_SUFFIX, "");
    mediaQuery = parts.slice(1).join(" ");
    return [uri, mediaQuery];
  };
  var split = require_split();
  var BRACE_PREFIX = /^\(/;
  var BRACE_SUFFIX = /\)$/;
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  var QUOTE_PREFIX_PATTERN = /['"]\s*/;
  var QUOTE_SUFFIX_PATTERN = /\s*['"]/;
  var URL_PREFIX_PATTERN = /^url\(\s*/i;
  var URL_SUFFIX_PATTERN = /\s*\)/i;
  module.exports = extractImportUrlAndMedia;
});

// node_modules/clean-css/lib/reader/load-original-sources.js
var require_load_original_sources = __commonJS((exports, module) => {
  var loadOriginalSources = function(context, callback) {
    var loadContext = {
      callback,
      fetch: context.options.fetch,
      index: 0,
      inline: context.options.inline,
      inlineRequest: context.options.inlineRequest,
      inlineTimeout: context.options.inlineTimeout,
      localOnly: context.localOnly,
      rebaseTo: context.options.rebaseTo,
      sourcesContent: context.sourcesContent,
      uriToSource: uriToSourceMapping(context.inputSourceMapTracker.all()),
      warnings: context.warnings
    };
    return context.options.sourceMap && context.options.sourceMapInlineSources ? doLoadOriginalSources(loadContext) : callback();
  };
  var uriToSourceMapping = function(allSourceMapConsumers) {
    var mapping = {};
    var consumer;
    var uri;
    var source;
    var i, l2;
    for (source in allSourceMapConsumers) {
      consumer = allSourceMapConsumers[source];
      for (i = 0, l2 = consumer.sources.length;i < l2; i++) {
        uri = consumer.sources[i];
        source = consumer.sourceContentFor(uri, true);
        mapping[uri] = source;
      }
    }
    return mapping;
  };
  var doLoadOriginalSources = function(loadContext) {
    var uris = Object.keys(loadContext.uriToSource);
    var uri;
    var source;
    var total;
    for (total = uris.length;loadContext.index < total; loadContext.index++) {
      uri = uris[loadContext.index];
      source = loadContext.uriToSource[uri];
      if (source) {
        loadContext.sourcesContent[uri] = source;
      } else {
        return loadOriginalSource(uri, loadContext);
      }
    }
    return loadContext.callback();
  };
  var loadOriginalSource = function(uri, loadContext) {
    var content;
    if (isRemoteResource(uri)) {
      return loadOriginalSourceFromRemoteUri(uri, loadContext, function(content2) {
        loadContext.index++;
        loadContext.sourcesContent[uri] = content2;
        return doLoadOriginalSources(loadContext);
      });
    } else {
      content = loadOriginalSourceFromLocalUri(uri, loadContext);
      loadContext.index++;
      loadContext.sourcesContent[uri] = content;
      return doLoadOriginalSources(loadContext);
    }
  };
  var loadOriginalSourceFromRemoteUri = function(uri, loadContext, whenLoaded) {
    var isAllowed = isAllowedResource(uri, true, loadContext.inline);
    var isRuntimeResource = !hasProtocol(uri);
    if (loadContext.localOnly) {
      loadContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
      return whenLoaded(null);
    } else if (isRuntimeResource) {
      loadContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
      return whenLoaded(null);
    } else if (!isAllowed) {
      loadContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return whenLoaded(null);
    }
    loadContext.fetch(uri, loadContext.inlineRequest, loadContext.inlineTimeout, function(error, content) {
      if (error) {
        loadContext.warnings.push('Missing original source at "' + uri + '" - ' + error);
      }
      whenLoaded(content);
    });
  };
  var loadOriginalSourceFromLocalUri = function(relativeUri, loadContext) {
    var isAllowed = isAllowedResource(relativeUri, false, loadContext.inline);
    var absoluteUri = path.resolve(loadContext.rebaseTo, relativeUri);
    if (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile()) {
      loadContext.warnings.push('Ignoring local source map at "' + absoluteUri + '" as resource is missing.');
      return null;
    } else if (!isAllowed) {
      loadContext.warnings.push('Cannot fetch "' + absoluteUri + '" as resource is not allowed.');
      return null;
    }
    return fs.readFileSync(absoluteUri, "utf8");
  };
  var fs = (()=>({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var isAllowedResource = require_is_allowed_resource();
  var hasProtocol = require_has_protocol();
  var isRemoteResource = require_is_remote_resource();
  module.exports = loadOriginalSources;
});

// node_modules/clean-css/lib/reader/normalize-path.js
var require_normalize_path = __commonJS((exports, module) => {
  var normalizePath = function(path) {
    return path.replace(WINDOWS_SEPARATOR_PATTERN, UNIX_SEPARATOR);
  };
  var UNIX_SEPARATOR = "/";
  var WINDOWS_SEPARATOR_PATTERN = /\\/g;
  module.exports = normalizePath;
});

// node_modules/clean-css/lib/reader/restore-import.js
var require_restore_import = __commonJS((exports, module) => {
  var restoreImport = function(uri, mediaQuery) {
    return ("@import " + uri + " " + mediaQuery).trim();
  };
  module.exports = restoreImport;
});

// node_modules/clean-css/lib/reader/rewrite-url.js
var require_rewrite_url = __commonJS((exports, module) => {
  var rebase = function(uri, rebaseConfig) {
    if (!rebaseConfig) {
      return uri;
    }
    if (isAbsolute(uri) && !isRemote(rebaseConfig.toBase)) {
      return uri;
    }
    if (isRemote(uri) || isSVGMarker(uri) || isInternal(uri) || isDataUriResource(uri)) {
      return uri;
    }
    if (isRemote(rebaseConfig.toBase)) {
      return url.resolve(rebaseConfig.toBase, uri);
    }
    return rebaseConfig.absolute ? normalize(absolute(uri, rebaseConfig)) : normalize(relative(uri, rebaseConfig));
  };
  var isAbsolute = function(uri) {
    return path.isAbsolute(uri);
  };
  var isSVGMarker = function(uri) {
    return uri[0] == "#";
  };
  var isInternal = function(uri) {
    return /^\w+:\w+/.test(uri);
  };
  var isRemote = function(uri) {
    return /^[^:]+?:\/\//.test(uri) || PROTOCOL_LESS_PREFIX_PATTERN.test(uri);
  };
  var absolute = function(uri, rebaseConfig) {
    return path.resolve(path.join(rebaseConfig.fromBase || "", uri)).replace(rebaseConfig.toBase, "");
  };
  var relative = function(uri, rebaseConfig) {
    return path.relative(rebaseConfig.toBase, path.join(rebaseConfig.fromBase || "", uri));
  };
  var normalize = function(uri) {
    return isWindows ? uri.replace(/\\/g, "/") : uri;
  };
  var quoteFor = function(unquotedUrl) {
    if (unquotedUrl.indexOf(SINGLE_QUOTE) > -1) {
      return DOUBLE_QUOTE;
    } else if (unquotedUrl.indexOf(DOUBLE_QUOTE) > -1) {
      return SINGLE_QUOTE;
    } else if (hasWhitespace(unquotedUrl) || hasRoundBrackets(unquotedUrl)) {
      return SINGLE_QUOTE;
    } else {
      return "";
    }
  };
  var hasWhitespace = function(url2) {
    return WHITESPACE_PATTERN.test(url2);
  };
  var hasRoundBrackets = function(url2) {
    return ROUND_BRACKETS_PATTERN.test(url2);
  };
  var rewriteUrl = function(originalUrl, rebaseConfig, pathOnly) {
    var strippedUrl = originalUrl.replace(URL_PREFIX_PATTERN, "").replace(URL_SUFFIX_PATTERN, "").trim();
    var unquotedUrl = strippedUrl.replace(QUOTE_PREFIX_PATTERN, "").replace(QUOTE_SUFFIX_PATTERN, "").trim();
    var quote = strippedUrl[0] == SINGLE_QUOTE || strippedUrl[0] == DOUBLE_QUOTE ? strippedUrl[0] : quoteFor(unquotedUrl);
    return pathOnly ? rebase(unquotedUrl, rebaseConfig) : URL_PREFIX + quote + rebase(unquotedUrl, rebaseConfig) + quote + URL_SUFFIX;
  };
  var path = (init_path(), __toCommonJS(exports_path));
  var url = (init_url(), __toCommonJS(exports_url));
  var isDataUriResource = require_is_data_uri_resource();
  var DOUBLE_QUOTE = '"';
  var SINGLE_QUOTE = "\'";
  var URL_PREFIX = "url(";
  var URL_SUFFIX = ")";
  var PROTOCOL_LESS_PREFIX_PATTERN = /^[^\w\d]*\/\//;
  var QUOTE_PREFIX_PATTERN = /^["']/;
  var QUOTE_SUFFIX_PATTERN = /["']$/;
  var ROUND_BRACKETS_PATTERN = /[\(\)]/;
  var URL_PREFIX_PATTERN = /^url\(/i;
  var URL_SUFFIX_PATTERN = /\)$/;
  var WHITESPACE_PATTERN = /\s/;
  var isWindows = process.platform == "win32";
  module.exports = rewriteUrl;
});

// node_modules/clean-css/lib/utils/is-import.js
var require_is_import = __commonJS((exports, module) => {
  var isImport = function(value) {
    return IMPORT_PREFIX_PATTERN.test(value);
  };
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  module.exports = isImport;
});

// node_modules/clean-css/lib/reader/rebase.js
var require_rebase2 = __commonJS((exports, module) => {
  var rebase = function(tokens, rebaseAll, validator, rebaseConfig) {
    return rebaseAll ? rebaseEverything(tokens, validator, rebaseConfig) : rebaseAtRules(tokens, validator, rebaseConfig);
  };
  var rebaseEverything = function(tokens, validator, rebaseConfig) {
    var token;
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          rebaseAtRule(token, validator, rebaseConfig);
          break;
        case Token.AT_RULE_BLOCK:
          rebaseProperties(token[2], validator, rebaseConfig);
          break;
        case Token.COMMENT:
          rebaseSourceMapComment(token, rebaseConfig);
          break;
        case Token.NESTED_BLOCK:
          rebaseEverything(token[2], validator, rebaseConfig);
          break;
        case Token.RULE:
          rebaseProperties(token[2], validator, rebaseConfig);
          break;
      }
    }
    return tokens;
  };
  var rebaseAtRules = function(tokens, validator, rebaseConfig) {
    var token;
    var i, l2;
    for (i = 0, l2 = tokens.length;i < l2; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          rebaseAtRule(token, validator, rebaseConfig);
          break;
      }
    }
    return tokens;
  };
  var rebaseAtRule = function(token, validator, rebaseConfig) {
    if (!isImport(token[1])) {
      return;
    }
    var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
    var newUrl = rewriteUrl(uriAndMediaQuery[0], rebaseConfig);
    var mediaQuery = uriAndMediaQuery[1];
    token[1] = restoreImport(newUrl, mediaQuery);
  };
  var rebaseSourceMapComment = function(token, rebaseConfig) {
    var matches = SOURCE_MAP_COMMENT_PATTERN.exec(token[1]);
    if (matches && matches[1].indexOf("data:") === -1) {
      token[1] = token[1].replace(matches[1], rewriteUrl(matches[1], rebaseConfig, true));
    }
  };
  var rebaseProperties = function(properties, validator, rebaseConfig) {
    var property;
    var value;
    var i, l2;
    var j2, m4;
    for (i = 0, l2 = properties.length;i < l2; i++) {
      property = properties[i];
      for (j2 = 2, m4 = property.length;j2 < m4; j2++) {
        value = property[j2][1];
        if (validator.isUrl(value)) {
          property[j2][1] = rewriteUrl(value, rebaseConfig);
        }
      }
    }
  };
  var extractImportUrlAndMedia = require_extract_import_url_and_media();
  var restoreImport = require_restore_import();
  var rewriteUrl = require_rewrite_url();
  var Token = require_token();
  var isImport = require_is_import();
  var SOURCE_MAP_COMMENT_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;
  module.exports = rebase;
});

// node_modules/clean-css/lib/tokenizer/tokenize.js
var require_tokenize = __commonJS((exports, module) => {
  var tokenize = function(source, externalContext) {
    var internalContext = {
      level: Level.BLOCK,
      position: {
        source: externalContext.source || undefined,
        line: 1,
        column: 0,
        index: 0
      }
    };
    return intoTokens(source, externalContext, internalContext, false);
  };
  var intoTokens = function(source, externalContext, internalContext, isNested) {
    var allTokens = [];
    var newTokens = allTokens;
    var lastToken;
    var ruleToken;
    var ruleTokens = [];
    var propertyToken;
    var metadata;
    var metadatas = [];
    var level = internalContext.level;
    var levels = [];
    var buffer = [];
    var buffers = [];
    var isBufferEmpty = true;
    var serializedBuffer;
    var serializedBufferPart;
    var roundBracketLevel = 0;
    var isQuoted;
    var isSpace;
    var isNewLineNix;
    var isNewLineWin;
    var isCarriageReturn;
    var isCommentStart;
    var wasCommentStart = false;
    var isCommentEnd;
    var wasCommentEnd = false;
    var isCommentEndMarker;
    var isEscaped;
    var wasEscaped = false;
    var characterWithNoSpecialMeaning;
    var isPreviousDash = false;
    var isVariable = false;
    var isRaw = false;
    var seekingValue = false;
    var seekingPropertyBlockClosing = false;
    var position = internalContext.position;
    var lastCommentStartAt;
    for (;position.index < source.length; position.index++) {
      var character = source[position.index];
      isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;
      isSpace = character == Marker.SPACE || character == Marker.TAB;
      isNewLineNix = character == Marker.NEW_LINE_NIX;
      isNewLineWin = character == Marker.NEW_LINE_NIX && source[position.index - 1] == Marker.CARRIAGE_RETURN;
      isCarriageReturn = character == Marker.CARRIAGE_RETURN && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;
      isCommentStart = !wasCommentEnd && level != Level.COMMENT && !isQuoted && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;
      isCommentEndMarker = !wasCommentStart && !isQuoted && character == Marker.FORWARD_SLASH && source[position.index - 1] == Marker.ASTERISK;
      isCommentEnd = level == Level.COMMENT && isCommentEndMarker;
      characterWithNoSpecialMeaning = !isSpace && !isCarriageReturn && (character >= "A" && character <= "Z" || character >= "a" && character <= "z" || character >= "0" && character <= "9" || character == "-");
      isVariable = isVariable || !seekingValue && isPreviousDash && character === "-";
      isPreviousDash = character === "-";
      roundBracketLevel = Math.max(roundBracketLevel, 0);
      metadata = isBufferEmpty ? [position.line, position.column, position.source] : metadata;
      if (isEscaped) {
        buffer.push(character);
        isBufferEmpty = false;
      } else if (characterWithNoSpecialMeaning) {
        buffer.push(character);
        isBufferEmpty = false;
      } else if ((isSpace || isNewLineNix && !isNewLineWin) && (isQuoted || level == Level.COMMENT)) {
        buffer.push(character);
        isBufferEmpty = false;
      } else if ((isSpace || isNewLineNix && !isNewLineWin) && isBufferEmpty) {
      } else if (!isCommentEnd && level == Level.COMMENT) {
        buffer.push(character);
        isBufferEmpty = false;
      } else if (!isCommentStart && !isCommentEnd && isRaw) {
        buffer.push(character);
        isBufferEmpty = false;
      } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {
        metadatas.push(metadata);
        buffer.push(character);
        buffers.push(buffer.slice(0, -2));
        isBufferEmpty = false;
        buffer = buffer.slice(-2);
        metadata = [position.line, position.column - 1, position.source];
        levels.push(level);
        level = Level.COMMENT;
      } else if (isCommentStart) {
        levels.push(level);
        level = Level.COMMENT;
        buffer.push(character);
        isBufferEmpty = false;
      } else if (isCommentEnd && isIgnoreStartComment(buffer)) {
        serializedBuffer = buffer.join("").trim() + character;
        lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
        newTokens.push(lastToken);
        isRaw = true;
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
        isBufferEmpty = buffer.length === 0;
      } else if (isCommentEnd && isIgnoreEndComment(buffer)) {
        serializedBuffer = buffer.join("") + character;
        lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);
        serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);
        lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
        newTokens.push(lastToken);
        serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);
        metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];
        lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
        newTokens.push(lastToken);
        isRaw = false;
        level = levels.pop();
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
        isBufferEmpty = buffer.length === 0;
      } else if (isCommentEnd) {
        serializedBuffer = buffer.join("").trim() + character;
        lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
        newTokens.push(lastToken);
        level = levels.pop();
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
        isBufferEmpty = buffer.length === 0;
      } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {
        externalContext.warnings.push("Unexpected \'*/\' at " + formatPosition([position.line, position.column, position.source]) + ".");
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
        levels.push(level);
        level = Level.SINGLE_QUOTE;
        buffer.push(character);
        isBufferEmpty = false;
      } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
        level = levels.pop();
        buffer.push(character);
        isBufferEmpty = false;
      } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
        levels.push(level);
        level = Level.DOUBLE_QUOTE;
        buffer.push(character);
        isBufferEmpty = false;
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
        level = levels.pop();
        buffer.push(character);
        isBufferEmpty = false;
      } else if (character != Marker.CLOSE_ROUND_BRACKET && character != Marker.OPEN_ROUND_BRACKET && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {
        buffer.push(character);
        isBufferEmpty = false;
      } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {
        buffer.push(character);
        isBufferEmpty = false;
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {
        buffer.push(character);
        isBufferEmpty = false;
        roundBracketLevel--;
      } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {
        serializedBuffer = buffer.join("").trim();
        allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {
        serializedBuffer = buffer.join("").trim();
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {
        buffer.push(character);
        isBufferEmpty = false;
      } else if (character == Marker.COMMA && level == Level.BLOCK) {
        ruleToken = [tokenTypeFrom(buffer), [], []];
        serializedBuffer = buffer.join("").trim();
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && ruleToken && ruleToken[0] == Token.NESTED_BLOCK) {
        serializedBuffer = buffer.join("").trim();
        ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        allTokens.push(ruleToken);
        levels.push(level);
        position.column++;
        position.index++;
        buffer = [];
        isBufferEmpty = true;
        ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
        ruleToken = null;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {
        serializedBuffer = buffer.join("").trim();
        ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];
        ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        allTokens.push(ruleToken);
        levels.push(level);
        position.column++;
        position.index++;
        buffer = [];
        isBufferEmpty = true;
        ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
        ruleToken = null;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {
        serializedBuffer = buffer.join("").trim();
        ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);
        newTokens = ruleToken[2];
        allTokens.push(ruleToken);
        levels.push(level);
        level = Level.RULE;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {
        ruleTokens.push(ruleToken);
        ruleToken = [Token.PROPERTY_BLOCK, []];
        propertyToken.push(ruleToken);
        newTokens = ruleToken[1];
        levels.push(level);
        level = Level.RULE;
        seekingValue = false;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {
        serializedBuffer = buffer.join("").trim();
        ruleTokens.push(ruleToken);
        ruleToken = [Token.AT_RULE_BLOCK, [], []];
        ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        newTokens.push(ruleToken);
        newTokens = ruleToken[2];
        levels.push(level);
        level = Level.RULE;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {
        serializedBuffer = buffer.join("").trim();
        propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];
        newTokens.push(propertyToken);
        seekingValue = true;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && ruleTokens.length > 0 && !isBufferEmpty && buffer[0] == Marker.AT) {
        serializedBuffer = buffer.join("").trim();
        ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && !isBufferEmpty) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        seekingValue = false;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty && isVariable && !propertyToken[2]) {
        propertyToken.push([Token.PROPERTY_VALUE, " ", [originalMetadata(metadata, " ", externalContext)]]);
        isVariable = false;
        propertyToken = null;
        seekingValue = false;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty) {
        propertyToken = null;
        seekingValue = false;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && !isBufferEmpty && buffer[0] == Marker.AT) {
        serializedBuffer = buffer.join("");
        newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        seekingValue = false;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {
        seekingPropertyBlockClosing = false;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && isBufferEmpty) {
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && seekingValue && !isBufferEmpty && ruleTokens.length > 0) {
        serializedBuffer = buffer.join("");
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && !isBufferEmpty && buffer[0] == Marker.AT && ruleTokens.length > 0) {
        serializedBuffer = buffer.join("");
        ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && ruleTokens.length > 0) {
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && !isBufferEmpty) {
        serializedBuffer = buffer.join("");
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && !isBufferEmpty && buffer[0] == Marker.AT) {
        propertyToken = null;
        ruleToken = null;
        serializedBuffer = buffer.join("").trim();
        newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && levels[levels.length - 1] == Level.RULE) {
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        seekingPropertyBlockClosing = true;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && isVariable && propertyToken && !propertyToken[2]) {
        propertyToken.push([Token.PROPERTY_VALUE, " ", [originalMetadata(metadata, " ", externalContext)]]);
        isVariable = false;
        propertyToken = null;
        ruleToken = null;
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {
        propertyToken = null;
        ruleToken = null;
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK && !isNested && position.index <= source.length - 1) {
        externalContext.warnings.push("Unexpected \'}\' at " + formatPosition([position.line, position.column, position.source]) + ".");
        buffer.push(character);
        isBufferEmpty = false;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {
        break;
      } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {
        buffer.push(character);
        isBufferEmpty = false;
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue && roundBracketLevel == 1) {
        buffer.push(character);
        isBufferEmpty = false;
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        roundBracketLevel--;
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {
        buffer.push(character);
        isBufferEmpty = false;
        roundBracketLevel--;
      } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue && !isBufferEmpty) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue) {
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && !isBufferEmpty) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (character == Marker.CLOSE_SQUARE_BRACKET && propertyToken && propertyToken.length > 1 && !isBufferEmpty && isRepeatToken(buffer)) {
        buffer.push(character);
        serializedBuffer = buffer.join("").trim();
        propertyToken[propertyToken.length - 1][1] += serializedBuffer;
        buffer = [];
        isBufferEmpty = true;
      } else if ((isSpace || isNewLineNix && !isNewLineWin) && level == Level.RULE && seekingValue && propertyToken && !isBufferEmpty) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
        isBufferEmpty = true;
      } else if (isNewLineWin && level == Level.RULE && seekingValue) {
        buffer = [];
        isBufferEmpty = true;
      } else if (isNewLineWin && buffer.length == 1) {
        buffer.pop();
        isBufferEmpty = buffer.length === 0;
      } else if (!isBufferEmpty || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {
        buffer.push(character);
        isBufferEmpty = false;
      }
      wasEscaped = isEscaped;
      isEscaped = !wasEscaped && character == Marker.BACK_SLASH;
      wasCommentStart = isCommentStart;
      wasCommentEnd = isCommentEnd;
      position.line = isNewLineWin || isNewLineNix || isCarriageReturn ? position.line + 1 : position.line;
      position.column = isNewLineWin || isNewLineNix || isCarriageReturn ? 0 : position.column + 1;
    }
    if (seekingValue) {
      externalContext.warnings.push("Missing \'}\' at " + formatPosition([position.line, position.column, position.source]) + ".");
    }
    if (seekingValue && buffer.length > 0) {
      serializedBuffer = buffer.join("").replace(TAIL_BROKEN_VALUE_PATTERN, "");
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      buffer = [];
    }
    if (buffer.length > 0) {
      externalContext.warnings.push("Invalid character(s) \'" + buffer.join("") + "\' at " + formatPosition(metadata) + ". Ignoring.");
    }
    return allTokens;
  };
  var isIgnoreStartComment = function(buffer) {
    return IGNORE_START_COMMENT_PATTERN.test(buffer.join("") + Marker.FORWARD_SLASH);
  };
  var isIgnoreEndComment = function(buffer) {
    return IGNORE_END_COMMENT_PATTERN.test(buffer.join("") + Marker.FORWARD_SLASH);
  };
  var originalMetadata = function(metadata, value, externalContext, selectorFallbacks) {
    var source = metadata[2];
    return externalContext.inputSourceMapTracker.isTracking(source) ? externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) : metadata;
  };
  var tokenTypeFrom = function(buffer) {
    var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;
    var ruleWord = buffer.join("").split(RULE_WORD_SEPARATOR_PATTERN)[0];
    if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {
      return Token.NESTED_BLOCK;
    } else if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {
      return Token.AT_RULE;
    } else if (isAtRule) {
      return Token.AT_RULE_BLOCK;
    } else {
      return Token.RULE;
    }
  };
  var tokenScopeFrom = function(tokenType) {
    if (tokenType == Token.RULE) {
      return Token.RULE_SCOPE;
    } else if (tokenType == Token.NESTED_BLOCK) {
      return Token.NESTED_BLOCK_SCOPE;
    } else if (tokenType == Token.AT_RULE_BLOCK) {
      return Token.AT_RULE_BLOCK_SCOPE;
    }
  };
  var isPageMarginBox = function(buffer) {
    var serializedBuffer = buffer.join("").trim();
    return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;
  };
  var isRepeatToken = function(buffer) {
    return REPEAT_PATTERN.test(buffer.join("") + Marker.CLOSE_SQUARE_BRACKET);
  };
  var Marker = require_marker();
  var Token = require_token();
  var formatPosition = require_format_position();
  var Level = {
    BLOCK: "block",
    COMMENT: "comment",
    DOUBLE_QUOTE: "double-quote",
    RULE: "rule",
    SINGLE_QUOTE: "single-quote"
  };
  var AT_RULES = [
    "@charset",
    "@import"
  ];
  var BLOCK_RULES = [
    "@-moz-document",
    "@document",
    "@-moz-keyframes",
    "@-ms-keyframes",
    "@-o-keyframes",
    "@-webkit-keyframes",
    "@keyframes",
    "@media",
    "@supports"
  ];
  var IGNORE_END_COMMENT_PATTERN = /\/\* clean\-css ignore:end \*\/$/;
  var IGNORE_START_COMMENT_PATTERN = /^\/\* clean\-css ignore:start \*\//;
  var PAGE_MARGIN_BOXES = [
    "@bottom-center",
    "@bottom-left",
    "@bottom-left-corner",
    "@bottom-right",
    "@bottom-right-corner",
    "@left-bottom",
    "@left-middle",
    "@left-top",
    "@right-bottom",
    "@right-middle",
    "@right-top",
    "@top-center",
    "@top-left",
    "@top-left-corner",
    "@top-right",
    "@top-right-corner"
  ];
  var EXTRA_PAGE_BOXES = [
    "@footnote",
    "@footnotes",
    "@left",
    "@page-float-bottom",
    "@page-float-top",
    "@right"
  ];
  var REPEAT_PATTERN = /^\[\s{0,31}\d+\s{0,31}\]$/;
  var RULE_WORD_SEPARATOR_PATTERN = /[\s\(]/;
  var TAIL_BROKEN_VALUE_PATTERN = /[\s|\}]*$/;
  module.exports = tokenize;
});

// node_modules/clean-css/lib/reader/read-sources.js
var require_read_sources = __commonJS((exports, module) => {
  var readSources = function(input, context, callback) {
    return doReadSources(input, context, function(tokens) {
      return applySourceMaps(tokens, context, function() {
        return loadOriginalSources(context, function() {
          return callback(tokens);
        });
      });
    });
  };
  var doReadSources = function(input, context, callback) {
    if (typeof input == "string") {
      return fromString(input, context, callback);
    } else if (Buffer.isBuffer(input)) {
      return fromString(input.toString(), context, callback);
    } else if (Array.isArray(input)) {
      return fromArray(input, context, callback);
    } else if (typeof input == "object") {
      return fromHash(input, context, callback);
    }
  };
  var fromString = function(input, context, callback) {
    context.source = undefined;
    context.sourcesContent[undefined] = input;
    context.stats.originalSize += input.length;
    return fromStyles(input, context, { inline: context.options.inline }, callback);
  };
  var fromArray = function(input, context, callback) {
    var inputAsImports = input.reduce(function(accumulator, uriOrHash) {
      if (typeof uriOrHash === "string") {
        return addStringSource(uriOrHash, accumulator);
      } else {
        return addHashSource(uriOrHash, context, accumulator);
      }
    }, []);
    return fromStyles(inputAsImports.join(""), context, { inline: ["all"] }, callback);
  };
  var fromHash = function(input, context, callback) {
    var inputAsImports = addHashSource(input, context, []);
    return fromStyles(inputAsImports.join(""), context, { inline: ["all"] }, callback);
  };
  var addStringSource = function(input, imports) {
    imports.push(restoreAsImport(normalizeUri(input)));
    return imports;
  };
  var addHashSource = function(input, context, imports) {
    var uri;
    var normalizedUri;
    var source;
    for (uri in input) {
      source = input[uri];
      normalizedUri = normalizeUri(uri);
      imports.push(restoreAsImport(normalizedUri));
      context.sourcesContent[normalizedUri] = source.styles;
      if (source.sourceMap) {
        trackSourceMap(source.sourceMap, normalizedUri, context);
      }
    }
    return imports;
  };
  var normalizeUri = function(uri) {
    var currentPath = path.resolve("");
    var absoluteUri;
    var relativeToCurrentPath;
    var normalizedUri;
    if (isRemoteResource(uri)) {
      return uri;
    }
    absoluteUri = path.isAbsolute(uri) ? uri : path.resolve(uri);
    relativeToCurrentPath = path.relative(currentPath, absoluteUri);
    normalizedUri = normalizePath(relativeToCurrentPath);
    return normalizedUri;
  };
  var trackSourceMap = function(sourceMap, uri, context) {
    var parsedMap = typeof sourceMap == "string" ? JSON.parse(sourceMap) : sourceMap;
    var rebasedMap = isRemoteResource(uri) ? rebaseRemoteMap(parsedMap, uri) : rebaseLocalMap(parsedMap, uri || UNKNOWN_URI, context.options.rebaseTo);
    context.inputSourceMapTracker.track(uri, rebasedMap);
  };
  var restoreAsImport = function(uri) {
    return restoreImport("url(" + uri + ")", "") + Marker.SEMICOLON;
  };
  var fromStyles = function(styles, context, parentInlinerContext, callback) {
    var tokens;
    var rebaseConfig = {};
    if (!context.source) {
      rebaseConfig.fromBase = path.resolve("");
      rebaseConfig.toBase = context.options.rebaseTo;
    } else if (isRemoteResource(context.source)) {
      rebaseConfig.fromBase = context.source;
      rebaseConfig.toBase = context.source;
    } else if (path.isAbsolute(context.source)) {
      rebaseConfig.fromBase = path.dirname(context.source);
      rebaseConfig.toBase = context.options.rebaseTo;
    } else {
      rebaseConfig.fromBase = path.dirname(path.resolve(context.source));
      rebaseConfig.toBase = context.options.rebaseTo;
    }
    tokens = tokenize(styles, context);
    tokens = rebase(tokens, context.options.rebase, context.validator, rebaseConfig);
    return allowsAnyImports(parentInlinerContext.inline) ? inline(tokens, context, parentInlinerContext, callback) : callback(tokens);
  };
  var allowsAnyImports = function(inline2) {
    return !(inline2.length == 1 && inline2[0] == "none");
  };
  var inline = function(tokens, externalContext, parentInlinerContext, callback) {
    var inlinerContext = {
      afterContent: false,
      callback,
      errors: externalContext.errors,
      externalContext,
      fetch: externalContext.options.fetch,
      inlinedStylesheets: parentInlinerContext.inlinedStylesheets || externalContext.inlinedStylesheets,
      inline: parentInlinerContext.inline,
      inlineRequest: externalContext.options.inlineRequest,
      inlineTimeout: externalContext.options.inlineTimeout,
      isRemote: parentInlinerContext.isRemote || false,
      localOnly: externalContext.localOnly,
      outputTokens: [],
      rebaseTo: externalContext.options.rebaseTo,
      sourceTokens: tokens,
      warnings: externalContext.warnings
    };
    return doInlineImports(inlinerContext);
  };
  var doInlineImports = function(inlinerContext) {
    var token;
    var i, l2;
    for (i = 0, l2 = inlinerContext.sourceTokens.length;i < l2; i++) {
      token = inlinerContext.sourceTokens[i];
      if (token[0] == Token.AT_RULE && isImport(token[1])) {
        inlinerContext.sourceTokens.splice(0, i);
        return inlineStylesheet(token, inlinerContext);
      } else if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {
        inlinerContext.outputTokens.push(token);
      } else {
        inlinerContext.outputTokens.push(token);
        inlinerContext.afterContent = true;
      }
    }
    inlinerContext.sourceTokens = [];
    return inlinerContext.callback(inlinerContext.outputTokens);
  };
  var inlineStylesheet = function(token, inlinerContext) {
    var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
    var uri = uriAndMediaQuery[0];
    var mediaQuery = uriAndMediaQuery[1];
    var metadata = token[2];
    return isRemoteResource(uri) ? inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) : inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext);
  };
  var inlineRemoteStylesheet = function(uri, mediaQuery, metadata, inlinerContext) {
    var isAllowed = isAllowedResource(uri, true, inlinerContext.inline);
    var originalUri = uri;
    var isLoaded = uri in inlinerContext.externalContext.sourcesContent;
    var isRuntimeResource = !hasProtocol(uri);
    if (inlinerContext.inlinedStylesheets.indexOf(uri) > -1) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as it has already been imported.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (inlinerContext.localOnly && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as no callback given and after other content.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (isRuntimeResource) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no protocol given.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (inlinerContext.localOnly && !isLoaded) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no callback given.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (!isAllowed && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as resource is not allowed and after other content.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (!isAllowed) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as resource is not allowed.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    }
    inlinerContext.inlinedStylesheets.push(uri);
    function whenLoaded(error, importedStyles) {
      if (error) {
        inlinerContext.errors.push('Broken @import declaration of "' + uri + '" - ' + error);
        return process.nextTick(function() {
          inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
          inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
          doInlineImports(inlinerContext);
        });
      }
      inlinerContext.inline = inlinerContext.externalContext.options.inline;
      inlinerContext.isRemote = true;
      inlinerContext.externalContext.source = originalUri;
      inlinerContext.externalContext.sourcesContent[uri] = importedStyles;
      inlinerContext.externalContext.stats.originalSize += importedStyles.length;
      return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function(importedTokens) {
        importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);
        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
        return doInlineImports(inlinerContext);
      });
    }
    return isLoaded ? whenLoaded(null, inlinerContext.externalContext.sourcesContent[uri]) : inlinerContext.fetch(uri, inlinerContext.inlineRequest, inlinerContext.inlineTimeout, whenLoaded);
  };
  var inlineLocalStylesheet = function(uri, mediaQuery, metadata, inlinerContext) {
    var currentPath = path.resolve("");
    var absoluteUri = path.isAbsolute(uri) ? path.resolve(currentPath, uri[0] == "/" ? uri.substring(1) : uri) : path.resolve(inlinerContext.rebaseTo, uri);
    var relativeToCurrentPath = path.relative(currentPath, absoluteUri);
    var importedStyles;
    var isAllowed = isAllowedResource(uri, false, inlinerContext.inline);
    var normalizedPath = normalizePath(relativeToCurrentPath);
    var isLoaded = normalizedPath in inlinerContext.externalContext.sourcesContent;
    if (inlinerContext.inlinedStylesheets.indexOf(absoluteUri) > -1) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as it has already been imported.');
    } else if (isAllowed && !isLoaded && (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile())) {
      inlinerContext.errors.push('Ignoring local @import of "' + uri + '" as resource is missing.');
    } else if (!isAllowed && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as resource is not allowed and after other content.');
    } else if (inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as after other content.');
    } else if (!isAllowed) {
      inlinerContext.warnings.push('Skipping local @import of "' + uri + '" as resource is not allowed.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
    } else {
      importedStyles = isLoaded ? inlinerContext.externalContext.sourcesContent[normalizedPath] : fs.readFileSync(absoluteUri, "utf-8");
      inlinerContext.inlinedStylesheets.push(absoluteUri);
      inlinerContext.inline = inlinerContext.externalContext.options.inline;
      inlinerContext.externalContext.source = normalizedPath;
      inlinerContext.externalContext.sourcesContent[normalizedPath] = importedStyles;
      inlinerContext.externalContext.stats.originalSize += importedStyles.length;
      return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function(importedTokens) {
        importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);
        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
        return doInlineImports(inlinerContext);
      });
    }
    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
    return doInlineImports(inlinerContext);
  };
  var wrapInMedia = function(tokens, mediaQuery, metadata) {
    if (mediaQuery) {
      return [[Token.NESTED_BLOCK, [[Token.NESTED_BLOCK_SCOPE, "@media " + mediaQuery, metadata]], tokens]];
    } else {
      return tokens;
    }
  };
  var fs = (()=>({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var applySourceMaps = require_apply_source_maps();
  var extractImportUrlAndMedia = require_extract_import_url_and_media();
  var isAllowedResource = require_is_allowed_resource();
  var loadOriginalSources = require_load_original_sources();
  var normalizePath = require_normalize_path();
  var rebase = require_rebase2();
  var rebaseLocalMap = require_rebase_local_map();
  var rebaseRemoteMap = require_rebase_remote_map();
  var restoreImport = require_restore_import();
  var tokenize = require_tokenize();
  var Token = require_token();
  var Marker = require_marker();
  var hasProtocol = require_has_protocol();
  var isImport = require_is_import();
  var isRemoteResource = require_is_remote_resource();
  var UNKNOWN_URI = "uri:unknown";
  module.exports = readSources;
});

// node_modules/clean-css/lib/writer/simple.js
var require_simple = __commonJS((exports, module) => {
  var store = function(serializeContext, token) {
    var value = typeof token == "string" ? token : token[1];
    var wrap2 = serializeContext.wrap;
    wrap2(serializeContext, value);
    track(serializeContext, value);
    serializeContext.output.push(value);
  };
  var wrap = function(serializeContext, value) {
    if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
      track(serializeContext, serializeContext.format.breakWith);
      serializeContext.output.push(serializeContext.format.breakWith);
    }
  };
  var track = function(serializeContext, value) {
    var parts = value.split("\n");
    serializeContext.line += parts.length - 1;
    serializeContext.column = parts.length > 1 ? 0 : serializeContext.column + parts.pop().length;
  };
  var serializeStyles = function(tokens, context) {
    var serializeContext = {
      column: 0,
      format: context.options.format,
      indentBy: 0,
      indentWith: "",
      line: 1,
      output: [],
      spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
      store,
      wrap: context.options.format.wrapAt ? wrap : function() {
      }
    };
    all2(serializeContext, tokens);
    return {
      styles: serializeContext.output.join("")
    };
  };
  var all2 = require_helpers().all;
  module.exports = serializeStyles;
});

// node_modules/clean-css/lib/writer/source-maps.js
var require_source_maps = __commonJS((exports, module) => {
  var store = function(serializeContext, element) {
    var fromString = typeof element == "string";
    var value = fromString ? element : element[1];
    var mappings = fromString ? null : element[2];
    var wrap2 = serializeContext.wrap;
    wrap2(serializeContext, value);
    track(serializeContext, value, mappings);
    serializeContext.output.push(value);
  };
  var wrap = function(serializeContext, value) {
    if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
      track(serializeContext, serializeContext.format.breakWith, false);
      serializeContext.output.push(serializeContext.format.breakWith);
    }
  };
  var track = function(serializeContext, value, mappings) {
    var parts = value.split("\n");
    if (mappings) {
      trackAllMappings(serializeContext, mappings);
    }
    serializeContext.line += parts.length - 1;
    serializeContext.column = parts.length > 1 ? 0 : serializeContext.column + parts.pop().length;
  };
  var trackAllMappings = function(serializeContext, mappings) {
    for (var i = 0, l2 = mappings.length;i < l2; i++) {
      trackMapping(serializeContext, mappings[i]);
    }
  };
  var trackMapping = function(serializeContext, mapping) {
    var line = mapping[0];
    var column = mapping[1];
    var originalSource = mapping[2];
    var source = originalSource;
    var storedSource = source || UNKNOWN_SOURCE;
    if (isWindows && source && !isRemoteResource(source)) {
      storedSource = source.replace(NIX_SEPARATOR_PATTERN, WINDOWS_SEPARATOR);
    }
    serializeContext.outputMap.addMapping({
      generated: {
        line: serializeContext.line,
        column: serializeContext.column
      },
      source: storedSource,
      original: {
        line,
        column
      }
    });
    if (serializeContext.inlineSources && originalSource in serializeContext.sourcesContent) {
      serializeContext.outputMap.setSourceContent(storedSource, serializeContext.sourcesContent[originalSource]);
    }
  };
  var serializeStylesAndSourceMap = function(tokens, context) {
    var serializeContext = {
      column: 0,
      format: context.options.format,
      indentBy: 0,
      indentWith: "",
      inlineSources: context.options.sourceMapInlineSources,
      line: 1,
      output: [],
      outputMap: new SourceMapGenerator,
      sourcesContent: context.sourcesContent,
      spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
      store,
      wrap: context.options.format.wrapAt ? wrap : function() {
      }
    };
    all2(serializeContext, tokens);
    return {
      sourceMap: serializeContext.outputMap,
      styles: serializeContext.output.join("")
    };
  };
  var SourceMapGenerator = require_source_map().SourceMapGenerator;
  var all2 = require_helpers().all;
  var isRemoteResource = require_is_remote_resource();
  var isWindows = process.platform == "win32";
  var NIX_SEPARATOR_PATTERN = /\//g;
  var UNKNOWN_SOURCE = "$stdin";
  var WINDOWS_SEPARATOR = "\\";
  module.exports = serializeStylesAndSourceMap;
});

// node_modules/clean-css/lib/clean.js
var require_clean = __commonJS((exports, module) => {
  var minifyAll = function(input, options, maybeSourceMap, maybeCallback) {
    if (options.batch && Array.isArray(input)) {
      return minifyInBatchesFromArray(input, options, maybeSourceMap, maybeCallback);
    } else if (options.batch && typeof input == "object") {
      return minifyInBatchesFromHash(input, options, maybeSourceMap, maybeCallback);
    } else {
      return minify2(input, options, maybeSourceMap, maybeCallback);
    }
  };
  var minifyInBatchesFromArray = function(input, options, maybeSourceMap, maybeCallback) {
    var callback = typeof maybeCallback == "function" ? maybeCallback : typeof maybeSourceMap == "function" ? maybeSourceMap : null;
    var errors = [];
    var outputAsHash = {};
    var inputValue;
    var i, l2;
    function whenHashBatchDone(innerErrors, output) {
      outputAsHash = Object.assign(outputAsHash, output);
      if (innerErrors !== null) {
        errors = errors.concat(innerErrors);
      }
    }
    for (i = 0, l2 = input.length;i < l2; i++) {
      if (typeof input[i] == "object") {
        minifyInBatchesFromHash(input[i], options, whenHashBatchDone);
      } else {
        inputValue = input[i];
        outputAsHash[inputValue] = minify2([inputValue], options);
        errors = errors.concat(outputAsHash[inputValue].errors);
      }
    }
    return callback ? callback(errors.length > 0 ? errors : null, outputAsHash) : outputAsHash;
  };
  var minifyInBatchesFromHash = function(input, options, maybeSourceMap, maybeCallback) {
    var callback = typeof maybeCallback == "function" ? maybeCallback : typeof maybeSourceMap == "function" ? maybeSourceMap : null;
    var errors = [];
    var outputAsHash = {};
    var inputKey;
    var inputValue;
    for (inputKey in input) {
      inputValue = input[inputKey];
      outputAsHash[inputKey] = minify2(inputValue.styles, options, inputValue.sourceMap);
      errors = errors.concat(outputAsHash[inputKey].errors);
    }
    return callback ? callback(errors.length > 0 ? errors : null, outputAsHash) : outputAsHash;
  };
  var minify2 = function(input, options, maybeSourceMap, maybeCallback) {
    var sourceMap = typeof maybeSourceMap != "function" ? maybeSourceMap : null;
    var callback = typeof maybeCallback == "function" ? maybeCallback : typeof maybeSourceMap == "function" ? maybeSourceMap : null;
    var context = {
      stats: {
        efficiency: 0,
        minifiedSize: 0,
        originalSize: 0,
        startedAt: Date.now(),
        timeSpent: 0
      },
      cache: {
        specificity: {}
      },
      errors: [],
      inlinedStylesheets: [],
      inputSourceMapTracker: inputSourceMapTracker(),
      localOnly: !callback,
      options,
      source: null,
      sourcesContent: {},
      validator: validator(options.compatibility),
      warnings: []
    };
    var implicitRebaseToWarning;
    if (sourceMap) {
      context.inputSourceMapTracker.track(undefined, sourceMap);
    }
    if (options.rebase && !options.explicitRebaseTo) {
      implicitRebaseToWarning = "You have set `rebase: true` without giving `rebaseTo` option, which, in this case, defaults to the current working directory. You are then warned this can lead to unexpected URL rebasing (aka here be dragons)! If you are OK with the clean-css output, then you can get rid of this warning by giving clean-css a `rebaseTo: process.cwd()` option.";
      context.warnings.push(implicitRebaseToWarning);
    }
    return runner(context.localOnly)(function() {
      return readSources(input, context, function(tokens) {
        var serialize = context.options.sourceMap ? serializeStylesAndSourceMap : serializeStyles;
        var optimizedTokens = optimize(tokens, context);
        var optimizedStyles = serialize(optimizedTokens, context);
        var output = withMetadata(optimizedStyles, context);
        return callback ? callback(context.errors.length > 0 ? context.errors : null, output) : output;
      });
    });
  };
  var runner = function(localOnly) {
    return localOnly ? function(callback) {
      return callback();
    } : process.nextTick;
  };
  var optimize = function(tokens, context) {
    var optimized = level0Optimize(tokens, context);
    optimized = OptimizationLevel.One in context.options.level ? level1Optimize(tokens, context) : tokens;
    optimized = OptimizationLevel.Two in context.options.level ? level2Optimize(tokens, context, true) : optimized;
    return optimized;
  };
  var withMetadata = function(output, context) {
    output.stats = calculateStatsFrom(output.styles, context);
    output.errors = context.errors;
    output.inlinedStylesheets = context.inlinedStylesheets;
    output.warnings = context.warnings;
    return output;
  };
  var calculateStatsFrom = function(styles, context) {
    var finishedAt = Date.now();
    var timeSpent = finishedAt - context.stats.startedAt;
    delete context.stats.startedAt;
    context.stats.timeSpent = timeSpent;
    context.stats.efficiency = 1 - styles.length / context.stats.originalSize;
    context.stats.minifiedSize = styles.length;
    return context.stats;
  };
  var level0Optimize = require_optimize();
  var level1Optimize = require_optimize2();
  var level2Optimize = require_optimize4();
  var validator = require_validator();
  var compatibilityFrom = require_compatibility();
  var fetchFrom = require_fetch();
  var formatFrom = require_format().formatFrom;
  var inlineFrom = require_inline();
  var inlineRequestFrom = require_inline_request();
  var inlineTimeoutFrom = require_inline_timeout();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var optimizationLevelFrom = require_optimization_level().optimizationLevelFrom;
  var pluginsFrom = require_plugins();
  var rebaseFrom = require_rebase();
  var rebaseToFrom = require_rebase_to();
  var inputSourceMapTracker = require_input_source_map_tracker();
  var readSources = require_read_sources();
  var serializeStyles = require_simple();
  var serializeStylesAndSourceMap = require_source_maps();
  var CleanCSS = module.exports = function CleanCSS(options) {
    options = options || {};
    this.options = {
      batch: !!options.batch,
      compatibility: compatibilityFrom(options.compatibility),
      explicitRebaseTo: "rebaseTo" in options,
      fetch: fetchFrom(options.fetch),
      format: formatFrom(options.format),
      inline: inlineFrom(options.inline),
      inlineRequest: inlineRequestFrom(options.inlineRequest),
      inlineTimeout: inlineTimeoutFrom(options.inlineTimeout),
      level: optimizationLevelFrom(options.level),
      plugins: pluginsFrom(options.plugins),
      rebase: rebaseFrom(options.rebase, options.rebaseTo),
      rebaseTo: rebaseToFrom(options.rebaseTo),
      returnPromise: !!options.returnPromise,
      sourceMap: !!options.sourceMap,
      sourceMapInlineSources: !!options.sourceMapInlineSources
    };
  };
  CleanCSS.process = function(input, opts) {
    var cleanCss;
    var optsTo = opts.to;
    delete opts.to;
    cleanCss = new CleanCSS(Object.assign({ returnPromise: true, rebaseTo: optsTo }, opts));
    return cleanCss.minify(input).then(function(output) {
      return { css: output.styles };
    });
  };
  CleanCSS.prototype.minify = function(input, maybeSourceMap, maybeCallback) {
    var options = this.options;
    if (options.returnPromise) {
      return new Promise(function(resolve, reject) {
        minifyAll(input, options, maybeSourceMap, function(errors, output) {
          return errors ? reject(errors) : resolve(output);
        });
      });
    } else {
      return minifyAll(input, options, maybeSourceMap, maybeCallback);
    }
  };
});

// node_modules/he/he.js
var require_he = __commonJS((exports, module) => {
  /*! https://mths.be/he v1.2.0 by @mathias | MIT license */
  (function(root) {
    var freeExports = typeof exports == "object" && exports;
    var freeModule = typeof module == "object" && module && exports == freeExports && module;
    var freeGlobal = typeof global == "object" && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
      root = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm", "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "\t": "Tab", "\n": "NewLine", "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "emsp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", _: "lowbar", "\u2010": "dash", "\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "\'": "apos", "\u2018": "lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang", "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "para", "@": "commat", "*": "ast", "/": "sol", undefined: null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk", "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota", "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nrarrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft", "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "rarrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu", "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "neArr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb", "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times", "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "frasl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint", "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot", "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac", "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest", "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge", "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "gg", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsim", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde", "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube", "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "NotSquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcaps", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odot", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup", "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lnsim", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot", "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrktbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul", "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr", "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU", "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xcirc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf", "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xhArr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr", "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "DownArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "harrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBar", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeftTeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr", "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "subrarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah", "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangleBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "capbrcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equivDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ges", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "pre", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supdot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE", "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe", "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "forkv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "cent", $: "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\uD835\uDCB6": "ascr", "\uD835\uDD52": "aopf", "\uD835\uDD1E": "afr", "\uD835\uDD38": "Aopf", "\uD835\uDD04": "Afr", "\uD835\uDC9C": "Ascr", "\xAA": "ordf", "\xE1": "aacute", "\xC1": "Aacute", "\xE0": "agrave", "\xC0": "Agrave", "\u0103": "abreve", "\u0102": "Abreve", "\xE2": "acirc", "\xC2": "Acirc", "\xE5": "aring", "\xC5": "angst", "\xE4": "auml", "\xC4": "Auml", "\xE3": "atilde", "\xC3": "Atilde", "\u0105": "aogon", "\u0104": "Aogon", "\u0101": "amacr", "\u0100": "Amacr", "\xE6": "aelig", "\xC6": "AElig", "\uD835\uDCB7": "bscr", "\uD835\uDD53": "bopf", "\uD835\uDD1F": "bfr", "\uD835\uDD39": "Bopf", "\u212C": "Bscr", "\uD835\uDD05": "Bfr", "\uD835\uDD20": "cfr", "\uD835\uDCB8": "cscr", "\uD835\uDD54": "copf", "\u212D": "Cfr", "\uD835\uDC9E": "Cscr", "\u2102": "Copf", "\u0107": "cacute", "\u0106": "Cacute", "\u0109": "ccirc", "\u0108": "Ccirc", "\u010D": "ccaron", "\u010C": "Ccaron", "\u010B": "cdot", "\u010A": "Cdot", "\xE7": "ccedil", "\xC7": "Ccedil", "\u2105": "incare", "\uD835\uDD21": "dfr", "\u2146": "dd", "\uD835\uDD55": "dopf", "\uD835\uDCB9": "dscr", "\uD835\uDC9F": "Dscr", "\uD835\uDD07": "Dfr", "\u2145": "DD", "\uD835\uDD3B": "Dopf", "\u010F": "dcaron", "\u010E": "Dcaron", "\u0111": "dstrok", "\u0110": "Dstrok", "\xF0": "eth", "\xD0": "ETH", "\u2147": "ee", "\u212F": "escr", "\uD835\uDD22": "efr", "\uD835\uDD56": "eopf", "\u2130": "Escr", "\uD835\uDD08": "Efr", "\uD835\uDD3C": "Eopf", "\xE9": "eacute", "\xC9": "Eacute", "\xE8": "egrave", "\xC8": "Egrave", "\xEA": "ecirc", "\xCA": "Ecirc", "\u011B": "ecaron", "\u011A": "Ecaron", "\xEB": "euml", "\xCB": "Euml", "\u0117": "edot", "\u0116": "Edot", "\u0119": "eogon", "\u0118": "Eogon", "\u0113": "emacr", "\u0112": "Emacr", "\uD835\uDD23": "ffr", "\uD835\uDD57": "fopf", "\uD835\uDCBB": "fscr", "\uD835\uDD09": "Ffr", "\uD835\uDD3D": "Fopf", "\u2131": "Fscr", "\uFB00": "fflig", "\uFB03": "ffilig", "\uFB04": "ffllig", "\uFB01": "filig", fj: "fjlig", "\uFB02": "fllig", "\u0192": "fnof", "\u210A": "gscr", "\uD835\uDD58": "gopf", "\uD835\uDD24": "gfr", "\uD835\uDCA2": "Gscr", "\uD835\uDD3E": "Gopf", "\uD835\uDD0A": "Gfr", "\u01F5": "gacute", "\u011F": "gbreve", "\u011E": "Gbreve", "\u011D": "gcirc", "\u011C": "Gcirc", "\u0121": "gdot", "\u0120": "Gdot", "\u0122": "Gcedil", "\uD835\uDD25": "hfr", "\u210E": "planckh", "\uD835\uDCBD": "hscr", "\uD835\uDD59": "hopf", "\u210B": "Hscr", "\u210C": "Hfr", "\u210D": "Hopf", "\u0125": "hcirc", "\u0124": "Hcirc", "\u210F": "hbar", "\u0127": "hstrok", "\u0126": "Hstrok", "\uD835\uDD5A": "iopf", "\uD835\uDD26": "ifr", "\uD835\uDCBE": "iscr", "\u2148": "ii", "\uD835\uDD40": "Iopf", "\u2110": "Iscr", "\u2111": "Im", "\xED": "iacute", "\xCD": "Iacute", "\xEC": "igrave", "\xCC": "Igrave", "\xEE": "icirc", "\xCE": "Icirc", "\xEF": "iuml", "\xCF": "Iuml", "\u0129": "itilde", "\u0128": "Itilde", "\u0130": "Idot", "\u012F": "iogon", "\u012E": "Iogon", "\u012B": "imacr", "\u012A": "Imacr", "\u0133": "ijlig", "\u0132": "IJlig", "\u0131": "imath", "\uD835\uDCBF": "jscr", "\uD835\uDD5B": "jopf", "\uD835\uDD27": "jfr", "\uD835\uDCA5": "Jscr", "\uD835\uDD0D": "Jfr", "\uD835\uDD41": "Jopf", "\u0135": "jcirc", "\u0134": "Jcirc", "\u0237": "jmath", "\uD835\uDD5C": "kopf", "\uD835\uDCC0": "kscr", "\uD835\uDD28": "kfr", "\uD835\uDCA6": "Kscr", "\uD835\uDD42": "Kopf", "\uD835\uDD0E": "Kfr", "\u0137": "kcedil", "\u0136": "Kcedil", "\uD835\uDD29": "lfr", "\uD835\uDCC1": "lscr", "\u2113": "ell", "\uD835\uDD5D": "lopf", "\u2112": "Lscr", "\uD835\uDD0F": "Lfr", "\uD835\uDD43": "Lopf", "\u013A": "lacute", "\u0139": "Lacute", "\u013E": "lcaron", "\u013D": "Lcaron", "\u013C": "lcedil", "\u013B": "Lcedil", "\u0142": "lstrok", "\u0141": "Lstrok", "\u0140": "lmidot", "\u013F": "Lmidot", "\uD835\uDD2A": "mfr", "\uD835\uDD5E": "mopf", "\uD835\uDCC2": "mscr", "\uD835\uDD10": "Mfr", "\uD835\uDD44": "Mopf", "\u2133": "Mscr", "\uD835\uDD2B": "nfr", "\uD835\uDD5F": "nopf", "\uD835\uDCC3": "nscr", "\u2115": "Nopf", "\uD835\uDCA9": "Nscr", "\uD835\uDD11": "Nfr", "\u0144": "nacute", "\u0143": "Nacute", "\u0148": "ncaron", "\u0147": "Ncaron", "\xF1": "ntilde", "\xD1": "Ntilde", "\u0146": "ncedil", "\u0145": "Ncedil", "\u2116": "numero", "\u014B": "eng", "\u014A": "ENG", "\uD835\uDD60": "oopf", "\uD835\uDD2C": "ofr", "\u2134": "oscr", "\uD835\uDCAA": "Oscr", "\uD835\uDD12": "Ofr", "\uD835\uDD46": "Oopf", "\xBA": "ordm", "\xF3": "oacute", "\xD3": "Oacute", "\xF2": "ograve", "\xD2": "Ograve", "\xF4": "ocirc", "\xD4": "Ocirc", "\xF6": "ouml", "\xD6": "Ouml", "\u0151": "odblac", "\u0150": "Odblac", "\xF5": "otilde", "\xD5": "Otilde", "\xF8": "oslash", "\xD8": "Oslash", "\u014D": "omacr", "\u014C": "Omacr", "\u0153": "oelig", "\u0152": "OElig", "\uD835\uDD2D": "pfr", "\uD835\uDCC5": "pscr", "\uD835\uDD61": "popf", "\u2119": "Popf", "\uD835\uDD13": "Pfr", "\uD835\uDCAB": "Pscr", "\uD835\uDD62": "qopf", "\uD835\uDD2E": "qfr", "\uD835\uDCC6": "qscr", "\uD835\uDCAC": "Qscr", "\uD835\uDD14": "Qfr", "\u211A": "Qopf", "\u0138": "kgreen", "\uD835\uDD2F": "rfr", "\uD835\uDD63": "ropf", "\uD835\uDCC7": "rscr", "\u211B": "Rscr", "\u211C": "Re", "\u211D": "Ropf", "\u0155": "racute", "\u0154": "Racute", "\u0159": "rcaron", "\u0158": "Rcaron", "\u0157": "rcedil", "\u0156": "Rcedil", "\uD835\uDD64": "sopf", "\uD835\uDCC8": "sscr", "\uD835\uDD30": "sfr", "\uD835\uDD4A": "Sopf", "\uD835\uDD16": "Sfr", "\uD835\uDCAE": "Sscr", "\u24C8": "oS", "\u015B": "sacute", "\u015A": "Sacute", "\u015D": "scirc", "\u015C": "Scirc", "\u0161": "scaron", "\u0160": "Scaron", "\u015F": "scedil", "\u015E": "Scedil", "\xDF": "szlig", "\uD835\uDD31": "tfr", "\uD835\uDCC9": "tscr", "\uD835\uDD65": "topf", "\uD835\uDCAF": "Tscr", "\uD835\uDD17": "Tfr", "\uD835\uDD4B": "Topf", "\u0165": "tcaron", "\u0164": "Tcaron", "\u0163": "tcedil", "\u0162": "Tcedil", "\u2122": "trade", "\u0167": "tstrok", "\u0166": "Tstrok", "\uD835\uDCCA": "uscr", "\uD835\uDD66": "uopf", "\uD835\uDD32": "ufr", "\uD835\uDD4C": "Uopf", "\uD835\uDD18": "Ufr", "\uD835\uDCB0": "Uscr", "\xFA": "uacute", "\xDA": "Uacute", "\xF9": "ugrave", "\xD9": "Ugrave", "\u016D": "ubreve", "\u016C": "Ubreve", "\xFB": "ucirc", "\xDB": "Ucirc", "\u016F": "uring", "\u016E": "Uring", "\xFC": "uuml", "\xDC": "Uuml", "\u0171": "udblac", "\u0170": "Udblac", "\u0169": "utilde", "\u0168": "Utilde", "\u0173": "uogon", "\u0172": "Uogon", "\u016B": "umacr", "\u016A": "Umacr", "\uD835\uDD33": "vfr", "\uD835\uDD67": "vopf", "\uD835\uDCCB": "vscr", "\uD835\uDD19": "Vfr", "\uD835\uDD4D": "Vopf", "\uD835\uDCB1": "Vscr", "\uD835\uDD68": "wopf", "\uD835\uDCCC": "wscr", "\uD835\uDD34": "wfr", "\uD835\uDCB2": "Wscr", "\uD835\uDD4E": "Wopf", "\uD835\uDD1A": "Wfr", "\u0175": "wcirc", "\u0174": "Wcirc", "\uD835\uDD35": "xfr", "\uD835\uDCCD": "xscr", "\uD835\uDD69": "xopf", "\uD835\uDD4F": "Xopf", "\uD835\uDD1B": "Xfr", "\uD835\uDCB3": "Xscr", "\uD835\uDD36": "yfr", "\uD835\uDCCE": "yscr", "\uD835\uDD6A": "yopf", "\uD835\uDCB4": "Yscr", "\uD835\uDD1C": "Yfr", "\uD835\uDD50": "Yopf", "\xFD": "yacute", "\xDD": "Yacute", "\u0177": "ycirc", "\u0176": "Ycirc", "\xFF": "yuml", "\u0178": "Yuml", "\uD835\uDCCF": "zscr", "\uD835\uDD37": "zfr", "\uD835\uDD6B": "zopf", "\u2128": "Zfr", "\u2124": "Zopf", "\uD835\uDCB5": "Zscr", "\u017A": "zacute", "\u0179": "Zacute", "\u017E": "zcaron", "\u017D": "Zcaron", "\u017C": "zdot", "\u017B": "Zdot", "\u01B5": "imped", "\xFE": "thorn", "\xDE": "THORN", "\u0149": "napos", "\u03B1": "alpha", "\u0391": "Alpha", "\u03B2": "beta", "\u0392": "Beta", "\u03B3": "gamma", "\u0393": "Gamma", "\u03B4": "delta", "\u0394": "Delta", "\u03B5": "epsi", "\u03F5": "epsiv", "\u0395": "Epsilon", "\u03DD": "gammad", "\u03DC": "Gammad", "\u03B6": "zeta", "\u0396": "Zeta", "\u03B7": "eta", "\u0397": "Eta", "\u03B8": "theta", "\u03D1": "thetav", "\u0398": "Theta", "\u03B9": "iota", "\u0399": "Iota", "\u03BA": "kappa", "\u03F0": "kappav", "\u039A": "Kappa", "\u03BB": "lambda", "\u039B": "Lambda", "\u03BC": "mu", "\xB5": "micro", "\u039C": "Mu", "\u03BD": "nu", "\u039D": "Nu", "\u03BE": "xi", "\u039E": "Xi", "\u03BF": "omicron", "\u039F": "Omicron", "\u03C0": "pi", "\u03D6": "piv", "\u03A0": "Pi", "\u03C1": "rho", "\u03F1": "rhov", "\u03A1": "Rho", "\u03C3": "sigma", "\u03A3": "Sigma", "\u03C2": "sigmaf", "\u03C4": "tau", "\u03A4": "Tau", "\u03C5": "upsi", "\u03A5": "Upsilon", "\u03D2": "Upsi", "\u03C6": "phi", "\u03D5": "phiv", "\u03A6": "Phi", "\u03C7": "chi", "\u03A7": "Chi", "\u03C8": "psi", "\u03A8": "Psi", "\u03C9": "omega", "\u03A9": "ohm", "\u0430": "acy", "\u0410": "Acy", "\u0431": "bcy", "\u0411": "Bcy", "\u0432": "vcy", "\u0412": "Vcy", "\u0433": "gcy", "\u0413": "Gcy", "\u0453": "gjcy", "\u0403": "GJcy", "\u0434": "dcy", "\u0414": "Dcy", "\u0452": "djcy", "\u0402": "DJcy", "\u0435": "iecy", "\u0415": "IEcy", "\u0451": "iocy", "\u0401": "IOcy", "\u0454": "jukcy", "\u0404": "Jukcy", "\u0436": "zhcy", "\u0416": "ZHcy", "\u0437": "zcy", "\u0417": "Zcy", "\u0455": "dscy", "\u0405": "DScy", "\u0438": "icy", "\u0418": "Icy", "\u0456": "iukcy", "\u0406": "Iukcy", "\u0457": "yicy", "\u0407": "YIcy", "\u0439": "jcy", "\u0419": "Jcy", "\u0458": "jsercy", "\u0408": "Jsercy", "\u043A": "kcy", "\u041A": "Kcy", "\u045C": "kjcy", "\u040C": "KJcy", "\u043B": "lcy", "\u041B": "Lcy", "\u0459": "ljcy", "\u0409": "LJcy", "\u043C": "mcy", "\u041C": "Mcy", "\u043D": "ncy", "\u041D": "Ncy", "\u045A": "njcy", "\u040A": "NJcy", "\u043E": "ocy", "\u041E": "Ocy", "\u043F": "pcy", "\u041F": "Pcy", "\u0440": "rcy", "\u0420": "Rcy", "\u0441": "scy", "\u0421": "Scy", "\u0442": "tcy", "\u0422": "Tcy", "\u045B": "tshcy", "\u040B": "TSHcy", "\u0443": "ucy", "\u0423": "Ucy", "\u045E": "ubrcy", "\u040E": "Ubrcy", "\u0444": "fcy", "\u0424": "Fcy", "\u0445": "khcy", "\u0425": "KHcy", "\u0446": "tscy", "\u0426": "TScy", "\u0447": "chcy", "\u0427": "CHcy", "\u045F": "dzcy", "\u040F": "DZcy", "\u0448": "shcy", "\u0428": "SHcy", "\u0449": "shchcy", "\u0429": "SHCHcy", "\u044A": "hardcy", "\u042A": "HARDcy", "\u044B": "ycy", "\u042B": "Ycy", "\u044C": "softcy", "\u042C": "SOFTcy", "\u044D": "ecy", "\u042D": "Ecy", "\u044E": "yucy", "\u042E": "YUcy", "\u044F": "yacy", "\u042F": "YAcy", "\u2135": "aleph", "\u2136": "beth", "\u2137": "gimel", "\u2138": "daleth" };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
      '"': "&quot;",
      "&": "&amp;",
      "\'": "&#x27;",
      "<": "&lt;",
      ">": "&gt;",
      "`": "&#x60;"
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
    var decodeMap = { aacute: "\xE1", Aacute: "\xC1", abreve: "\u0103", Abreve: "\u0102", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", acirc: "\xE2", Acirc: "\xC2", acute: "\xB4", acy: "\u0430", Acy: "\u0410", aelig: "\xE6", AElig: "\xC6", af: "\u2061", afr: "\uD835\uDD1E", Afr: "\uD835\uDD04", agrave: "\xE0", Agrave: "\xC0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", Alpha: "\u0391", amacr: "\u0101", Amacr: "\u0100", amalg: "\u2A3F", amp: "&", AMP: "&", and: "\u2227", And: "\u2A53", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", Aogon: "\u0104", aopf: "\uD835\uDD52", Aopf: "\uD835\uDD38", ap: "\u2248", apacir: "\u2A6F", ape: "\u224A", apE: "\u2A70", apid: "\u224B", apos: "\'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", aring: "\xE5", Aring: "\xC5", ascr: "\uD835\uDCB6", Ascr: "\uD835\uDC9C", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", atilde: "\xE3", Atilde: "\xC3", auml: "\xE4", Auml: "\xC4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", Bcy: "\u0411", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", beta: "\u03B2", Beta: "\u0392", beth: "\u2136", between: "\u226C", bfr: "\uD835\uDD1F", Bfr: "\uD835\uDD05", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bNot: "\u2AED", bopf: "\uD835\uDD53", Bopf: "\uD835\uDD39", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxhD: "\u2565", boxHd: "\u2564", boxHD: "\u2566", boxhu: "\u2534", boxhU: "\u2568", boxHu: "\u2567", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\uD835\uDCB7", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpe: "\u224F", bumpE: "\u2AAE", bumpeq: "\u224F", Bumpeq: "\u224E", cacute: "\u0107", Cacute: "\u0106", cap: "\u2229", Cap: "\u22D2", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", ccaron: "\u010D", Ccaron: "\u010C", ccedil: "\xE7", Ccedil: "\xC7", ccirc: "\u0109", Ccirc: "\u0108", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", Cdot: "\u010A", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\uD835\uDD20", Cfr: "\u212D", chcy: "\u0447", CHcy: "\u0427", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", Chi: "\u03A7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cire: "\u2257", cirE: "\u29C3", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", colone: "\u2254", Colone: "\u2A74", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\uD835\uDD54", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", cscr: "\uD835\uDCB8", Cscr: "\uD835\uDC9E", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", Cup: "\u22D3", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", dArr: "\u21D3", Darr: "\u21A1", dash: "\u2010", dashv: "\u22A3", Dashv: "\u2AE4", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", Dcaron: "\u010E", dcy: "\u0434", Dcy: "\u0414", dd: "\u2146", DD: "\u2145", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", delta: "\u03B4", Delta: "\u0394", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\uD835\uDD21", Dfr: "\uD835\uDD07", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", DJcy: "\u0402", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\uD835\uDD55", Dopf: "\uD835\uDD3B", dot: "\u02D9", Dot: "\xA8", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", downarrow: "\u2193", Downarrow: "\u21D3", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\uD835\uDCB9", Dscr: "\uD835\uDC9F", dscy: "\u0455", DScy: "\u0405", dsol: "\u29F6", dstrok: "\u0111", Dstrok: "\u0110", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", DZcy: "\u040F", dzigrarr: "\u27FF", eacute: "\xE9", Eacute: "\xC9", easter: "\u2A6E", ecaron: "\u011B", Ecaron: "\u011A", ecir: "\u2256", ecirc: "\xEA", Ecirc: "\xCA", ecolon: "\u2255", ecy: "\u044D", Ecy: "\u042D", eDDot: "\u2A77", edot: "\u0117", eDot: "\u2251", Edot: "\u0116", ee: "\u2147", efDot: "\u2252", efr: "\uD835\uDD22", Efr: "\uD835\uDD08", eg: "\u2A9A", egrave: "\xE8", Egrave: "\xC8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", Emacr: "\u0112", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", eng: "\u014B", ENG: "\u014A", ensp: "\u2002", eogon: "\u0119", Eogon: "\u0118", eopf: "\uD835\uDD56", Eopf: "\uD835\uDD3C", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", Epsilon: "\u0395", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", esim: "\u2242", Esim: "\u2A73", eta: "\u03B7", Eta: "\u0397", eth: "\xF0", ETH: "\xD0", euml: "\xEB", Euml: "\xCB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", Fcy: "\u0424", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\uD835\uDD23", Ffr: "\uD835\uDD09", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\uD835\uDD57", Fopf: "\uD835\uDD3D", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\uD835\uDCBB", Fscr: "\u2131", gacute: "\u01F5", gamma: "\u03B3", Gamma: "\u0393", gammad: "\u03DD", Gammad: "\u03DC", gap: "\u2A86", gbreve: "\u011F", Gbreve: "\u011E", Gcedil: "\u0122", gcirc: "\u011D", Gcirc: "\u011C", gcy: "\u0433", Gcy: "\u0413", gdot: "\u0121", Gdot: "\u0120", ge: "\u2265", gE: "\u2267", gel: "\u22DB", gEl: "\u2A8C", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\uD835\uDD24", Gfr: "\uD835\uDD0A", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", GJcy: "\u0403", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\uD835\uDD58", Gopf: "\uD835\uDD3E", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", gscr: "\u210A", Gscr: "\uD835\uDCA2", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gt: ">", Gt: "\u226B", GT: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", HARDcy: "\u042A", harr: "\u2194", hArr: "\u21D4", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", hcirc: "\u0125", Hcirc: "\u0124", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\uD835\uDD25", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\uD835\uDD59", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\uD835\uDCBD", Hscr: "\u210B", hslash: "\u210F", hstrok: "\u0127", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", iacute: "\xED", Iacute: "\xCD", ic: "\u2063", icirc: "\xEE", Icirc: "\xCE", icy: "\u0438", Icy: "\u0418", Idot: "\u0130", iecy: "\u0435", IEcy: "\u0415", iexcl: "\xA1", iff: "\u21D4", ifr: "\uD835\uDD26", Ifr: "\u2111", igrave: "\xEC", Igrave: "\xCC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", IJlig: "\u0132", Im: "\u2111", imacr: "\u012B", Imacr: "\u012A", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", Int: "\u222C", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", iocy: "\u0451", IOcy: "\u0401", iogon: "\u012F", Iogon: "\u012E", iopf: "\uD835\uDD5A", Iopf: "\uD835\uDD40", iota: "\u03B9", Iota: "\u0399", iprod: "\u2A3C", iquest: "\xBF", iscr: "\uD835\uDCBE", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", Itilde: "\u0128", iukcy: "\u0456", Iukcy: "\u0406", iuml: "\xEF", Iuml: "\xCF", jcirc: "\u0135", Jcirc: "\u0134", jcy: "\u0439", Jcy: "\u0419", jfr: "\uD835\uDD27", Jfr: "\uD835\uDD0D", jmath: "\u0237", jopf: "\uD835\uDD5B", Jopf: "\uD835\uDD41", jscr: "\uD835\uDCBF", Jscr: "\uD835\uDCA5", jsercy: "\u0458", Jsercy: "\u0408", jukcy: "\u0454", Jukcy: "\u0404", kappa: "\u03BA", Kappa: "\u039A", kappav: "\u03F0", kcedil: "\u0137", Kcedil: "\u0136", kcy: "\u043A", Kcy: "\u041A", kfr: "\uD835\uDD28", Kfr: "\uD835\uDD0E", kgreen: "\u0138", khcy: "\u0445", KHcy: "\u0425", kjcy: "\u045C", KJcy: "\u040C", kopf: "\uD835\uDD5C", Kopf: "\uD835\uDD42", kscr: "\uD835\uDCC0", Kscr: "\uD835\uDCA6", lAarr: "\u21DA", lacute: "\u013A", Lacute: "\u0139", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", Lambda: "\u039B", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larr: "\u2190", lArr: "\u21D0", Larr: "\u219E", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", lAtail: "\u291B", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", Lcaron: "\u013D", lcedil: "\u013C", Lcedil: "\u013B", lceil: "\u2308", lcub: "{", lcy: "\u043B", Lcy: "\u041B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", leftarrow: "\u2190", Leftarrow: "\u21D0", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", Leftrightarrow: "\u21D4", LeftRightArrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", leg: "\u22DA", lEg: "\u2A8B", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\uD835\uDD29", Lfr: "\uD835\uDD0F", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", LJcy: "\u0409", ll: "\u226A", Ll: "\u22D8", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", Lmidot: "\u013F", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", Longleftarrow: "\u27F8", LongLeftArrow: "\u27F5", longleftrightarrow: "\u27F7", Longleftrightarrow: "\u27FA", LongLeftRightArrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", Longrightarrow: "\u27F9", LongRightArrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\uD835\uDD5D", Lopf: "\uD835\uDD43", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\uD835\uDCC1", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", Lstrok: "\u0141", lt: "<", Lt: "\u226A", LT: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", Map: "\u2905", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", Mcy: "\u041C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", mfr: "\uD835\uDD2A", Mfr: "\uD835\uDD10", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\uD835\uDD5E", Mopf: "\uD835\uDD44", mp: "\u2213", mscr: "\uD835\uDCC2", Mscr: "\u2133", mstpos: "\u223E", mu: "\u03BC", Mu: "\u039C", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", nacute: "\u0144", Nacute: "\u0143", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", Ncaron: "\u0147", ncedil: "\u0146", Ncedil: "\u0145", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", Ncy: "\u041D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", nfr: "\uD835\uDD2B", Nfr: "\uD835\uDD11", nge: "\u2271", ngE: "\u2267\u0338", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", ngt: "\u226F", nGt: "\u226B\u20D2", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", NJcy: "\u040A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nle: "\u2270", nlE: "\u2266\u0338", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nlt: "\u226E", nLt: "\u226A\u20D2", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\uD835\uDD5F", Nopf: "\u2115", not: "\xAC", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\uD835\uDCC3", Nscr: "\uD835\uDCA9", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsube: "\u2288", nsubE: "\u2AC5\u0338", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupe: "\u2289", nsupE: "\u2AC6\u0338", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntilde: "\xF1", Ntilde: "\xD1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", Nu: "\u039D", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", oacute: "\xF3", Oacute: "\xD3", oast: "\u229B", ocir: "\u229A", ocirc: "\xF4", Ocirc: "\xD4", ocy: "\u043E", Ocy: "\u041E", odash: "\u229D", odblac: "\u0151", Odblac: "\u0150", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", OElig: "\u0152", ofcir: "\u29BF", ofr: "\uD835\uDD2C", Ofr: "\uD835\uDD12", ogon: "\u02DB", ograve: "\xF2", Ograve: "\xD2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", Omacr: "\u014C", omega: "\u03C9", Omega: "\u03A9", omicron: "\u03BF", Omicron: "\u039F", omid: "\u29B6", ominus: "\u2296", oopf: "\uD835\uDD60", Oopf: "\uD835\uDD46", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", or: "\u2228", Or: "\u2A54", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", oscr: "\u2134", Oscr: "\uD835\uDCAA", oslash: "\xF8", Oslash: "\xD8", osol: "\u2298", otilde: "\xF5", Otilde: "\xD5", otimes: "\u2297", Otimes: "\u2A37", otimesas: "\u2A36", ouml: "\xF6", Ouml: "\xD6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", pcy: "\u043F", Pcy: "\u041F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\uD835\uDD2D", Pfr: "\uD835\uDD13", phi: "\u03C6", Phi: "\u03A6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", Pi: "\u03A0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\uD835\uDD61", Popf: "\u2119", pound: "\xA3", pr: "\u227A", Pr: "\u2ABB", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prE: "\u2AB3", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\uD835\uDCC5", Pscr: "\uD835\uDCAB", psi: "\u03C8", Psi: "\u03A8", puncsp: "\u2008", qfr: "\uD835\uDD2E", Qfr: "\uD835\uDD14", qint: "\u2A0C", qopf: "\uD835\uDD62", Qopf: "\u211A", qprime: "\u2057", qscr: "\uD835\uDCC6", Qscr: "\uD835\uDCAC", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", racute: "\u0155", Racute: "\u0154", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarr: "\u2192", rArr: "\u21D2", Rarr: "\u21A0", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", Rarrtl: "\u2916", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", Rcaron: "\u0158", rcedil: "\u0157", Rcedil: "\u0156", rceil: "\u2309", rcub: "}", rcy: "\u0440", Rcy: "\u0420", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\uD835\uDD2F", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", Rho: "\u03A1", rhov: "\u03F1", RightAngleBracket: "\u27E9", rightarrow: "\u2192", Rightarrow: "\u21D2", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\uD835\uDD63", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\uD835\uDCC7", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", Sacute: "\u015A", sbquo: "\u201A", sc: "\u227B", Sc: "\u2ABC", scap: "\u2AB8", scaron: "\u0161", Scaron: "\u0160", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", scedil: "\u015F", Scedil: "\u015E", scirc: "\u015D", Scirc: "\u015C", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", Scy: "\u0421", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\uD835\uDD30", Sfr: "\uD835\uDD16", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", SHCHcy: "\u0429", shcy: "\u0448", SHcy: "\u0428", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", sigma: "\u03C3", Sigma: "\u03A3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", SOFTcy: "\u042C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\uD835\uDD64", Sopf: "\uD835\uDD4A", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\uD835\uDCC8", Sscr: "\uD835\uDCAE", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", Star: "\u22C6", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", sube: "\u2286", subE: "\u2AC5", subedot: "\u2AC3", submult: "\u2AC1", subne: "\u228A", subnE: "\u2ACB", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup: "\u2283", Sup: "\u22D1", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supE: "\u2AC6", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supne: "\u228B", supnE: "\u2ACC", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "\t", target: "\u2316", tau: "\u03C4", Tau: "\u03A4", tbrk: "\u23B4", tcaron: "\u0165", Tcaron: "\u0164", tcedil: "\u0163", Tcedil: "\u0162", tcy: "\u0442", Tcy: "\u0422", tdot: "\u20DB", telrec: "\u2315", tfr: "\uD835\uDD31", Tfr: "\uD835\uDD17", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", theta: "\u03B8", Theta: "\u0398", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", thorn: "\xFE", THORN: "\xDE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\uD835\uDD65", Topf: "\uD835\uDD4B", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\uD835\uDCC9", Tscr: "\uD835\uDCAF", tscy: "\u0446", TScy: "\u0426", tshcy: "\u045B", TSHcy: "\u040B", tstrok: "\u0167", Tstrok: "\u0166", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uacute: "\xFA", Uacute: "\xDA", uarr: "\u2191", uArr: "\u21D1", Uarr: "\u219F", Uarrocir: "\u2949", ubrcy: "\u045E", Ubrcy: "\u040E", ubreve: "\u016D", Ubreve: "\u016C", ucirc: "\xFB", Ucirc: "\xDB", ucy: "\u0443", Ucy: "\u0423", udarr: "\u21C5", udblac: "\u0171", Udblac: "\u0170", udhar: "\u296E", ufisht: "\u297E", ufr: "\uD835\uDD32", Ufr: "\uD835\uDD18", ugrave: "\xF9", Ugrave: "\xD9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", Umacr: "\u016A", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", uogon: "\u0173", Uogon: "\u0172", uopf: "\uD835\uDD66", Uopf: "\uD835\uDD4C", uparrow: "\u2191", Uparrow: "\u21D1", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", Updownarrow: "\u21D5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", upsilon: "\u03C5", Upsilon: "\u03A5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", Uring: "\u016E", urtri: "\u25F9", uscr: "\uD835\uDCCA", Uscr: "\uD835\uDCB0", utdot: "\u22F0", utilde: "\u0169", Utilde: "\u0168", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uuml: "\xFC", Uuml: "\xDC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", vcy: "\u0432", Vcy: "\u0412", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", vee: "\u2228", Vee: "\u22C1", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", vfr: "\uD835\uDD33", Vfr: "\uD835\uDD19", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\uD835\uDD67", Vopf: "\uD835\uDD4D", vprop: "\u221D", vrtri: "\u22B3", vscr: "\uD835\uDCCB", Vscr: "\uD835\uDCB1", vsubne: "\u228A\uFE00", vsubnE: "\u2ACB\uFE00", vsupne: "\u228B\uFE00", vsupnE: "\u2ACC\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", wcirc: "\u0175", Wcirc: "\u0174", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", wfr: "\uD835\uDD34", Wfr: "\uD835\uDD1A", wopf: "\uD835\uDD68", Wopf: "\uD835\uDD4E", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\uD835\uDCCC", Wscr: "\uD835\uDCB2", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\uD835\uDD35", Xfr: "\uD835\uDD1B", xharr: "\u27F7", xhArr: "\u27FA", xi: "\u03BE", Xi: "\u039E", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\uD835\uDD69", Xopf: "\uD835\uDD4F", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", xscr: "\uD835\uDCCD", Xscr: "\uD835\uDCB3", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacute: "\xFD", Yacute: "\xDD", yacy: "\u044F", YAcy: "\u042F", ycirc: "\u0177", Ycirc: "\u0176", ycy: "\u044B", Ycy: "\u042B", yen: "\xA5", yfr: "\uD835\uDD36", Yfr: "\uD835\uDD1C", yicy: "\u0457", YIcy: "\u0407", yopf: "\uD835\uDD6A", Yopf: "\uD835\uDD50", yscr: "\uD835\uDCCE", Yscr: "\uD835\uDCB4", yucy: "\u044E", YUcy: "\u042E", yuml: "\xFF", Yuml: "\u0178", zacute: "\u017A", Zacute: "\u0179", zcaron: "\u017E", Zcaron: "\u017D", zcy: "\u0437", Zcy: "\u0417", zdot: "\u017C", Zdot: "\u017B", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", zeta: "\u03B6", Zeta: "\u0396", zfr: "\uD835\uDD37", Zfr: "\u2128", zhcy: "\u0436", ZHcy: "\u0416", zigrarr: "\u21DD", zopf: "\uD835\uDD6B", Zopf: "\u2124", zscr: "\uD835\uDCCF", Zscr: "\uD835\uDCB5", zwj: "\u200D", zwnj: "\u200C" };
    var decodeMapLegacy = { aacute: "\xE1", Aacute: "\xC1", acirc: "\xE2", Acirc: "\xC2", acute: "\xB4", aelig: "\xE6", AElig: "\xC6", agrave: "\xE0", Agrave: "\xC0", amp: "&", AMP: "&", aring: "\xE5", Aring: "\xC5", atilde: "\xE3", Atilde: "\xC3", auml: "\xE4", Auml: "\xC4", brvbar: "\xA6", ccedil: "\xE7", Ccedil: "\xC7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", eacute: "\xE9", Eacute: "\xC9", ecirc: "\xEA", Ecirc: "\xCA", egrave: "\xE8", Egrave: "\xC8", eth: "\xF0", ETH: "\xD0", euml: "\xEB", Euml: "\xCB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", iacute: "\xED", Iacute: "\xCD", icirc: "\xEE", Icirc: "\xCE", iexcl: "\xA1", igrave: "\xEC", Igrave: "\xCC", iquest: "\xBF", iuml: "\xEF", Iuml: "\xCF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", ntilde: "\xF1", Ntilde: "\xD1", oacute: "\xF3", Oacute: "\xD3", ocirc: "\xF4", Ocirc: "\xD4", ograve: "\xF2", Ograve: "\xD2", ordf: "\xAA", ordm: "\xBA", oslash: "\xF8", Oslash: "\xD8", otilde: "\xF5", Otilde: "\xD5", ouml: "\xF6", Ouml: "\xD6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", thorn: "\xFE", THORN: "\xDE", times: "\xD7", uacute: "\xFA", Uacute: "\xDA", ucirc: "\xFB", Ucirc: "\xDB", ugrave: "\xF9", Ugrave: "\xD9", uml: "\xA8", uuml: "\xFC", Uuml: "\xDC", yacute: "\xFD", Yacute: "\xDD", yen: "\xA5", yuml: "\xFF" };
    var decodeMapNumeric = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
    var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var has = function(object2, propertyName) {
      return hasOwnProperty.call(object2, propertyName);
    };
    var contains = function(array, value) {
      var index = -1;
      var length = array.length;
      while (++index < length) {
        if (array[index] == value) {
          return true;
        }
      }
      return false;
    };
    var merge2 = function(options, defaults2) {
      if (!options) {
        return defaults2;
      }
      var result = {};
      var key2;
      for (key2 in defaults2) {
        result[key2] = has(options, key2) ? options[key2] : defaults2[key2];
      }
      return result;
    };
    var codePointToSymbol = function(codePoint, strict) {
      var output = "";
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        if (strict) {
          parseError("character reference outside the permissible Unicode range");
        }
        return "\uFFFD";
      }
      if (has(decodeMapNumeric, codePoint)) {
        if (strict) {
          parseError("disallowed character reference");
        }
        return decodeMapNumeric[codePoint];
      }
      if (strict && contains(invalidReferenceCodePoints, codePoint)) {
        parseError("disallowed character reference");
      }
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += stringFromCharCode(codePoint);
      return output;
    };
    var hexEscape = function(codePoint) {
      return "&#x" + codePoint.toString(16).toUpperCase() + ";";
    };
    var decEscape = function(codePoint) {
      return "&#" + codePoint + ";";
    };
    var parseError = function(message) {
      throw Error("Parse error: " + message);
    };
    var encode = function(string, options) {
      options = merge2(options, encode.options);
      var strict = options.strict;
      if (strict && regexInvalidRawCodePoint.test(string)) {
        parseError("forbidden code point");
      }
      var encodeEverything = options.encodeEverything;
      var useNamedReferences = options.useNamedReferences;
      var allowUnsafeSymbols = options.allowUnsafeSymbols;
      var escapeCodePoint = options.decimal ? decEscape : hexEscape;
      var escapeBmpSymbol = function(symbol) {
        return escapeCodePoint(symbol.charCodeAt(0));
      };
      if (encodeEverything) {
        string = string.replace(regexAsciiWhitelist, function(symbol) {
          if (useNamedReferences && has(encodeMap, symbol)) {
            return "&" + encodeMap[symbol] + ";";
          }
          return escapeBmpSymbol(symbol);
        });
        if (useNamedReferences) {
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
        }
        if (useNamedReferences) {
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        }
      } else if (useNamedReferences) {
        if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        }
        string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
        string = string.replace(regexEncodeNonAscii, function(string2) {
          return "&" + encodeMap[string2] + ";";
        });
      } else if (!allowUnsafeSymbols) {
        string = string.replace(regexEscape, escapeBmpSymbol);
      }
      return string.replace(regexAstralSymbols, function($0) {
        var high = $0.charCodeAt(0);
        var low = $0.charCodeAt(1);
        var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
        return escapeCodePoint(codePoint);
      }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
      allowUnsafeSymbols: false,
      encodeEverything: false,
      strict: false,
      useNamedReferences: false,
      decimal: false
    };
    var decode = function(html, options) {
      options = merge2(options, decode.options);
      var strict = options.strict;
      if (strict && regexInvalidEntity.test(html)) {
        parseError("malformed character reference");
      }
      return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
        var codePoint;
        var semicolon;
        var decDigits;
        var hexDigits;
        var reference;
        var next;
        if ($1) {
          reference = $1;
          return decodeMap[reference];
        }
        if ($2) {
          reference = $2;
          next = $3;
          if (next && options.isAttributeValue) {
            if (strict && next == "=") {
              parseError("`&` did not start a character reference");
            }
            return $0;
          } else {
            if (strict) {
              parseError("named character reference was not terminated by a semicolon");
            }
            return decodeMapLegacy[reference] + (next || "");
          }
        }
        if ($4) {
          decDigits = $4;
          semicolon = $5;
          if (strict && !semicolon) {
            parseError("character reference was not terminated by a semicolon");
          }
          codePoint = parseInt(decDigits, 10);
          return codePointToSymbol(codePoint, strict);
        }
        if ($6) {
          hexDigits = $6;
          semicolon = $7;
          if (strict && !semicolon) {
            parseError("character reference was not terminated by a semicolon");
          }
          codePoint = parseInt(hexDigits, 16);
          return codePointToSymbol(codePoint, strict);
        }
        if (strict) {
          parseError("named character reference was not terminated by a semicolon");
        }
        return $0;
      });
    };
    decode.options = {
      isAttributeValue: false,
      strict: false
    };
    var escape2 = function(string) {
      return string.replace(regexEscape, function($0) {
        return escapeMap[$0];
      });
    };
    var he = {
      version: "1.2.0",
      encode,
      decode,
      escape: escape2,
      unescape: decode
    };
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      define(function() {
        return he;
      });
    } else if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        freeModule.exports = he;
      } else {
        for (var key in he) {
          has(he, key) && (freeExports[key] = he[key]);
        }
      }
    } else {
      root.he = he;
    }
  })(exports);
});

// src/utils.js
var require_utils = __commonJS((exports) => {
  var createMap = function(values, ignoreCase) {
    var map = {};
    values.forEach(function(value) {
      map[value] = 1;
    });
    return ignoreCase ? function(value) {
      return map[value.toLowerCase()] === 1;
    } : function(value) {
      return map[value] === 1;
    };
  };
  exports.createMap = createMap;
  exports.createMapFromString = function(values, ignoreCase) {
    return createMap(values.split(/,/), ignoreCase);
  };
});

// src/htmlparser.js
var require_htmlparser = __commonJS((exports) => {
  var makeMap = function(values) {
    return createMapFromString(values, true);
  };
  var attrForHandler = function(handler) {
    var pattern = singleAttrIdentifier.source + "(?:\\s*(" + joinSingleAttrAssigns(handler) + ")[ \\t\\n\\f\\r]*(?:" + singleAttrValues.join("|") + "))?";
    if (handler.customAttrSurround) {
      var attrClauses = [];
      for (var i = handler.customAttrSurround.length - 1;i >= 0; i--) {
        attrClauses[i] = "(?:(" + handler.customAttrSurround[i][0].source + ")\\s*" + pattern + "\\s*(" + handler.customAttrSurround[i][1].source + "))";
      }
      attrClauses.push("(?:" + pattern + ")");
      pattern = "(?:" + attrClauses.join("|") + ")";
    }
    return new RegExp("^\\s*" + pattern);
  };
  var joinSingleAttrAssigns = function(handler) {
    return singleAttrAssigns.concat(handler.customAttrAssign || []).map(function(assign) {
      return "(?:" + assign.source + ")";
    }).join("|");
  };
  var HTMLParser = function(html, handler) {
    var stack = [], lastTag;
    var attribute = attrForHandler(handler);
    var last, prevTag, nextTag;
    while (html) {
      last = html;
      if (!lastTag || !special(lastTag)) {
        var textEnd = html.indexOf("<");
        if (textEnd === 0) {
          if (/^<!--/.test(html)) {
            var commentEnd = html.indexOf("-->");
            if (commentEnd >= 0) {
              if (handler.comment) {
                handler.comment(html.substring(4, commentEnd));
              }
              html = html.substring(commentEnd + 3);
              prevTag = "";
              continue;
            }
          }
          if (/^<!\[/.test(html)) {
            var conditionalEnd = html.indexOf("]>");
            if (conditionalEnd >= 0) {
              if (handler.comment) {
                handler.comment(html.substring(2, conditionalEnd + 1), true);
              }
              html = html.substring(conditionalEnd + 2);
              prevTag = "";
              continue;
            }
          }
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            if (handler.doctype) {
              handler.doctype(doctypeMatch[0]);
            }
            html = html.substring(doctypeMatch[0].length);
            prevTag = "";
            continue;
          }
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            html = html.substring(endTagMatch[0].length);
            endTagMatch[0].replace(endTag, parseEndTag);
            prevTag = "/" + endTagMatch[1].toLowerCase();
            continue;
          }
          var startTagMatch = parseStartTag(html);
          if (startTagMatch) {
            html = startTagMatch.rest;
            handleStartTag(startTagMatch);
            prevTag = startTagMatch.tagName.toLowerCase();
            continue;
          }
          if (handler.continueOnParseError) {
            textEnd = html.indexOf("<", 1);
          }
        }
        var text;
        if (textEnd >= 0) {
          text = html.substring(0, textEnd);
          html = html.substring(textEnd);
        } else {
          text = html;
          html = "";
        }
        var nextTagMatch = parseStartTag(html);
        if (nextTagMatch) {
          nextTag = nextTagMatch.tagName;
        } else {
          nextTagMatch = html.match(endTag);
          if (nextTagMatch) {
            nextTag = "/" + nextTagMatch[1];
          } else {
            nextTag = "";
          }
        }
        if (handler.chars) {
          handler.chars(text, prevTag, nextTag);
        }
        prevTag = "";
      } else {
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp("([\\s\\S]*?)</" + stackedTag + "[^>]*>", "i"));
        html = html.replace(reStackedTag, function(all2, text2) {
          if (stackedTag !== "script" && stackedTag !== "style" && stackedTag !== "noscript") {
            text2 = text2.replace(/<!--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1");
          }
          if (handler.chars) {
            handler.chars(text2);
          }
          return "";
        });
        parseEndTag("</" + stackedTag + ">", stackedTag);
      }
      if (html === last) {
        throw new Error("Parse Error: " + html);
      }
    }
    if (!handler.partialMarkup) {
      parseEndTag();
    }
    function parseStartTag(input) {
      var start = input.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: []
        };
        input = input.slice(start[0].length);
        var end, attr;
        while (!(end = input.match(startTagClose)) && (attr = input.match(attribute))) {
          input = input.slice(attr[0].length);
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          match.rest = input.slice(end[0].length);
          return match;
        }
      }
    }
    function closeIfFound(tagName) {
      if (findTag(tagName) >= 0) {
        parseEndTag("", tagName);
        return true;
      }
    }
    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;
      if (handler.html5) {
        if (lastTag === "p" && nonPhrasing(tagName)) {
          parseEndTag("", lastTag);
        } else if (tagName === "tbody") {
          closeIfFound("thead");
        } else if (tagName === "tfoot") {
          if (!closeIfFound("tbody")) {
            closeIfFound("thead");
          }
        }
        if (tagName === "col" && findTag("colgroup") < 0) {
          lastTag = "colgroup";
          stack.push({ tag: lastTag, attrs: [] });
          if (handler.start) {
            handler.start(lastTag, [], false, "");
          }
        }
      }
      if (!handler.html5 && !inline(tagName)) {
        while (lastTag && inline(lastTag)) {
          parseEndTag("", lastTag);
        }
      }
      if (closeSelf(tagName) && lastTag === tagName) {
        parseEndTag("", tagName);
      }
      var unary = empty(tagName) || tagName === "html" && lastTag === "head" || !!unarySlash;
      var attrs = match.attrs.map(function(args) {
        var name, value, customOpen, customClose, customAssign, quote;
        var ncp = 7;
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === "") {
            delete args[3];
          }
          if (args[4] === "") {
            delete args[4];
          }
          if (args[5] === "") {
            delete args[5];
          }
        }
        function populate(index) {
          customAssign = args[index];
          value = args[index + 1];
          if (typeof value !== "undefined") {
            return '"';
          }
          value = args[index + 2];
          if (typeof value !== "undefined") {
            return "\'";
          }
          value = args[index + 3];
          if (typeof value === "undefined" && fillAttrs(name)) {
            value = name;
          }
          return "";
        }
        var j2 = 1;
        if (handler.customAttrSurround) {
          for (var i = 0, l2 = handler.customAttrSurround.length;i < l2; i++, j2 += ncp) {
            name = args[j2 + 1];
            if (name) {
              quote = populate(j2 + 2);
              customOpen = args[j2];
              customClose = args[j2 + 6];
              break;
            }
          }
        }
        if (!name && (name = args[j2])) {
          quote = populate(j2 + 1);
        }
        return {
          name,
          value,
          customAssign: customAssign || "=",
          customOpen: customOpen || "",
          customClose: customClose || "",
          quote: quote || ""
        };
      });
      if (!unary) {
        stack.push({ tag: tagName, attrs });
        lastTag = tagName;
        unarySlash = "";
      }
      if (handler.start) {
        handler.start(tagName, attrs, unary, unarySlash);
      }
    }
    function findTag(tagName) {
      var pos;
      var needle = tagName.toLowerCase();
      for (pos = stack.length - 1;pos >= 0; pos--) {
        if (stack[pos].tag.toLowerCase() === needle) {
          break;
        }
      }
      return pos;
    }
    function parseEndTag(tag, tagName) {
      var pos;
      if (tagName) {
        pos = findTag(tagName);
      } else {
        pos = 0;
      }
      if (pos >= 0) {
        for (var i = stack.length - 1;i >= pos; i--) {
          if (handler.end) {
            handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);
          }
        }
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (tagName.toLowerCase() === "br") {
        if (handler.start) {
          handler.start(tagName, [], true, "");
        }
      } else if (tagName.toLowerCase() === "p") {
        if (handler.start) {
          handler.start(tagName, [], false, "", true);
        }
        if (handler.end) {
          handler.end(tagName, []);
        }
      }
    }
  };
  /*!
   * HTML Parser By John Resig (ejohn.org)
   * Modified by Juriy "kangax" Zaytsev
   * Original code by Erik Arvidsson, Mozilla Public License
   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
   */
  var createMapFromString = require_utils().createMapFromString;
  var singleAttrIdentifier = /([^\s"'<>/=]+)/;
  var singleAttrAssigns = [/=/];
  var singleAttrValues = [
    /"([^"]*)"+/.source,
    /'([^']*)'+/.source,
    /([^ \t\n\f\r"'`=<>]+)/.source
  ];
  var qnameCapture = function() {
    var combiningChar = "\\u0300-\\u0345\\u0360\\u0361\\u0483-\\u0486\\u0591-\\u05A1\\u05A3-\\u05B9\\u05BB-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u064B-\\u0652\\u0670\\u06D6-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0901-\\u0903\\u093C\\u093E-\\u094D\\u0951-\\u0954\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A02\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A70\\u0A71\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B82\\u0B83\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C82\\u0C83\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86-\\u0F8B\\u0F90-\\u0F95\\u0F97\\u0F99-\\u0FAD\\u0FB1-\\u0FB7\\u0FB9\\u20D0-\\u20DC\\u20E1\\u302A-\\u302F\\u3099\\u309A";
    var digit = "0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE7-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29";
    var extender = "\\xB7\\u02D0\\u02D1\\u0387\\u0640\\u0E46\\u0EC6\\u3005\\u3031-\\u3035\\u309D\\u309E\\u30FC-\\u30FE";
    var letter = "A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3007\\u3021-\\u3029\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3";
    var ncname = "[" + letter + "_][" + letter + digit + "\\.\\-_" + combiningChar + extender + "]*";
    return "((?:" + ncname + "\\:)?" + ncname + ")";
  }();
  var startTagOpen = new RegExp("^<" + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
  var doctype = /^<!DOCTYPE\s?[^>]+>/i;
  var IS_REGEX_CAPTURING_BROKEN = false;
  "x".replace(/x(.)?/g, function(m4, g2) {
    IS_REGEX_CAPTURING_BROKEN = g2 === "";
  });
  var empty = makeMap("area,base,basefont,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr");
  var inline = makeMap("a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,noscript,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,svg,textarea,tt,u,var");
  var closeSelf = makeMap("colgroup,dd,dt,li,option,p,td,tfoot,th,thead,tr,source");
  var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");
  var special = makeMap("script,style");
  var nonPhrasing = makeMap("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,ol,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track,ul");
  var reCache = {};
  exports.HTMLParser = HTMLParser;
  exports.HTMLtoXML = function(html) {
    var results = "";
    new HTMLParser(html, {
      start: function(tag, attrs, unary) {
        results += "<" + tag;
        for (var i = 0, len = attrs.length;i < len; i++) {
          results += " " + attrs[i].name + '="' + (attrs[i].value || "").replace(/"/g, "&#34;") + '"';
        }
        results += (unary ? "/" : "") + ">";
      },
      end: function(tag) {
        results += "</" + tag + ">";
      },
      chars: function(text) {
        results += text;
      },
      comment: function(text) {
        results += "<!--" + text + "-->";
      },
      ignore: function(text) {
        results += text;
      }
    });
    return results;
  };
  exports.HTMLtoDOM = function(html, doc) {
    var one = {
      html: true,
      head: true,
      body: true,
      title: true
    };
    var structure = {
      link: "head",
      base: "head"
    };
    if (doc) {
      doc = doc.ownerDocument || doc.getOwnerDocument && doc.getOwnerDocument() || doc;
    } else if (typeof DOMDocument !== "undefined") {
      doc = new DOMDocument;
    } else if (typeof document !== "undefined" && document.implementation && document.implementation.createDocument) {
      doc = document.implementation.createDocument("", "", null);
    } else if (typeof ActiveX !== "undefined") {
      doc = new ActiveXObject("Msxml.DOMDocument");
    }
    var elems = [], documentElement = doc.documentElement || doc.getDocumentElement && doc.getDocumentElement();
    if (!documentElement && doc.createElement) {
      (function() {
        var html2 = doc.createElement("html");
        var head = doc.createElement("head");
        head.appendChild(doc.createElement("title"));
        html2.appendChild(head);
        html2.appendChild(doc.createElement("body"));
        doc.appendChild(html2);
      })();
    }
    if (doc.getElementsByTagName) {
      for (var i in one) {
        one[i] = doc.getElementsByTagName(i)[0];
      }
    }
    var curParentNode = one.body;
    new HTMLParser(html, {
      start: function(tagName, attrs, unary) {
        if (one[tagName]) {
          curParentNode = one[tagName];
          return;
        }
        var elem = doc.createElement(tagName);
        for (var attr in attrs) {
          elem.setAttribute(attrs[attr].name, attrs[attr].value);
        }
        if (structure[tagName] && typeof one[structure[tagName]] !== "boolean") {
          one[structure[tagName]].appendChild(elem);
        } else if (curParentNode && curParentNode.appendChild) {
          curParentNode.appendChild(elem);
        }
        if (!unary) {
          elems.push(elem);
          curParentNode = elem;
        }
      },
      end: function() {
        elems.length -= 1;
        curParentNode = elems[elems.length - 1];
      },
      chars: function(text) {
        curParentNode.appendChild(doc.createTextNode(text));
      },
      comment: function() {
      },
      ignore: function() {
      }
    });
    return doc;
  };
});

// node_modules/relateurl/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    ABSOLUTE: "absolute",
    PATH_RELATIVE: "pathRelative",
    ROOT_RELATIVE: "rootRelative",
    SHORTEST: "shortest"
  };
});

// node_modules/relateurl/lib/format.js
var require_format2 = __commonJS((exports, module) => {
  var formatAuth = function(urlObj, options) {
    if (urlObj.auth && !options.removeAuth && (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE)) {
      return urlObj.auth + "@";
    }
    return "";
  };
  var formatHash = function(urlObj, options) {
    return urlObj.hash ? urlObj.hash : "";
  };
  var formatHost = function(urlObj, options) {
    if (urlObj.host.full && (urlObj.extra.relation.maximumAuth || options.output === constants.ABSOLUTE)) {
      return urlObj.host.full;
    }
    return "";
  };
  var formatPath = function(urlObj, options) {
    var str = "";
    var absolutePath = urlObj.path.absolute.string;
    var relativePath = urlObj.path.relative.string;
    var resource = showResource(urlObj, options);
    if (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE || options.output === constants.ROOT_RELATIVE) {
      str = absolutePath;
    } else if (relativePath.length <= absolutePath.length && options.output === constants.SHORTEST || options.output === constants.PATH_RELATIVE) {
      str = relativePath;
      if (str === "") {
        var query = showQuery(urlObj, options) && !!getQuery(urlObj, options);
        if (urlObj.extra.relation.maximumPath && !resource) {
          str = "./";
        } else if (urlObj.extra.relation.overridesQuery && !resource && !query) {
          str = "./";
        }
      }
    } else {
      str = absolutePath;
    }
    if (str === "/" && !resource && options.removeRootTrailingSlash && (!urlObj.extra.relation.minimumPort || options.output === constants.ABSOLUTE)) {
      str = "";
    }
    return str;
  };
  var formatPort = function(urlObj, options) {
    if (urlObj.port && !urlObj.extra.portIsDefault && urlObj.extra.relation.maximumHost) {
      return ":" + urlObj.port;
    }
    return "";
  };
  var formatQuery = function(urlObj, options) {
    return showQuery(urlObj, options) ? getQuery(urlObj, options) : "";
  };
  var formatResource = function(urlObj, options) {
    return showResource(urlObj, options) ? urlObj.resource : "";
  };
  var formatScheme = function(urlObj, options) {
    var str = "";
    if (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE) {
      if (!urlObj.extra.relation.minimumScheme || !options.schemeRelative || options.output === constants.ABSOLUTE) {
        str += urlObj.scheme + "://";
      } else {
        str += "//";
      }
    }
    return str;
  };
  var formatUrl = function(urlObj, options) {
    var url = "";
    url += formatScheme(urlObj, options);
    url += formatAuth(urlObj, options);
    url += formatHost(urlObj, options);
    url += formatPort(urlObj, options);
    url += formatPath(urlObj, options);
    url += formatResource(urlObj, options);
    url += formatQuery(urlObj, options);
    url += formatHash(urlObj, options);
    return url;
  };
  var getQuery = function(urlObj, options) {
    var stripQuery = options.removeEmptyQueries && urlObj.extra.relation.minimumPort;
    return urlObj.query.string[stripQuery ? "stripped" : "full"];
  };
  var showQuery = function(urlObj, options) {
    return !urlObj.extra.relation.minimumQuery || options.output === constants.ABSOLUTE || options.output === constants.ROOT_RELATIVE;
  };
  var showResource = function(urlObj, options) {
    var removeIndex = options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex;
    var removeMatchingResource = urlObj.extra.relation.minimumResource && options.output !== constants.ABSOLUTE && options.output !== constants.ROOT_RELATIVE;
    return !!urlObj.resource && !removeMatchingResource && !removeIndex;
  };
  var constants = require_constants();
  module.exports = formatUrl;
});

// node_modules/relateurl/lib/util/object.js
var require_object = __commonJS((exports, module) => {
  var clone = function(obj) {
    if (obj instanceof Object) {
      var clonedObj = obj instanceof Array ? [] : {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          clonedObj[i] = clone(obj[i]);
        }
      }
      return clonedObj;
    }
    return obj;
  };
  var isPlainObject = function(obj) {
    return !!obj && typeof obj === "object" && obj.constructor === Object;
  };
  var shallowMerge = function(target, source) {
    if (target instanceof Object && source instanceof Object) {
      for (var i in source) {
        if (source.hasOwnProperty(i)) {
          target[i] = source[i];
        }
      }
    }
    return target;
  };
  module.exports = {
    clone,
    isPlainObject,
    shallowMerge
  };
});

// node_modules/relateurl/lib/options.js
var require_options = __commonJS((exports, module) => {
  var getOptions = function(options, defaults2) {
    if (objUtils.isPlainObject(options)) {
      var newOptions = {};
      for (var i in defaults2) {
        if (defaults2.hasOwnProperty(i)) {
          if (options[i] !== undefined) {
            newOptions[i] = mergeOption(options[i], defaults2[i]);
          } else {
            newOptions[i] = defaults2[i];
          }
        }
      }
      return newOptions;
    } else {
      return defaults2;
    }
  };
  var mergeOption = function(newValues, defaultValues) {
    if (defaultValues instanceof Object && newValues instanceof Object) {
      if (defaultValues instanceof Array && newValues instanceof Array) {
        return defaultValues.concat(newValues);
      } else {
        return objUtils.shallowMerge(newValues, defaultValues);
      }
    }
    return newValues;
  };
  var objUtils = require_object();
  module.exports = getOptions;
});

// node_modules/relateurl/lib/parse/hrefInfo.js
var require_hrefInfo = __commonJS((exports, module) => {
  var hrefInfo = function(urlObj) {
    var minimumPathOnly = !urlObj.scheme && !urlObj.auth && !urlObj.host.full && !urlObj.port;
    var minimumResourceOnly = minimumPathOnly && !urlObj.path.absolute.string;
    var minimumQueryOnly = minimumResourceOnly && !urlObj.resource;
    var minimumHashOnly = minimumQueryOnly && !urlObj.query.string.full.length;
    var empty = minimumHashOnly && !urlObj.hash;
    urlObj.extra.hrefInfo.minimumPathOnly = minimumPathOnly;
    urlObj.extra.hrefInfo.minimumResourceOnly = minimumResourceOnly;
    urlObj.extra.hrefInfo.minimumQueryOnly = minimumQueryOnly;
    urlObj.extra.hrefInfo.minimumHashOnly = minimumHashOnly;
    urlObj.extra.hrefInfo.empty = empty;
  };
  module.exports = hrefInfo;
});

// node_modules/relateurl/lib/parse/host.js
var require_host = __commonJS((exports, module) => {
  var parseHost = function(urlObj, options) {
    if (options.ignore_www) {
      var host = urlObj.host.full;
      if (host) {
        var stripped = host;
        if (host.indexOf("www.") === 0) {
          stripped = host.substr(4);
        }
        urlObj.host.stripped = stripped;
      }
    }
  };
  module.exports = parseHost;
});

// node_modules/relateurl/lib/parse/path.js
var require_path = __commonJS((exports, module) => {
  var isDirectoryIndex = function(resource, options) {
    var verdict = false;
    options.directoryIndexes.every(function(index) {
      if (index === resource) {
        verdict = true;
        return false;
      }
      return true;
    });
    return verdict;
  };
  var parsePath = function(urlObj, options) {
    var path = urlObj.path.absolute.string;
    if (path) {
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash > -1) {
        if (++lastSlash < path.length) {
          var resource = path.substr(lastSlash);
          if (resource !== "." && resource !== "..") {
            urlObj.resource = resource;
            path = path.substr(0, lastSlash);
          } else {
            path += "/";
          }
        }
        urlObj.path.absolute.string = path;
        urlObj.path.absolute.array = splitPath(path);
      } else if (path === "." || path === "..") {
        path += "/";
        urlObj.path.absolute.string = path;
        urlObj.path.absolute.array = splitPath(path);
      } else {
        urlObj.resource = path;
        urlObj.path.absolute.string = null;
      }
      urlObj.extra.resourceIsIndex = isDirectoryIndex(urlObj.resource, options);
    }
  };
  var splitPath = function(path) {
    if (path !== "/") {
      var cleaned = [];
      path.split("/").forEach(function(dir) {
        if (dir !== "") {
          cleaned.push(dir);
        }
      });
      return cleaned;
    } else {
      return [];
    }
  };
  module.exports = parsePath;
});

// node_modules/relateurl/lib/parse/port.js
var require_port = __commonJS((exports, module) => {
  var parsePort = function(urlObj, options) {
    var defaultPort = -1;
    for (var i in options.defaultPorts) {
      if (i === urlObj.scheme && options.defaultPorts.hasOwnProperty(i)) {
        defaultPort = options.defaultPorts[i];
        break;
      }
    }
    if (defaultPort > -1) {
      defaultPort = defaultPort.toString();
      if (urlObj.port === null) {
        urlObj.port = defaultPort;
      }
      urlObj.extra.portIsDefault = urlObj.port === defaultPort;
    }
  };
  module.exports = parsePort;
});

// node_modules/relateurl/lib/parse/query.js
var require_query = __commonJS((exports, module) => {
  var parseQuery = function(urlObj, options) {
    urlObj.query.string.full = stringify(urlObj.query.object, false);
    if (options.removeEmptyQueries) {
      urlObj.query.string.stripped = stringify(urlObj.query.object, true);
    }
  };
  var stringify = function(queryObj, removeEmptyQueries) {
    var count = 0;
    var str = "";
    for (var i in queryObj) {
      if (i !== "" && hasOwnProperty.call(queryObj, i) === true) {
        var value = queryObj[i];
        if (value !== "" || !removeEmptyQueries) {
          str += ++count === 1 ? "?" : "&";
          i = encodeURIComponent(i);
          if (value !== "") {
            str += i + "=" + encodeURIComponent(value).replace(/%20/g, "+");
          } else {
            str += i;
          }
        }
      }
    }
    return str;
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = parseQuery;
});

// node_modules/relateurl/lib/parse/urlstring.js
var require_urlstring = __commonJS((exports, module) => {
  var clean = function(urlObj) {
    var scheme = urlObj.protocol;
    if (scheme) {
      if (scheme.indexOf(":") === scheme.length - 1) {
        scheme = scheme.substr(0, scheme.length - 1);
      }
    }
    urlObj.host = {
      full: urlObj.hostname,
      stripped: null
    };
    urlObj.path = {
      absolute: {
        array: null,
        string: urlObj.pathname
      },
      relative: {
        array: null,
        string: null
      }
    };
    urlObj.query = {
      object: urlObj.query,
      string: {
        full: null,
        stripped: null
      }
    };
    urlObj.extra = {
      hrefInfo: {
        minimumPathOnly: null,
        minimumResourceOnly: null,
        minimumQueryOnly: null,
        minimumHashOnly: null,
        empty: null,
        separatorOnlyQuery: urlObj.search === "?"
      },
      portIsDefault: null,
      relation: {
        maximumScheme: null,
        maximumAuth: null,
        maximumHost: null,
        maximumPort: null,
        maximumPath: null,
        maximumResource: null,
        maximumQuery: null,
        maximumHash: null,
        minimumScheme: null,
        minimumAuth: null,
        minimumHost: null,
        minimumPort: null,
        minimumPath: null,
        minimumResource: null,
        minimumQuery: null,
        minimumHash: null,
        overridesQuery: null
      },
      resourceIsIndex: null,
      slashes: urlObj.slashes
    };
    urlObj.resource = null;
    urlObj.scheme = scheme;
    delete urlObj.hostname;
    delete urlObj.pathname;
    delete urlObj.protocol;
    delete urlObj.search;
    delete urlObj.slashes;
    return urlObj;
  };
  var validScheme = function(url, options) {
    var valid = true;
    options.rejectedSchemes.every(function(rejectedScheme) {
      valid = !(url.indexOf(rejectedScheme + ":") === 0);
      return valid;
    });
    return valid;
  };
  var parseUrlString = function(url, options) {
    if (validScheme(url, options)) {
      return clean(_parseUrl(url, true, options.slashesDenoteHost));
    } else {
      return { href: url, valid: false };
    }
  };
  var _parseUrl = (init_url(), __toCommonJS(exports_url)).parse;
  module.exports = parseUrlString;
});

// node_modules/relateurl/lib/util/path.js
var require_path2 = __commonJS((exports, module) => {
  var joinPath = function(pathArray) {
    if (pathArray.length > 0) {
      return pathArray.join("/") + "/";
    } else {
      return "";
    }
  };
  var resolveDotSegments = function(pathArray) {
    var pathAbsolute = [];
    pathArray.forEach(function(dir) {
      if (dir !== "..") {
        if (dir !== ".") {
          pathAbsolute.push(dir);
        }
      } else {
        if (pathAbsolute.length > 0) {
          pathAbsolute.splice(pathAbsolute.length - 1, 1);
        }
      }
    });
    return pathAbsolute;
  };
  module.exports = {
    join: joinPath,
    resolveDotSegments
  };
});

// node_modules/relateurl/lib/parse/index.js
var require_parse = __commonJS((exports, module) => {
  var parseFromUrl = function(url, options, fallback) {
    if (url) {
      var urlObj = parseUrl(url, options);
      var pathArray = pathUtils.resolveDotSegments(urlObj.path.absolute.array);
      urlObj.path.absolute.array = pathArray;
      urlObj.path.absolute.string = "/" + pathUtils.join(pathArray);
      return urlObj;
    } else {
      return fallback;
    }
  };
  var parseUrl = function(url, options) {
    var urlObj = parseUrlString(url, options);
    if (urlObj.valid === false)
      return urlObj;
    parseHost(urlObj, options);
    parsePort(urlObj, options);
    parsePath(urlObj, options);
    parseQuery(urlObj, options);
    hrefInfo(urlObj);
    return urlObj;
  };
  var hrefInfo = require_hrefInfo();
  var parseHost = require_host();
  var parsePath = require_path();
  var parsePort = require_port();
  var parseQuery = require_query();
  var parseUrlString = require_urlstring();
  var pathUtils = require_path2();
  module.exports = {
    from: parseFromUrl,
    to: parseUrl
  };
});

// node_modules/relateurl/lib/relate/findRelation.js
var require_findRelation = __commonJS((exports, module) => {
  var findRelation_upToPath = function(urlObj, siteUrlObj, options) {
    var pathOnly = urlObj.extra.hrefInfo.minimumPathOnly;
    var minimumScheme = urlObj.scheme === siteUrlObj.scheme || !urlObj.scheme;
    var minimumAuth = minimumScheme && (urlObj.auth === siteUrlObj.auth || options.removeAuth || pathOnly);
    var www = options.ignore_www ? "stripped" : "full";
    var minimumHost = minimumAuth && (urlObj.host[www] === siteUrlObj.host[www] || pathOnly);
    var minimumPort = minimumHost && (urlObj.port === siteUrlObj.port || pathOnly);
    urlObj.extra.relation.minimumScheme = minimumScheme;
    urlObj.extra.relation.minimumAuth = minimumAuth;
    urlObj.extra.relation.minimumHost = minimumHost;
    urlObj.extra.relation.minimumPort = minimumPort;
    urlObj.extra.relation.maximumScheme = !minimumScheme || minimumScheme && !minimumAuth;
    urlObj.extra.relation.maximumAuth = !minimumScheme || minimumScheme && !minimumHost;
    urlObj.extra.relation.maximumHost = !minimumScheme || minimumScheme && !minimumPort;
  };
  var findRelation_pathOn = function(urlObj, siteUrlObj, options) {
    var queryOnly = urlObj.extra.hrefInfo.minimumQueryOnly;
    var hashOnly = urlObj.extra.hrefInfo.minimumHashOnly;
    var empty = urlObj.extra.hrefInfo.empty;
    var minimumPort = urlObj.extra.relation.minimumPort;
    var minimumScheme = urlObj.extra.relation.minimumScheme;
    var minimumPath = minimumPort && urlObj.path.absolute.string === siteUrlObj.path.absolute.string;
    var matchingResource = urlObj.resource === siteUrlObj.resource || !urlObj.resource && siteUrlObj.extra.resourceIsIndex || options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex && !siteUrlObj.resource;
    var minimumResource = minimumPath && (matchingResource || queryOnly || hashOnly || empty);
    var query = options.removeEmptyQueries ? "stripped" : "full";
    var urlQuery = urlObj.query.string[query];
    var siteUrlQuery = siteUrlObj.query.string[query];
    var minimumQuery = minimumResource && !!urlQuery && urlQuery === siteUrlQuery || (hashOnly || empty) && !urlObj.extra.hrefInfo.separatorOnlyQuery;
    var minimumHash = minimumQuery && urlObj.hash === siteUrlObj.hash;
    urlObj.extra.relation.minimumPath = minimumPath;
    urlObj.extra.relation.minimumResource = minimumResource;
    urlObj.extra.relation.minimumQuery = minimumQuery;
    urlObj.extra.relation.minimumHash = minimumHash;
    urlObj.extra.relation.maximumPort = !minimumScheme || minimumScheme && !minimumPath;
    urlObj.extra.relation.maximumPath = !minimumScheme || minimumScheme && !minimumResource;
    urlObj.extra.relation.maximumResource = !minimumScheme || minimumScheme && !minimumQuery;
    urlObj.extra.relation.maximumQuery = !minimumScheme || minimumScheme && !minimumHash;
    urlObj.extra.relation.maximumHash = !minimumScheme || minimumScheme && !minimumHash;
    urlObj.extra.relation.overridesQuery = minimumPath && urlObj.extra.relation.maximumResource && !minimumQuery && !!siteUrlQuery;
  };
  module.exports = {
    pathOn: findRelation_pathOn,
    upToPath: findRelation_upToPath
  };
});

// node_modules/relateurl/lib/relate/absolutize.js
var require_absolutize = __commonJS((exports, module) => {
  var absolutize = function(urlObj, siteUrlObj, options) {
    findRelation.upToPath(urlObj, siteUrlObj, options);
    if (urlObj.extra.relation.minimumScheme)
      urlObj.scheme = siteUrlObj.scheme;
    if (urlObj.extra.relation.minimumAuth)
      urlObj.auth = siteUrlObj.auth;
    if (urlObj.extra.relation.minimumHost)
      urlObj.host = objUtils.clone(siteUrlObj.host);
    if (urlObj.extra.relation.minimumPort)
      copyPort(urlObj, siteUrlObj);
    if (urlObj.extra.relation.minimumScheme)
      copyPath(urlObj, siteUrlObj);
    findRelation.pathOn(urlObj, siteUrlObj, options);
    if (urlObj.extra.relation.minimumResource)
      copyResource(urlObj, siteUrlObj);
    if (urlObj.extra.relation.minimumQuery)
      urlObj.query = objUtils.clone(siteUrlObj.query);
    if (urlObj.extra.relation.minimumHash)
      urlObj.hash = siteUrlObj.hash;
  };
  var copyPath = function(urlObj, siteUrlObj) {
    if (urlObj.extra.relation.maximumHost || !urlObj.extra.hrefInfo.minimumResourceOnly) {
      var pathArray = urlObj.path.absolute.array;
      var pathString = "/";
      if (pathArray) {
        if (urlObj.extra.hrefInfo.minimumPathOnly && urlObj.path.absolute.string.indexOf("/") !== 0) {
          pathArray = siteUrlObj.path.absolute.array.concat(pathArray);
        }
        pathArray = pathUtils.resolveDotSegments(pathArray);
        pathString += pathUtils.join(pathArray);
      } else {
        pathArray = [];
      }
      urlObj.path.absolute.array = pathArray;
      urlObj.path.absolute.string = pathString;
    } else {
      urlObj.path = objUtils.clone(siteUrlObj.path);
    }
  };
  var copyPort = function(urlObj, siteUrlObj) {
    urlObj.port = siteUrlObj.port;
    urlObj.extra.portIsDefault = siteUrlObj.extra.portIsDefault;
  };
  var copyResource = function(urlObj, siteUrlObj) {
    urlObj.resource = siteUrlObj.resource;
    urlObj.extra.resourceIsIndex = siteUrlObj.extra.resourceIsIndex;
  };
  var findRelation = require_findRelation();
  var objUtils = require_object();
  var pathUtils = require_path2();
  module.exports = absolutize;
});

// node_modules/relateurl/lib/relate/relativize.js
var require_relativize = __commonJS((exports, module) => {
  var relatePath = function(absolutePath, siteAbsolutePath) {
    var relativePath = [];
    var related = true;
    var parentIndex = -1;
    siteAbsolutePath.forEach(function(siteAbsoluteDir, i) {
      if (related) {
        if (absolutePath[i] !== siteAbsoluteDir) {
          related = false;
        } else {
          parentIndex = i;
        }
      }
      if (!related) {
        relativePath.push("..");
      }
    });
    absolutePath.forEach(function(dir, i) {
      if (i > parentIndex) {
        relativePath.push(dir);
      }
    });
    return relativePath;
  };
  var relativize = function(urlObj, siteUrlObj, options) {
    if (urlObj.extra.relation.minimumScheme) {
      var pathArray = relatePath(urlObj.path.absolute.array, siteUrlObj.path.absolute.array);
      urlObj.path.relative.array = pathArray;
      urlObj.path.relative.string = pathUtils.join(pathArray);
    }
  };
  var pathUtils = require_path2();
  module.exports = relativize;
});

// node_modules/relateurl/lib/relate/index.js
var require_relate = __commonJS((exports, module) => {
  var relateUrl = function(siteUrlObj, urlObj, options) {
    absolutize(urlObj, siteUrlObj, options);
    relativize(urlObj, siteUrlObj, options);
    return urlObj;
  };
  var absolutize = require_absolutize();
  var relativize = require_relativize();
  module.exports = relateUrl;
});

// node_modules/relateurl/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var RelateUrl = function(from, options) {
    this.options = getOptions(options, {
      defaultPorts: { ftp: 21, http: 80, https: 443 },
      directoryIndexes: ["index.html"],
      ignore_www: false,
      output: RelateUrl.SHORTEST,
      rejectedSchemes: ["data", "javascript", "mailto"],
      removeAuth: false,
      removeDirectoryIndexes: true,
      removeEmptyQueries: false,
      removeRootTrailingSlash: true,
      schemeRelative: true,
      site: undefined,
      slashesDenoteHost: true
    });
    this.from = parseUrl.from(from, this.options, null);
  };
  var constants = require_constants();
  var formatUrl = require_format2();
  var getOptions = require_options();
  var objUtils = require_object();
  var parseUrl = require_parse();
  var relateUrl = require_relate();
  RelateUrl.prototype.relate = function(from, to2, options) {
    if (objUtils.isPlainObject(to2)) {
      options = to2;
      to2 = from;
      from = null;
    } else if (!to2) {
      to2 = from;
      from = null;
    }
    options = getOptions(options, this.options);
    from = from || options.site;
    from = parseUrl.from(from, options, this.from);
    if (!from || !from.href) {
      throw new Error("from value not defined.");
    } else if (from.extra.hrefInfo.minimumPathOnly) {
      throw new Error("from value supplied is not absolute: " + from.href);
    }
    to2 = parseUrl.to(to2, options);
    if (to2.valid === false)
      return to2.href;
    to2 = relateUrl(from, to2, options);
    to2 = formatUrl(to2, options);
    return to2;
  };
  RelateUrl.relate = function(from, to2, options) {
    return new RelateUrl().relate(from, to2, options);
  };
  objUtils.shallowMerge(RelateUrl, constants);
  module.exports = RelateUrl;
});

// src/tokenchain.js
var require_tokenchain = __commonJS((exports, module) => {
  var Sorter = function() {
  };
  var TokenChain = function() {
  };
  Sorter.prototype.sort = function(tokens, fromIndex) {
    fromIndex = fromIndex || 0;
    for (var i = 0, len = this.keys.length;i < len; i++) {
      var key = this.keys[i];
      var token = key.slice(1);
      var index = tokens.indexOf(token, fromIndex);
      if (index !== -1) {
        do {
          if (index !== fromIndex) {
            tokens.splice(index, 1);
            tokens.splice(fromIndex, 0, token);
          }
          fromIndex++;
        } while ((index = tokens.indexOf(token, fromIndex)) !== -1);
        return this[key].sort(tokens, fromIndex);
      }
    }
    return tokens;
  };
  TokenChain.prototype = {
    add: function(tokens) {
      var self = this;
      tokens.forEach(function(token) {
        var key = "$" + token;
        if (!self[key]) {
          self[key] = [];
          self[key].processed = 0;
        }
        self[key].push(tokens);
      });
    },
    createSorter: function() {
      var self = this;
      var sorter = new Sorter;
      sorter.keys = Object.keys(self).sort(function(j2, k3) {
        var m4 = self[j2].length;
        var n = self[k3].length;
        return m4 < n ? 1 : m4 > n ? -1 : j2 < k3 ? -1 : j2 > k3 ? 1 : 0;
      }).filter(function(key) {
        if (self[key].processed < self[key].length) {
          var token = key.slice(1);
          var chain = new TokenChain;
          self[key].forEach(function(tokens) {
            var index;
            while ((index = tokens.indexOf(token)) !== -1) {
              tokens.splice(index, 1);
            }
            tokens.forEach(function(token2) {
              self["$" + token2].processed++;
            });
            chain.add(tokens.slice(0));
          });
          sorter[key] = chain.createSorter();
          return true;
        }
        return false;
      });
      return sorter;
    }
  };
  module.exports = TokenChain;
});

// node_modules/uglify-js/lib/utils.js
var exports_utils = {};
var configure_error_stack2, DefaultsError, merge2, Dictionary2, HOP2, List2;
var init_utils = __esm(() => {
  configure_error_stack2 = function(fn) {
    Object.defineProperty(fn.prototype, "stack", {
      get: function() {
        var err = new Error(this.message);
        err.name = this.name;
        try {
          throw err;
        } catch (e) {
          return e.stack;
        }
      }
    });
  };
  DefaultsError = function(msg, defs) {
    this.message = msg;
    this.defs = defs;
  };
  merge2 = function(obj, ext) {
    var count = 0;
    for (var i in ext)
      if (HOP2(ext, i)) {
        obj[i] = ext[i];
        count++;
      }
    return count;
  };
  Dictionary2 = function() {
    this._values = Object.create(null);
    this._size = 0;
  };
  HOP2 = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  DefaultsError.prototype = Object.create(Error.prototype);
  DefaultsError.prototype.constructor = DefaultsError;
  DefaultsError.prototype.name = "DefaultsError";
  configure_error_stack2(DefaultsError);
  List2 = function() {
    function List3(a2, f2) {
      var ret = [];
      for (var i = 0;i < a2.length; i++) {
        var val = f2(a2[i], i);
        if (val === skip)
          continue;
        if (val instanceof Splice) {
          ret.push.apply(ret, val.v);
        } else {
          ret.push(val);
        }
      }
      return ret;
    }
    List3.is_op = function(val) {
      return val === skip || val instanceof Splice;
    };
    List3.splice = function(val) {
      return new Splice(val);
    };
    var skip = List3.skip = {};
    function Splice(val) {
      this.v = val;
    }
    return List3;
  }();
  Dictionary2.prototype = {
    set: function(key, val) {
      if (!this.has(key))
        ++this._size;
      this._values["$" + key] = val;
      return this;
    },
    add: function(key, val) {
      if (this.has(key)) {
        this.get(key).push(val);
      } else {
        this.set(key, [val]);
      }
      return this;
    },
    get: function(key) {
      return this._values["$" + key];
    },
    del: function(key) {
      if (this.has(key)) {
        --this._size;
        delete this._values["$" + key];
      }
      return this;
    },
    has: function(key) {
      return "$" + key in this._values;
    },
    all: function(predicate) {
      for (var i in this._values)
        if (!predicate(this._values[i], i.substr(1)))
          return false;
      return true;
    },
    each: function(f2) {
      for (var i in this._values)
        f2(this._values[i], i.substr(1));
    },
    size: function() {
      return this._size;
    },
    map: function(f2) {
      var ret = [];
      for (var i in this._values)
        ret.push(f2(this._values[i], i.substr(1)));
      return ret;
    },
    clone: function() {
      var ret = new Dictionary2;
      for (var i in this._values)
        ret._values[i] = this._values[i];
      ret._size = this._size;
      return ret;
    },
    toObject: function() {
      return this._values;
    }
  };
  Dictionary2.fromObject = function(obj) {
    var dict = new Dictionary2;
    dict._size = merge2(dict._values, obj);
    return dict;
  };
});

// node_modules/uglify-js/lib/ast.js
var require_ast = __commonJS((exports) => {
  var DEFNODE = function(type, props, methods, base) {
    if (typeof base === "undefined")
      base = AST_Node2;
    props = props ? props.split(/\s+/) : [];
    var self_props = props;
    if (base && base.PROPS)
      props = props.concat(base.PROPS);
    var code = [
      "return function AST_",
      type,
      "(props){",
      "if(props){"
    ];
    props.forEach(function(prop) {
      code.push("this.", prop, "=props.", prop, ";");
    });
    code.push("}");
    var proto = Object.create(base && base.prototype);
    if (methods.initialize || proto.initialize)
      code.push("this.initialize();");
    code.push("};");
    var ctor = new Function(code.join(""))();
    ctor.prototype = proto;
    ctor.prototype.CTOR = ctor;
    ctor.prototype.TYPE = ctor.TYPE = type;
    if (base) {
      ctor.BASE = base;
      base.SUBCLASSES.push(ctor);
    }
    ctor.DEFMETHOD = function(name2, method) {
      this.prototype[name2] = method;
    };
    ctor.PROPS = props;
    ctor.SELF_PROPS = self_props;
    ctor.SUBCLASSES = [];
    for (var name in methods)
      if (HOP(methods, name)) {
        if (/^\$/.test(name)) {
          ctor[name.substr(1)] = methods[name];
        } else {
          ctor.DEFMETHOD(name, methods[name]);
        }
      }
    if (typeof exports !== "undefined")
      exports["AST_" + type] = ctor;
    return ctor;
  };
  var is_statement2 = function(node) {
    return node instanceof AST_Statement2 && !(node instanceof AST_ClassExpression2) && !(node instanceof AST_LambdaExpression2);
  };
  var validate_expression = function(value, prop, multiple, allow_spread, allow_hole) {
    multiple = multiple ? "contain" : "be";
    if (!(value instanceof AST_Node2))
      throw new Error(prop + " must " + multiple + " AST_Node");
    if (value instanceof AST_DefaultValue2)
      throw new Error(prop + " cannot " + multiple + " AST_DefaultValue");
    if (value instanceof AST_Destructured2)
      throw new Error(prop + " cannot " + multiple + " AST_Destructured");
    if (value instanceof AST_Hole2 && !allow_hole)
      throw new Error(prop + " cannot " + multiple + " AST_Hole");
    if (value instanceof AST_Spread2 && !allow_spread)
      throw new Error(prop + " cannot " + multiple + " AST_Spread");
    if (is_statement2(value))
      throw new Error(prop + " cannot " + multiple + " AST_Statement");
    if (value instanceof AST_SymbolDeclaration2) {
      throw new Error(prop + " cannot " + multiple + " AST_SymbolDeclaration");
    }
  };
  var must_be_expression = function(node, prop) {
    validate_expression(node[prop], prop);
  };
  var walk_body2 = function(node, visitor) {
    node.body.forEach(function(node2) {
      node2.walk(visitor);
    });
  };
  var is_arrow2 = function(node) {
    return node instanceof AST_Arrow2 || node instanceof AST_AsyncArrow2;
  };
  var must_be_expressions = function(node, prop, allow_spread, allow_hole) {
    node[prop].forEach(function(node2) {
      validate_expression(node2, prop, true, allow_spread, allow_hole);
    });
  };
  var validate_destructured = function(node, check, allow_default) {
    if (node instanceof AST_DefaultValue2 && allow_default)
      return validate_destructured(node.name, check);
    if (node instanceof AST_Destructured2) {
      if (node.rest != null)
        validate_destructured(node.rest, check);
      if (node instanceof AST_DestructuredArray2)
        return node.elements.forEach(function(node2) {
          if (!(node2 instanceof AST_Hole2))
            validate_destructured(node2, check, true);
        });
      if (node instanceof AST_DestructuredObject2)
        return node.properties.forEach(function(prop) {
          validate_destructured(prop.value, check, true);
        });
    }
    check(node);
  };
  var TreeWalker2 = function(callback) {
    this.callback = callback;
    this.directives = Object.create(null);
    this.stack = [];
  };
  var AST_Token2 = DEFNODE("Token", "type value line col pos endline endcol endpos nlb comments_before comments_after file raw", {}, null);
  var AST_Node2 = DEFNODE("Node", "start end", {
    _clone: function(deep) {
      if (deep) {
        var self = this.clone();
        return self.transform(new TreeTransformer(function(node) {
          if (node !== self) {
            return node.clone(true);
          }
        }));
      }
      return new this.CTOR(this);
    },
    clone: function(deep) {
      return this._clone(deep);
    },
    $documentation: "Base class of all AST nodes",
    $propdoc: {
      start: "[AST_Token] The first token of this node",
      end: "[AST_Token] The last token of this node"
    },
    walk: function(visitor) {
      visitor.visit(this);
    },
    _validate: function() {
      if (this.TYPE == "Node")
        throw new Error("should not instantiate AST_Node");
    },
    validate: function() {
      var ctor = this.CTOR;
      do {
        ctor.prototype._validate.call(this);
      } while (ctor = ctor.BASE);
    },
    validate_ast: function() {
      var marker = {};
      this.walk(new TreeWalker2(function(node) {
        if (node.validate_visited === marker) {
          throw new Error(string_template("cannot reuse {type} from [{file}:{line},{col}]", {
            type: "AST_" + node.TYPE,
            file: node.start.file,
            line: node.start.line,
            col: node.start.col
          }));
        }
        node.validate_visited = marker;
      }));
    }
  }, null);
  (AST_Node2.log_function = function(fn, verbose) {
    if (typeof fn != "function") {
      AST_Node2.info = AST_Node2.warn = noop;
      return;
    }
    var printed = Object.create(null);
    AST_Node2.info = verbose ? function(text, props) {
      log("INFO: " + string_template(text, props));
    } : noop;
    AST_Node2.warn = function(text, props) {
      log("WARN: " + string_template(text, props));
    };
    function log(msg) {
      if (printed[msg])
        return;
      printed[msg] = true;
      fn(msg);
    }
  })();
  var restore_transforms = [];
  AST_Node2.enable_validation = function() {
    AST_Node2.disable_validation();
    (function validate_transform(ctor) {
      ctor.SUBCLASSES.forEach(validate_transform);
      if (!HOP(ctor.prototype, "transform"))
        return;
      var transform = ctor.prototype.transform;
      ctor.prototype.transform = function(tw, in_list) {
        var node = transform.call(this, tw, in_list);
        if (node instanceof AST_Node2) {
          node.validate();
        } else if (!(node === null || in_list && List.is_op(node))) {
          throw new Error("invalid transformed value: " + node);
        }
        return node;
      };
      restore_transforms.push(function() {
        ctor.prototype.transform = transform;
      });
    })(this);
  };
  AST_Node2.disable_validation = function() {
    var restore;
    while (restore = restore_transforms.pop())
      restore();
  };
  var AST_Statement2 = DEFNODE("Statement", null, {
    $documentation: "Base class of all statements",
    _validate: function() {
      if (this.TYPE == "Statement")
        throw new Error("should not instantiate AST_Statement");
    }
  });
  var AST_Debugger2 = DEFNODE("Debugger", null, {
    $documentation: "Represents a debugger statement"
  }, AST_Statement2);
  var AST_Directive2 = DEFNODE("Directive", "quote value", {
    $documentation: "Represents a directive, like \"use strict\";",
    $propdoc: {
      quote: "[string?] the original quote character",
      value: "[string] The value of this directive as a plain string (it's not an AST_String!)"
    },
    _validate: function() {
      if (this.quote != null) {
        if (typeof this.quote != "string")
          throw new Error("quote must be string");
        if (!/^["']$/.test(this.quote))
          throw new Error("invalid quote: " + this.quote);
      }
      if (typeof this.value != "string")
        throw new Error("value must be string");
    }
  }, AST_Statement2);
  var AST_EmptyStatement2 = DEFNODE("EmptyStatement", null, {
    $documentation: "The empty statement (empty block or simply a semicolon)"
  }, AST_Statement2);
  var AST_SimpleStatement2 = DEFNODE("SimpleStatement", "body", {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
      body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "body");
    }
  }, AST_Statement2);
  var AST_BlockScope2 = DEFNODE("BlockScope", "enclosed functions make_def parent_scope variables", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
      enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
      functions: "[Dictionary/S] like `variables`, but only lists function declarations",
      parent_scope: "[AST_Scope?/S] link to the parent scope",
      variables: "[Dictionary/S] a map of name ---> SymbolDef for all variables/functions defined in this scope"
    },
    clone: function(deep) {
      var node = this._clone(deep);
      if (this.enclosed)
        node.enclosed = this.enclosed.slice();
      if (this.functions)
        node.functions = this.functions.clone();
      if (this.variables)
        node.variables = this.variables.clone();
      return node;
    },
    pinned: function() {
      return this.resolve().pinned();
    },
    resolve: function() {
      return this.parent_scope.resolve();
    },
    _validate: function() {
      if (this.TYPE == "BlockScope")
        throw new Error("should not instantiate AST_BlockScope");
      if (this.parent_scope == null)
        return;
      if (!(this.parent_scope instanceof AST_BlockScope2))
        throw new Error("parent_scope must be AST_BlockScope");
      if (!(this.resolve() instanceof AST_Scope2))
        throw new Error("must be contained within AST_Scope");
    }
  }, AST_Statement2);
  var AST_Block2 = DEFNODE("Block", "body", {
    $documentation: "A body of statements (usually braced)",
    $propdoc: {
      body: "[AST_Statement*] an array of statements"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "Block")
        throw new Error("should not instantiate AST_Block");
      this.body.forEach(function(node) {
        if (!is_statement2(node))
          throw new Error("body must contain AST_Statement");
      });
    }
  }, AST_BlockScope2);
  var AST_BlockStatement2 = DEFNODE("BlockStatement", null, {
    $documentation: "A block statement"
  }, AST_Block2);
  var AST_StatementWithBody2 = DEFNODE("StatementWithBody", "body", {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
      body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    },
    _validate: function() {
      if (this.TYPE == "StatementWithBody")
        throw new Error("should not instantiate AST_StatementWithBody");
      if (!is_statement2(this.body))
        throw new Error("body must be AST_Statement");
    }
  }, AST_BlockScope2);
  var AST_LabeledStatement2 = DEFNODE("LabeledStatement", "label", {
    $documentation: "Statement with a label",
    $propdoc: {
      label: "[AST_Label] a label definition"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.label.walk(visitor);
        node.body.walk(visitor);
      });
    },
    clone: function(deep) {
      var node = this._clone(deep);
      if (deep) {
        var label = node.label;
        var def = this.label;
        node.walk(new TreeWalker2(function(node2) {
          if (node2 instanceof AST_LoopControl2) {
            if (!node2.label || node2.label.thedef !== def)
              return;
            node2.label.thedef = label;
            label.references.push(node2);
            return true;
          }
          if (node2 instanceof AST_Scope2)
            return true;
        }));
      }
      return node;
    },
    _validate: function() {
      if (!(this.label instanceof AST_Label2))
        throw new Error("label must be AST_Label");
    }
  }, AST_StatementWithBody2);
  var AST_IterationStatement2 = DEFNODE("IterationStatement", null, {
    $documentation: "Internal class.  All loops inherit from it.",
    _validate: function() {
      if (this.TYPE == "IterationStatement")
        throw new Error("should not instantiate AST_IterationStatement");
    }
  }, AST_StatementWithBody2);
  var AST_DWLoop2 = DEFNODE("DWLoop", "condition", {
    $documentation: "Base class for do/while statements",
    $propdoc: {
      condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    },
    _validate: function() {
      if (this.TYPE == "DWLoop")
        throw new Error("should not instantiate AST_DWLoop");
      must_be_expression(this, "condition");
    }
  }, AST_IterationStatement2);
  var AST_Do2 = DEFNODE("Do", null, {
    $documentation: "A `do` statement",
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.body.walk(visitor);
        node.condition.walk(visitor);
      });
    }
  }, AST_DWLoop2);
  var AST_While2 = DEFNODE("While", null, {
    $documentation: "A `while` statement",
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.condition.walk(visitor);
        node.body.walk(visitor);
      });
    }
  }, AST_DWLoop2);
  var AST_For2 = DEFNODE("For", "init condition step", {
    $documentation: "A `for` statement",
    $propdoc: {
      init: "[AST_Node?] the `for` initialization code, or null if empty",
      condition: "[AST_Node?] the `for` termination clause, or null if empty",
      step: "[AST_Node?] the `for` update clause, or null if empty"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.init)
          node.init.walk(visitor);
        if (node.condition)
          node.condition.walk(visitor);
        if (node.step)
          node.step.walk(visitor);
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      if (this.init != null) {
        if (!(this.init instanceof AST_Node2))
          throw new Error("init must be AST_Node");
        if (is_statement2(this.init) && !(this.init instanceof AST_Definitions2)) {
          throw new Error("init cannot be AST_Statement");
        }
      }
      if (this.condition != null)
        must_be_expression(this, "condition");
      if (this.step != null)
        must_be_expression(this, "step");
    }
  }, AST_IterationStatement2);
  var AST_ForEnumeration2 = DEFNODE("ForEnumeration", "init object", {
    $documentation: "Base class for enumeration loops, i.e. `for ... in`, `for ... of` & `for await ... of`",
    $propdoc: {
      init: "[AST_Node] the assignment target during iteration",
      object: "[AST_Node] the object to iterate over"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.init.walk(visitor);
        node.object.walk(visitor);
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "ForEnumeration")
        throw new Error("should not instantiate AST_ForEnumeration");
      if (this.init instanceof AST_Definitions2) {
        if (this.init.definitions.length != 1)
          throw new Error("init must have single declaration");
      } else {
        validate_destructured(this.init, function(node) {
          if (!(node instanceof AST_PropAccess2 || node instanceof AST_SymbolRef2)) {
            throw new Error("init must be assignable: " + node.TYPE);
          }
        });
      }
      must_be_expression(this, "object");
    }
  }, AST_IterationStatement2);
  var AST_ForIn2 = DEFNODE("ForIn", null, {
    $documentation: "A `for ... in` statement"
  }, AST_ForEnumeration2);
  var AST_ForOf2 = DEFNODE("ForOf", null, {
    $documentation: "A `for ... of` statement"
  }, AST_ForEnumeration2);
  var AST_ForAwaitOf2 = DEFNODE("ForAwaitOf", null, {
    $documentation: "A `for await ... of` statement"
  }, AST_ForOf2);
  var AST_With2 = DEFNODE("With", "expression", {
    $documentation: "A `with` statement",
    $propdoc: {
      expression: "[AST_Node] the `with` expression"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
    }
  }, AST_StatementWithBody2);
  var AST_Scope2 = DEFNODE("Scope", "uses_eval uses_with", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
      uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
      uses_with: "[boolean/S] tells whether this scope uses the `with` statement"
    },
    pinned: function() {
      return this.uses_eval || this.uses_with;
    },
    resolve: return_this,
    _validate: function() {
      if (this.TYPE == "Scope")
        throw new Error("should not instantiate AST_Scope");
    }
  }, AST_Block2);
  var AST_Toplevel2 = DEFNODE("Toplevel", "globals", {
    $documentation: "The toplevel scope",
    $propdoc: {
      globals: "[Dictionary/S] a map of name ---> SymbolDef for all undeclared names"
    },
    wrap: function(name) {
      var body = this.body;
      return parse([
        "(function(exports){'$ORIG';})(typeof ",
        name,
        "=='undefined'?(",
        name,
        "={}):",
        name,
        ");"
      ].join(""), {
        filename: "wrap=" + JSON.stringify(name)
      }).transform(new TreeTransformer(function(node) {
        if (node instanceof AST_Directive2 && node.value == "$ORIG") {
          return List.splice(body);
        }
      }));
    },
    enclose: function(args_values) {
      if (typeof args_values != "string")
        args_values = "";
      var index = args_values.indexOf(":");
      if (index < 0)
        index = args_values.length;
      var body = this.body;
      return parse([
        "(function(",
        args_values.slice(0, index),
        '){"$ORIG"})(',
        args_values.slice(index + 1),
        ")"
      ].join(""), {
        filename: "enclose=" + JSON.stringify(args_values)
      }).transform(new TreeTransformer(function(node) {
        if (node instanceof AST_Directive2 && node.value == "$ORIG") {
          return List.splice(body);
        }
      }));
    }
  }, AST_Scope2);
  var AST_Lambda2 = DEFNODE("Lambda", "argnames length_read rest uses_arguments", {
    $documentation: "Base class for functions",
    $propdoc: {
      argnames: "[(AST_DefaultValue|AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals",
      length_read: "[boolean/S] whether length property of this function is accessed",
      rest: "[(AST_Destructured|AST_SymbolFunarg)?] rest parameter, or null if absent",
      uses_arguments: "[boolean/S] whether this function accesses the arguments array"
    },
    each_argname: function(visit) {
      var tw = new TreeWalker2(function(node) {
        if (node instanceof AST_DefaultValue2) {
          node.name.walk(tw);
          return true;
        }
        if (node instanceof AST_DestructuredKeyVal2) {
          node.value.walk(tw);
          return true;
        }
        if (node instanceof AST_SymbolFunarg2)
          visit(node);
      });
      this.argnames.forEach(function(argname) {
        argname.walk(tw);
      });
      if (this.rest)
        this.rest.walk(tw);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.name)
          node.name.walk(visitor);
        node.argnames.forEach(function(argname) {
          argname.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "Lambda")
        throw new Error("should not instantiate AST_Lambda");
      this.argnames.forEach(function(node) {
        validate_destructured(node, function(node2) {
          if (!(node2 instanceof AST_SymbolFunarg2))
            throw new Error("argnames must be AST_SymbolFunarg[]");
        }, true);
      });
      if (this.rest != null)
        validate_destructured(this.rest, function(node) {
          if (!(node instanceof AST_SymbolFunarg2))
            throw new Error("rest must be AST_SymbolFunarg");
        });
    }
  }, AST_Scope2);
  var AST_Accessor2 = DEFNODE("Accessor", null, {
    $documentation: "A getter/setter function",
    _validate: function() {
      if (this.name != null)
        throw new Error("name must be null");
    }
  }, AST_Lambda2);
  var AST_LambdaExpression2 = DEFNODE("LambdaExpression", "inlined", {
    $documentation: "Base class for function expressions",
    $propdoc: {
      inlined: "[boolean/S] whether this function has been inlined"
    },
    _validate: function() {
      if (this.TYPE == "LambdaExpression")
        throw new Error("should not instantiate AST_LambdaExpression");
    }
  }, AST_Lambda2);
  var AST_Arrow2 = DEFNODE("Arrow", "value", {
    $documentation: "An arrow function expression",
    $propdoc: {
      value: "[AST_Node?] simple return expression, or null if using function body."
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.argnames.forEach(function(argname) {
          argname.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
        if (node.value) {
          node.value.walk(visitor);
        } else {
          walk_body2(node, visitor);
        }
      });
    },
    _validate: function() {
      if (this.name != null)
        throw new Error("name must be null");
      if (this.uses_arguments)
        throw new Error("uses_arguments must be false");
      if (this.value != null) {
        must_be_expression(this, "value");
        if (this.body.length)
          throw new Error("body must be empty if value exists");
      }
    }
  }, AST_LambdaExpression2);
  var AST_AsyncArrow2 = DEFNODE("AsyncArrow", "value", {
    $documentation: "An asynchronous arrow function expression",
    $propdoc: {
      value: "[AST_Node?] simple return expression, or null if using function body."
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.argnames.forEach(function(argname) {
          argname.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
        if (node.value) {
          node.value.walk(visitor);
        } else {
          walk_body2(node, visitor);
        }
      });
    },
    _validate: function() {
      if (this.name != null)
        throw new Error("name must be null");
      if (this.uses_arguments)
        throw new Error("uses_arguments must be false");
      if (this.value != null) {
        must_be_expression(this, "value");
        if (this.body.length)
          throw new Error("body must be empty if value exists");
      }
    }
  }, AST_LambdaExpression2);
  var AST_AsyncFunction2 = DEFNODE("AsyncFunction", "name", {
    $documentation: "An asynchronous function expression",
    $propdoc: {
      name: "[AST_SymbolLambda?] the name of this function, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolLambda2))
          throw new Error("name must be AST_SymbolLambda");
      }
    }
  }, AST_LambdaExpression2);
  var AST_AsyncGeneratorFunction2 = DEFNODE("AsyncGeneratorFunction", "name", {
    $documentation: "An asynchronous generator function expression",
    $propdoc: {
      name: "[AST_SymbolLambda?] the name of this function, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolLambda2))
          throw new Error("name must be AST_SymbolLambda");
      }
    }
  }, AST_LambdaExpression2);
  var AST_Function2 = DEFNODE("Function", "name", {
    $documentation: "A function expression",
    $propdoc: {
      name: "[AST_SymbolLambda?] the name of this function, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolLambda2))
          throw new Error("name must be AST_SymbolLambda");
      }
    }
  }, AST_LambdaExpression2);
  var AST_GeneratorFunction2 = DEFNODE("GeneratorFunction", "name", {
    $documentation: "A generator function expression",
    $propdoc: {
      name: "[AST_SymbolLambda?] the name of this function, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolLambda2))
          throw new Error("name must be AST_SymbolLambda");
      }
    }
  }, AST_LambdaExpression2);
  var AST_LambdaDefinition2 = DEFNODE("LambdaDefinition", "inlined name", {
    $documentation: "Base class for function definitions",
    $propdoc: {
      inlined: "[boolean/S] whether this function has been inlined",
      name: "[AST_SymbolDefun] the name of this function"
    },
    _validate: function() {
      if (this.TYPE == "LambdaDefinition")
        throw new Error("should not instantiate AST_LambdaDefinition");
      if (!(this.name instanceof AST_SymbolDefun2))
        throw new Error("name must be AST_SymbolDefun");
    }
  }, AST_Lambda2);
  var AST_AsyncDefun2 = DEFNODE("AsyncDefun", null, {
    $documentation: "An asynchronous function definition"
  }, AST_LambdaDefinition2);
  var AST_AsyncGeneratorDefun2 = DEFNODE("AsyncGeneratorDefun", null, {
    $documentation: "An asynchronous generator function definition"
  }, AST_LambdaDefinition2);
  var AST_Defun2 = DEFNODE("Defun", null, {
    $documentation: "A function definition"
  }, AST_LambdaDefinition2);
  var AST_GeneratorDefun2 = DEFNODE("GeneratorDefun", null, {
    $documentation: "A generator function definition"
  }, AST_LambdaDefinition2);
  var AST_Class2 = DEFNODE("Class", "extends name properties", {
    $documentation: "Base class for class literals",
    $propdoc: {
      extends: "[AST_Node?] the super class, or null if not specified",
      properties: "[AST_ClassProperty*] array of class properties"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.name)
          node.name.walk(visitor);
        if (node.extends)
          node.extends.walk(visitor);
        node.properties.forEach(function(prop) {
          prop.walk(visitor);
        });
      });
    },
    _validate: function() {
      if (this.TYPE == "Class")
        throw new Error("should not instantiate AST_Class");
      if (this.extends != null)
        must_be_expression(this, "extends");
      this.properties.forEach(function(node) {
        if (!(node instanceof AST_ClassProperty2))
          throw new Error("properties must contain AST_ClassProperty");
      });
    }
  }, AST_BlockScope2);
  var AST_DefClass2 = DEFNODE("DefClass", null, {
    $documentation: "A class definition",
    $propdoc: {
      name: "[AST_SymbolDefClass] the name of this class"
    },
    _validate: function() {
      if (!(this.name instanceof AST_SymbolDefClass2))
        throw new Error("name must be AST_SymbolDefClass");
    }
  }, AST_Class2);
  var AST_ClassExpression2 = DEFNODE("ClassExpression", null, {
    $documentation: "A class expression",
    $propdoc: {
      name: "[AST_SymbolClass?] the name of this class, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolClass2))
          throw new Error("name must be AST_SymbolClass");
      }
    }
  }, AST_Class2);
  var AST_ClassProperty2 = DEFNODE("ClassProperty", "key private static value", {
    $documentation: "Base class for `class` properties",
    $propdoc: {
      key: "[string|AST_Node] property name (AST_Node for computed property)",
      private: "[boolean] whether this is a private property",
      static: "[boolean] whether this is a static property",
      value: "[AST_Node?] property value (AST_Accessor for getters/setters, AST_LambdaExpression for methods, null if not specified for fields)"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.key instanceof AST_Node2)
          node.key.walk(visitor);
        if (node.value)
          node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "ClassProperty")
        throw new Error("should not instantiate AST_ClassProperty");
      if (typeof this.key != "string") {
        if (!(this.key instanceof AST_Node2))
          throw new Error("key must be string or AST_Node");
        must_be_expression(this, "key");
      }
      if (this.value != null) {
        if (!(this.value instanceof AST_Node2))
          throw new Error("value must be AST_Node");
      }
    }
  });
  var AST_ClassField2 = DEFNODE("ClassField", null, {
    $documentation: "A `class` field",
    _validate: function() {
      if (this.value != null)
        must_be_expression(this, "value");
    }
  }, AST_ClassProperty2);
  var AST_ClassGetter2 = DEFNODE("ClassGetter", null, {
    $documentation: "A `class` getter",
    _validate: function() {
      if (!(this.value instanceof AST_Accessor2))
        throw new Error("value must be AST_Accessor");
    }
  }, AST_ClassProperty2);
  var AST_ClassSetter2 = DEFNODE("ClassSetter", null, {
    $documentation: "A `class` setter",
    _validate: function() {
      if (!(this.value instanceof AST_Accessor2))
        throw new Error("value must be AST_Accessor");
    }
  }, AST_ClassProperty2);
  var AST_ClassMethod2 = DEFNODE("ClassMethod", null, {
    $documentation: "A `class` method",
    _validate: function() {
      if (!(this.value instanceof AST_LambdaExpression2))
        throw new Error("value must be AST_LambdaExpression");
      if (is_arrow2(this.value))
        throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");
      if (this.value.name != null)
        throw new Error("name of class method's lambda must be null");
    }
  }, AST_ClassProperty2);
  var AST_Jump2 = DEFNODE("Jump", null, {
    $documentation: "Base class for \u201Cjumps\u201D (for now that's `return`, `throw`, `break` and `continue`)",
    _validate: function() {
      if (this.TYPE == "Jump")
        throw new Error("should not instantiate AST_Jump");
    }
  }, AST_Statement2);
  var AST_Exit2 = DEFNODE("Exit", "value", {
    $documentation: "Base class for \u201Cexits\u201D (`return` and `throw`)",
    $propdoc: {
      value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.value)
          node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "Exit")
        throw new Error("should not instantiate AST_Exit");
    }
  }, AST_Jump2);
  var AST_Return2 = DEFNODE("Return", null, {
    $documentation: "A `return` statement",
    _validate: function() {
      if (this.value != null)
        must_be_expression(this, "value");
    }
  }, AST_Exit2);
  var AST_Throw2 = DEFNODE("Throw", null, {
    $documentation: "A `throw` statement",
    _validate: function() {
      must_be_expression(this, "value");
    }
  }, AST_Exit2);
  var AST_LoopControl2 = DEFNODE("LoopControl", "label", {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
      label: "[AST_LabelRef?] the label, or null if none"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.label)
          node.label.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "LoopControl")
        throw new Error("should not instantiate AST_LoopControl");
      if (this.label != null) {
        if (!(this.label instanceof AST_LabelRef2))
          throw new Error("label must be AST_LabelRef");
      }
    }
  }, AST_Jump2);
  var AST_Break2 = DEFNODE("Break", null, {
    $documentation: "A `break` statement"
  }, AST_LoopControl2);
  var AST_Continue2 = DEFNODE("Continue", null, {
    $documentation: "A `continue` statement"
  }, AST_LoopControl2);
  var AST_If2 = DEFNODE("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
      condition: "[AST_Node] the `if` condition",
      alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.condition.walk(visitor);
        node.body.walk(visitor);
        if (node.alternative)
          node.alternative.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "condition");
      if (this.alternative != null) {
        if (!is_statement2(this.alternative))
          throw new Error("alternative must be AST_Statement");
      }
    }
  }, AST_StatementWithBody2);
  var AST_Switch2 = DEFNODE("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
      expression: "[AST_Node] the `switch` \u201Cdiscriminant\u201D"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
      this.body.forEach(function(node) {
        if (!(node instanceof AST_SwitchBranch2))
          throw new Error("body must be AST_SwitchBranch[]");
      });
    }
  }, AST_Block2);
  var AST_SwitchBranch2 = DEFNODE("SwitchBranch", null, {
    $documentation: "Base class for `switch` branches",
    _validate: function() {
      if (this.TYPE == "SwitchBranch")
        throw new Error("should not instantiate AST_SwitchBranch");
    }
  }, AST_Block2);
  var AST_Default2 = DEFNODE("Default", null, {
    $documentation: "A `default` switch branch"
  }, AST_SwitchBranch2);
  var AST_Case2 = DEFNODE("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
      expression: "[AST_Node] the `case` expression"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
    }
  }, AST_SwitchBranch2);
  var AST_Try2 = DEFNODE("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
      bcatch: "[AST_Catch?] the catch block, or null if not present",
      bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        walk_body2(node, visitor);
        if (node.bcatch)
          node.bcatch.walk(visitor);
        if (node.bfinally)
          node.bfinally.walk(visitor);
      });
    },
    _validate: function() {
      if (this.bcatch != null) {
        if (!(this.bcatch instanceof AST_Catch2))
          throw new Error("bcatch must be AST_Catch");
      }
      if (this.bfinally != null) {
        if (!(this.bfinally instanceof AST_Finally2))
          throw new Error("bfinally must be AST_Finally");
      }
    }
  }, AST_Block2);
  var AST_Catch2 = DEFNODE("Catch", "argname", {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {
      argname: "[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.argname)
          node.argname.walk(visitor);
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      if (this.argname != null)
        validate_destructured(this.argname, function(node) {
          if (!(node instanceof AST_SymbolCatch2))
            throw new Error("argname must be AST_SymbolCatch");
        });
    }
  }, AST_Block2);
  var AST_Finally2 = DEFNODE("Finally", null, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
  }, AST_Block2);
  var AST_Definitions2 = DEFNODE("Definitions", "definitions", {
    $documentation: "Base class for `var` nodes (variable declarations/initializations)",
    $propdoc: {
      definitions: "[AST_VarDef*] array of variable definitions"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.definitions.forEach(function(defn) {
          defn.walk(visitor);
        });
      });
    },
    _validate: function() {
      if (this.TYPE == "Definitions")
        throw new Error("should not instantiate AST_Definitions");
      if (this.definitions.length < 1)
        throw new Error("must have at least one definition");
    }
  }, AST_Statement2);
  var AST_Const2 = DEFNODE("Const", null, {
    $documentation: "A `const` statement",
    _validate: function() {
      this.definitions.forEach(function(node) {
        if (!(node instanceof AST_VarDef2))
          throw new Error("definitions must be AST_VarDef[]");
        validate_destructured(node.name, function(node2) {
          if (!(node2 instanceof AST_SymbolConst2))
            throw new Error("name must be AST_SymbolConst");
        });
      });
    }
  }, AST_Definitions2);
  var AST_Let2 = DEFNODE("Let", null, {
    $documentation: "A `let` statement",
    _validate: function() {
      this.definitions.forEach(function(node) {
        if (!(node instanceof AST_VarDef2))
          throw new Error("definitions must be AST_VarDef[]");
        validate_destructured(node.name, function(node2) {
          if (!(node2 instanceof AST_SymbolLet2))
            throw new Error("name must be AST_SymbolLet");
        });
      });
    }
  }, AST_Definitions2);
  var AST_Var2 = DEFNODE("Var", null, {
    $documentation: "A `var` statement",
    _validate: function() {
      this.definitions.forEach(function(node) {
        if (!(node instanceof AST_VarDef2))
          throw new Error("definitions must be AST_VarDef[]");
        validate_destructured(node.name, function(node2) {
          if (!(node2 instanceof AST_SymbolVar2))
            throw new Error("name must be AST_SymbolVar");
        });
      });
    }
  }, AST_Definitions2);
  var AST_VarDef2 = DEFNODE("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
      name: "[AST_Destructured|AST_SymbolVar] name of the variable",
      value: "[AST_Node?] initializer, or null of there's no initializer"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.name.walk(visitor);
        if (node.value)
          node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (this.value != null)
        must_be_expression(this, "value");
    }
  });
  var AST_ExportDeclaration2 = DEFNODE("ExportDeclaration", "body", {
    $documentation: "An `export` statement",
    $propdoc: {
      body: "[AST_DefClass|AST_Definitions|AST_LambdaDefinition] the statement to export"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      if (!(this.body instanceof AST_DefClass2 || this.body instanceof AST_Definitions2 || this.body instanceof AST_LambdaDefinition2)) {
        throw new Error("body must be AST_DefClass, AST_Definitions or AST_LambdaDefinition");
      }
    }
  }, AST_Statement2);
  var AST_ExportDefault2 = DEFNODE("ExportDefault", "body", {
    $documentation: "An `export default` statement",
    $propdoc: {
      body: "[AST_Node] the default export"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      if (!(this.body instanceof AST_DefClass2 || this.body instanceof AST_LambdaDefinition2)) {
        must_be_expression(this, "body");
      }
    }
  }, AST_Statement2);
  var AST_ExportForeign2 = DEFNODE("ExportForeign", "aliases keys path quote", {
    $documentation: "An `export ... from '...'` statement",
    $propdoc: {
      aliases: "[string*] array of aliases to export",
      keys: "[string*] array of keys to import",
      path: "[string] the path to import module",
      quote: "[string?] the original quote character"
    },
    _validate: function() {
      if (this.aliases.length != this.keys.length) {
        throw new Error("aliases:key length mismatch: " + this.aliases.length + " != " + this.keys.length);
      }
      this.aliases.forEach(function(name) {
        if (typeof name != "string")
          throw new Error("aliases must contain string");
      });
      this.keys.forEach(function(name) {
        if (typeof name != "string")
          throw new Error("keys must contain string");
      });
      if (typeof this.path != "string")
        throw new Error("path must be string");
      if (this.quote != null) {
        if (typeof this.quote != "string")
          throw new Error("quote must be string");
        if (!/^["']$/.test(this.quote))
          throw new Error("invalid quote: " + this.quote);
      }
    }
  }, AST_Statement2);
  var AST_ExportReferences2 = DEFNODE("ExportReferences", "properties", {
    $documentation: "An `export { ... }` statement",
    $propdoc: {
      properties: "[AST_SymbolExport*] array of aliases to export"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.properties.forEach(function(prop) {
          prop.walk(visitor);
        });
      });
    },
    _validate: function() {
      this.properties.forEach(function(prop) {
        if (!(prop instanceof AST_SymbolExport2))
          throw new Error("properties must contain AST_SymbolExport");
      });
    }
  }, AST_Statement2);
  var AST_Import2 = DEFNODE("Import", "all default path properties quote", {
    $documentation: "An `import` statement",
    $propdoc: {
      all: "[AST_SymbolImport?] the imported namespace, or null if not specified",
      default: "[AST_SymbolImport?] the alias for default `export`, or null if not specified",
      path: "[string] the path to import module",
      properties: "[(AST_SymbolImport*)?] array of aliases, or null if not specified",
      quote: "[string?] the original quote character"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.all)
          node.all.walk(visitor);
        if (node.default)
          node.default.walk(visitor);
        if (node.properties)
          node.properties.forEach(function(prop) {
            prop.walk(visitor);
          });
      });
    },
    _validate: function() {
      if (this.all != null) {
        if (!(this.all instanceof AST_SymbolImport2))
          throw new Error("all must be AST_SymbolImport");
        if (this.properties != null)
          throw new Error("cannot import both * and {} in the same statement");
      }
      if (this.default != null) {
        if (!(this.default instanceof AST_SymbolImport2))
          throw new Error("default must be AST_SymbolImport");
        if (this.default.key !== "")
          throw new Error("invalid default key: " + this.default.key);
      }
      if (typeof this.path != "string")
        throw new Error("path must be string");
      if (this.properties != null)
        this.properties.forEach(function(node) {
          if (!(node instanceof AST_SymbolImport2))
            throw new Error("properties must contain AST_SymbolImport");
        });
      if (this.quote != null) {
        if (typeof this.quote != "string")
          throw new Error("quote must be string");
        if (!/^["']$/.test(this.quote))
          throw new Error("invalid quote: " + this.quote);
      }
    }
  }, AST_Statement2);
  var AST_DefaultValue2 = DEFNODE("DefaultValue", "name value", {
    $documentation: "A default value declaration",
    $propdoc: {
      name: "[AST_Destructured|AST_SymbolDeclaration] name of the variable",
      value: "[AST_Node] value to assign if variable is `undefined`"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.name.walk(visitor);
        node.value.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "value");
    }
  });
  var AST_Call2 = DEFNODE("Call", "args expression optional pure terminal", {
    $documentation: "A function call expression",
    $propdoc: {
      args: "[AST_Node*] array of arguments",
      expression: "[AST_Node] expression to invoke as function",
      optional: "[boolean] whether the expression is optional chaining",
      pure: "[string/S] marker for side-effect-free call expression",
      terminal: "[boolean] whether the chain has ended"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        node.args.forEach(function(arg) {
          arg.walk(visitor);
        });
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
      must_be_expressions(this, "args", true);
    }
  });
  var AST_New2 = DEFNODE("New", null, {
    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties",
    _validate: function() {
      if (this.optional)
        throw new Error("optional must be false");
      if (this.terminal)
        throw new Error("terminal must be false");
    }
  }, AST_Call2);
  var AST_Sequence2 = DEFNODE("Sequence", "expressions", {
    $documentation: "A sequence expression (comma-separated expressions)",
    $propdoc: {
      expressions: "[AST_Node*] array of expressions (at least two)"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expressions.forEach(function(expr) {
          expr.walk(visitor);
        });
      });
    },
    _validate: function() {
      if (this.expressions.length < 2)
        throw new Error("expressions must contain multiple elements");
      must_be_expressions(this, "expressions");
    }
  });
  var AST_PropAccess2 = DEFNODE("PropAccess", "expression optional property terminal", {
    $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
    $propdoc: {
      expression: "[AST_Node] the \u201Ccontainer\u201D expression",
      optional: "[boolean] whether the expression is optional chaining",
      property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",
      terminal: "[boolean] whether the chain has ended"
    },
    get_property: function() {
      var p2 = this.property;
      if (p2 instanceof AST_Constant2)
        return p2.value;
      if (p2 instanceof AST_UnaryPrefix2 && p2.operator == "void" && p2.expression instanceof AST_Constant2)
        return;
      return p2;
    },
    _validate: function() {
      if (this.TYPE == "PropAccess")
        throw new Error("should not instantiate AST_PropAccess");
      must_be_expression(this, "expression");
    }
  });
  var AST_Dot2 = DEFNODE("Dot", null, {
    $documentation: "A dotted property access expression",
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
      });
    },
    _validate: function() {
      if (typeof this.property != "string")
        throw new Error("property must be string");
    }
  }, AST_PropAccess2);
  var AST_Sub2 = DEFNODE("Sub", null, {
    $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        node.property.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "property");
    }
  }, AST_PropAccess2);
  var AST_Spread2 = DEFNODE("Spread", "expression", {
    $documentation: "Spread expression in array/object literals or function calls",
    $propdoc: {
      expression: "[AST_Node] expression to be expanded"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
    }
  });
  var AST_Unary2 = DEFNODE("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
      operator: "[string] the operator",
      expression: "[AST_Node] expression that this unary operator applies to"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "Unary")
        throw new Error("should not instantiate AST_Unary");
      if (typeof this.operator != "string")
        throw new Error("operator must be string");
      must_be_expression(this, "expression");
    }
  });
  var AST_UnaryPrefix2 = DEFNODE("UnaryPrefix", null, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
  }, AST_Unary2);
  var AST_UnaryPostfix2 = DEFNODE("UnaryPostfix", null, {
    $documentation: "Unary postfix expression, i.e. `i++`"
  }, AST_Unary2);
  var AST_Binary2 = DEFNODE("Binary", "operator left right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
      left: "[AST_Node] left-hand side expression",
      operator: "[string] the operator",
      right: "[AST_Node] right-hand side expression"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.left.walk(visitor);
        node.right.walk(visitor);
      });
    },
    _validate: function() {
      if (!(this instanceof AST_Assign2))
        must_be_expression(this, "left");
      if (typeof this.operator != "string")
        throw new Error("operator must be string");
      must_be_expression(this, "right");
    }
  });
  var AST_Conditional2 = DEFNODE("Conditional", "condition consequent alternative", {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
      condition: "[AST_Node]",
      consequent: "[AST_Node]",
      alternative: "[AST_Node]"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.condition.walk(visitor);
        node.consequent.walk(visitor);
        node.alternative.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "condition");
      must_be_expression(this, "consequent");
      must_be_expression(this, "alternative");
    }
  });
  var AST_Assign2 = DEFNODE("Assign", null, {
    $documentation: "An assignment expression \u2014 `a = b + 5`",
    _validate: function() {
      if (this.operator.indexOf("=") < 0)
        throw new Error('operator must contain "="');
      if (this.left instanceof AST_Destructured2) {
        if (this.operator != "=")
          throw new Error("invalid destructuring operator: " + this.operator);
        validate_destructured(this.left, function(node) {
          if (!(node instanceof AST_PropAccess2 || node instanceof AST_SymbolRef2)) {
            throw new Error("left must be assignable: " + node.TYPE);
          }
        });
      }
    }
  }, AST_Binary2);
  var AST_Await2 = DEFNODE("Await", "expression", {
    $documentation: "An await expression",
    $propdoc: {
      expression: "[AST_Node] expression with Promise to resolve on"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
    }
  });
  var AST_Yield2 = DEFNODE("Yield", "expression nested", {
    $documentation: "A yield expression",
    $propdoc: {
      expression: "[AST_Node?] return value for iterator, or null if undefined",
      nested: "[boolean] whether to iterate over expression as generator"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.expression)
          node.expression.walk(visitor);
      });
    },
    _validate: function() {
      if (this.expression != null) {
        must_be_expression(this, "expression");
      } else if (this.nested) {
        throw new Error("yield* must contain expression");
      }
    }
  });
  var AST_Array2 = DEFNODE("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
      elements: "[AST_Node*] array of elements"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.elements.forEach(function(element) {
          element.walk(visitor);
        });
      });
    },
    _validate: function() {
      must_be_expressions(this, "elements", true, true);
    }
  });
  var AST_Destructured2 = DEFNODE("Destructured", "rest", {
    $documentation: "Base class for destructured literal",
    $propdoc: {
      rest: "[(AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)?] rest parameter, or null if absent"
    },
    _validate: function() {
      if (this.TYPE == "Destructured")
        throw new Error("should not instantiate AST_Destructured");
    }
  });
  var AST_DestructuredArray2 = DEFNODE("DestructuredArray", "elements", {
    $documentation: "A destructured array literal",
    $propdoc: {
      elements: "[(AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)*] array of elements"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.elements.forEach(function(element) {
          element.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
      });
    }
  }, AST_Destructured2);
  var AST_DestructuredKeyVal2 = DEFNODE("DestructuredKeyVal", "key value", {
    $documentation: "A key: value destructured property",
    $propdoc: {
      key: "[string|AST_Node] property name.  For computed property this is an AST_Node.",
      value: "[AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef] property value"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.key instanceof AST_Node2)
          node.key.walk(visitor);
        node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (typeof this.key != "string") {
        if (!(this.key instanceof AST_Node2))
          throw new Error("key must be string or AST_Node");
        must_be_expression(this, "key");
      }
      if (!(this.value instanceof AST_Node2))
        throw new Error("value must be AST_Node");
    }
  });
  var AST_DestructuredObject2 = DEFNODE("DestructuredObject", "properties", {
    $documentation: "A destructured object literal",
    $propdoc: {
      properties: "[AST_DestructuredKeyVal*] array of properties"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.properties.forEach(function(prop) {
          prop.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
      });
    },
    _validate: function() {
      this.properties.forEach(function(node) {
        if (!(node instanceof AST_DestructuredKeyVal2))
          throw new Error("properties must be AST_DestructuredKeyVal[]");
      });
    }
  }, AST_Destructured2);
  var AST_Object2 = DEFNODE("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
      properties: "[(AST_ObjectProperty|AST_Spread)*] array of properties"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.properties.forEach(function(prop) {
          prop.walk(visitor);
        });
      });
    },
    _validate: function() {
      this.properties.forEach(function(node) {
        if (!(node instanceof AST_ObjectProperty2 || node instanceof AST_Spread2)) {
          throw new Error("properties must contain AST_ObjectProperty and/or AST_Spread only");
        }
      });
    }
  });
  var AST_ObjectProperty2 = DEFNODE("ObjectProperty", "key value", {
    $documentation: "Base class for literal object properties",
    $propdoc: {
      key: "[string|AST_Node] property name.  For computed property this is an AST_Node.",
      value: "[AST_Node] property value.  For getters and setters this is an AST_Accessor."
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.key instanceof AST_Node2)
          node.key.walk(visitor);
        node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "ObjectProperty")
        throw new Error("should not instantiate AST_ObjectProperty");
      if (typeof this.key != "string") {
        if (!(this.key instanceof AST_Node2))
          throw new Error("key must be string or AST_Node");
        must_be_expression(this, "key");
      }
      if (!(this.value instanceof AST_Node2))
        throw new Error("value must be AST_Node");
    }
  });
  var AST_ObjectKeyVal2 = DEFNODE("ObjectKeyVal", null, {
    $documentation: "A key: value object property",
    _validate: function() {
      must_be_expression(this, "value");
    }
  }, AST_ObjectProperty2);
  var AST_ObjectMethod2 = DEFNODE("ObjectMethod", null, {
    $documentation: "A key(){} object property",
    _validate: function() {
      if (!(this.value instanceof AST_LambdaExpression2))
        throw new Error("value must be AST_LambdaExpression");
      if (is_arrow2(this.value))
        throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");
      if (this.value.name != null)
        throw new Error("name of object method's lambda must be null");
    }
  }, AST_ObjectKeyVal2);
  var AST_ObjectSetter2 = DEFNODE("ObjectSetter", null, {
    $documentation: "An object setter property",
    _validate: function() {
      if (!(this.value instanceof AST_Accessor2))
        throw new Error("value must be AST_Accessor");
    }
  }, AST_ObjectProperty2);
  var AST_ObjectGetter2 = DEFNODE("ObjectGetter", null, {
    $documentation: "An object getter property",
    _validate: function() {
      if (!(this.value instanceof AST_Accessor2))
        throw new Error("value must be AST_Accessor");
    }
  }, AST_ObjectProperty2);
  var AST_Symbol2 = DEFNODE("Symbol", "scope name thedef", {
    $documentation: "Base class for all symbols",
    $propdoc: {
      name: "[string] name of this symbol",
      scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
      thedef: "[SymbolDef/S] the definition of this symbol"
    },
    _validate: function() {
      if (this.TYPE == "Symbol")
        throw new Error("should not instantiate AST_Symbol");
      if (typeof this.name != "string")
        throw new Error("name must be string");
    }
  });
  var AST_SymbolDeclaration2 = DEFNODE("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var, function name or argument, symbol in catch)"
  }, AST_Symbol2);
  var AST_SymbolConst2 = DEFNODE("SymbolConst", null, {
    $documentation: "Symbol defining a constant"
  }, AST_SymbolDeclaration2);
  var AST_SymbolImport2 = DEFNODE("SymbolImport", "key", {
    $documentation: "Symbol defined by an `import` statement",
    $propdoc: {
      key: "[string] the original `export` name"
    },
    _validate: function() {
      if (typeof this.key != "string")
        throw new Error("key must be string");
    }
  }, AST_SymbolConst2);
  var AST_SymbolLet2 = DEFNODE("SymbolLet", null, {
    $documentation: "Symbol defining a lexical-scoped variable"
  }, AST_SymbolDeclaration2);
  var AST_SymbolVar2 = DEFNODE("SymbolVar", null, {
    $documentation: "Symbol defining a variable"
  }, AST_SymbolDeclaration2);
  var AST_SymbolFunarg2 = DEFNODE("SymbolFunarg", null, {
    $documentation: "Symbol naming a function argument"
  }, AST_SymbolVar2);
  var AST_SymbolDefun2 = DEFNODE("SymbolDefun", null, {
    $documentation: "Symbol defining a function"
  }, AST_SymbolDeclaration2);
  var AST_SymbolLambda2 = DEFNODE("SymbolLambda", null, {
    $documentation: "Symbol naming a function expression"
  }, AST_SymbolDeclaration2);
  var AST_SymbolDefClass2 = DEFNODE("SymbolDefClass", null, {
    $documentation: "Symbol defining a class"
  }, AST_SymbolConst2);
  var AST_SymbolClass2 = DEFNODE("SymbolClass", null, {
    $documentation: "Symbol naming a class expression"
  }, AST_SymbolConst2);
  var AST_SymbolCatch2 = DEFNODE("SymbolCatch", null, {
    $documentation: "Symbol naming the exception in catch"
  }, AST_SymbolDeclaration2);
  var AST_Label2 = DEFNODE("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
      references: "[AST_LoopControl*] a list of nodes referring to this label"
    },
    initialize: function() {
      this.references = [];
      this.thedef = this;
    }
  }, AST_Symbol2);
  var AST_SymbolRef2 = DEFNODE("SymbolRef", "fixed in_arg redef", {
    $documentation: "Reference to some symbol (not definition/declaration)"
  }, AST_Symbol2);
  var AST_SymbolExport2 = DEFNODE("SymbolExport", "alias", {
    $documentation: "Reference in an `export` statement",
    $propdoc: {
      alias: "[string] the `export` alias"
    },
    _validate: function() {
      if (typeof this.alias != "string")
        throw new Error("alias must be string");
    }
  }, AST_SymbolRef2);
  var AST_LabelRef2 = DEFNODE("LabelRef", null, {
    $documentation: "Reference to a label symbol"
  }, AST_Symbol2);
  var AST_ObjectIdentity2 = DEFNODE("ObjectIdentity", null, {
    $documentation: "Base class for `super` & `this`",
    _validate: function() {
      if (this.TYPE == "ObjectIdentity")
        throw new Error("should not instantiate AST_ObjectIdentity");
    }
  }, AST_Symbol2);
  var AST_Super2 = DEFNODE("Super", null, {
    $documentation: "The `super` symbol",
    _validate: function() {
      if (this.name !== "super")
        throw new Error('name must be "super"');
    }
  }, AST_ObjectIdentity2);
  var AST_This2 = DEFNODE("This", null, {
    $documentation: "The `this` symbol",
    _validate: function() {
      if (this.TYPE == "This" && this.name !== "this")
        throw new Error('name must be "this"');
    }
  }, AST_ObjectIdentity2);
  var AST_NewTarget2 = DEFNODE("NewTarget", null, {
    $documentation: "The `new.target` symbol",
    initialize: function() {
      this.name = "new.target";
    },
    _validate: function() {
      if (this.name !== "new.target")
        throw new Error('name must be "new.target": ' + this.name);
    }
  }, AST_This2);
  var AST_Template2 = DEFNODE("Template", "expressions strings tag", {
    $documentation: "A template literal, i.e. tag`str1${expr1}...strN${exprN}strN+1`",
    $propdoc: {
      expressions: "[AST_Node*] the placeholder expressions",
      strings: "[string*] the raw text segments",
      tag: "[AST_Node] tag function, or null if absent"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.tag)
          node.tag.walk(visitor);
        node.expressions.forEach(function(expr) {
          expr.walk(visitor);
        });
      });
    },
    _validate: function() {
      if (this.expressions.length + 1 != this.strings.length) {
        throw new Error("malformed template with " + this.expressions.length + " placeholder(s) but " + this.strings.length + " text segment(s)");
      }
      must_be_expressions(this, "expressions");
      this.strings.forEach(function(string) {
        if (typeof string != "string")
          throw new Error("strings must contain string");
      });
      if (this.tag != null)
        must_be_expression(this, "tag");
    }
  });
  var AST_Constant2 = DEFNODE("Constant", null, {
    $documentation: "Base class for all constants",
    _validate: function() {
      if (this.TYPE == "Constant")
        throw new Error("should not instantiate AST_Constant");
    }
  });
  var AST_String2 = DEFNODE("String", "quote value", {
    $documentation: "A string literal",
    $propdoc: {
      quote: "[string?] the original quote character",
      value: "[string] the contents of this string"
    },
    _validate: function() {
      if (this.quote != null) {
        if (typeof this.quote != "string")
          throw new Error("quote must be string");
        if (!/^["']$/.test(this.quote))
          throw new Error("invalid quote: " + this.quote);
      }
      if (typeof this.value != "string")
        throw new Error("value must be string");
    }
  }, AST_Constant2);
  var AST_Number2 = DEFNODE("Number", "value", {
    $documentation: "A number literal",
    $propdoc: {
      value: "[number] the numeric value"
    },
    _validate: function() {
      if (typeof this.value != "number")
        throw new Error("value must be number");
      if (!isFinite(this.value))
        throw new Error("value must be finite");
      if (this.value < 0)
        throw new Error("value cannot be negative");
    }
  }, AST_Constant2);
  var AST_BigInt2 = DEFNODE("BigInt", "value", {
    $documentation: "A BigInt literal",
    $propdoc: {
      value: "[string] the numeric representation"
    },
    _validate: function() {
      if (typeof this.value != "string")
        throw new Error("value must be string");
      if (this.value[0] == "-")
        throw new Error("value cannot be negative");
    }
  }, AST_Constant2);
  var AST_RegExp2 = DEFNODE("RegExp", "value", {
    $documentation: "A regexp literal",
    $propdoc: {
      value: "[RegExp] the actual regexp"
    },
    _validate: function() {
      if (!(this.value instanceof RegExp))
        throw new Error("value must be RegExp");
    }
  }, AST_Constant2);
  var AST_Atom2 = DEFNODE("Atom", null, {
    $documentation: "Base class for atoms",
    _validate: function() {
      if (this.TYPE == "Atom")
        throw new Error("should not instantiate AST_Atom");
    }
  }, AST_Constant2);
  var AST_Null2 = DEFNODE("Null", null, {
    $documentation: "The `null` atom",
    value: null
  }, AST_Atom2);
  var AST_NaN2 = DEFNODE("NaN", null, {
    $documentation: "The impossible value",
    value: 0 / 0
  }, AST_Atom2);
  var AST_Undefined2 = DEFNODE("Undefined", null, {
    $documentation: "The `undefined` value",
    value: function() {
    }()
  }, AST_Atom2);
  var AST_Hole2 = DEFNODE("Hole", null, {
    $documentation: "A hole in an array",
    value: function() {
    }()
  }, AST_Atom2);
  var AST_Infinity2 = DEFNODE("Infinity", null, {
    $documentation: "The `Infinity` value",
    value: 1 / 0
  }, AST_Atom2);
  var AST_Boolean2 = DEFNODE("Boolean", null, {
    $documentation: "Base class for booleans",
    _validate: function() {
      if (this.TYPE == "Boolean")
        throw new Error("should not instantiate AST_Boolean");
    }
  }, AST_Atom2);
  var AST_False2 = DEFNODE("False", null, {
    $documentation: "The `false` atom",
    value: false
  }, AST_Boolean2);
  var AST_True2 = DEFNODE("True", null, {
    $documentation: "The `true` atom",
    value: true
  }, AST_Boolean2);
  TreeWalker2.prototype = {
    visit: function(node, descend) {
      this.push(node);
      var done = this.callback(node, descend || noop);
      if (!done && descend)
        descend();
      this.pop();
    },
    parent: function(n) {
      return this.stack[this.stack.length - 2 - (n || 0)];
    },
    push: function(node) {
      if (node instanceof AST_Lambda2) {
        this.directives = Object.create(this.directives);
      } else if (node instanceof AST_Directive2 && !this.directives[node.value]) {
        this.directives[node.value] = node;
      }
      this.stack.push(node);
    },
    pop: function() {
      var node = this.stack.pop();
      if (node instanceof AST_Lambda2) {
        this.directives = Object.getPrototypeOf(this.directives);
      }
    },
    self: function() {
      return this.stack[this.stack.length - 1];
    },
    find_parent: function(type) {
      var stack = this.stack;
      for (var i = stack.length;--i >= 0; ) {
        var x2 = stack[i];
        if (x2 instanceof type)
          return x2;
      }
    },
    has_directive: function(type) {
      var dir = this.directives[type];
      if (dir)
        return dir;
      var node = this.stack[this.stack.length - 1];
      if (node instanceof AST_Scope2) {
        for (var i = 0;i < node.body.length; ++i) {
          var st2 = node.body[i];
          if (!(st2 instanceof AST_Directive2))
            break;
          if (st2.value == type)
            return st2;
        }
      }
    },
    loopcontrol_target: function(node) {
      var stack = this.stack;
      if (node.label)
        for (var i = stack.length;--i >= 0; ) {
          var x2 = stack[i];
          if (x2 instanceof AST_LabeledStatement2 && x2.label.name == node.label.name)
            return x2.body;
        }
      else
        for (var i = stack.length;--i >= 0; ) {
          var x2 = stack[i];
          if (x2 instanceof AST_IterationStatement2 || node instanceof AST_Break2 && x2 instanceof AST_Switch2)
            return x2;
        }
    },
    in_boolean_context: function() {
      var self = this.self();
      for (var i = 0, p2;p2 = this.parent(i); i++) {
        if (p2 instanceof AST_Conditional2 && p2.condition === self || p2 instanceof AST_DWLoop2 && p2.condition === self || p2 instanceof AST_For2 && p2.condition === self || p2 instanceof AST_If2 && p2.condition === self || p2 instanceof AST_Return2 && p2.in_bool || p2 instanceof AST_Sequence2 && p2.tail_node() !== self || p2 instanceof AST_SimpleStatement2 || p2 instanceof AST_UnaryPrefix2 && p2.operator == "!" && p2.expression === self) {
          return true;
        }
        if (p2 instanceof AST_Binary2 && (p2.operator == "&&" || p2.operator == "||") || p2 instanceof AST_Conditional2 || p2.tail_node() === self) {
          self = p2;
        } else if (p2 instanceof AST_Return2) {
          for (var call, fn = p2;call = this.parent(++i); fn = call) {
            if (call.TYPE == "Call") {
              if (!(fn instanceof AST_Lambda2) || fn.name)
                return false;
            } else if (fn instanceof AST_Lambda2) {
              return false;
            }
          }
        } else {
          return false;
        }
      }
    }
  };
});

// node_modules/uglify-js/lib/transform.js
var exports_transform = {};
var TreeTransformer2;
var init_transform = __esm(() => {
  TreeTransformer2 = function(before, after) {
    TreeWalker.call(this);
    this.before = before;
    this.after = after;
  };
  TreeTransformer2.prototype = new TreeWalker;
  (function(DEF) {
    function do_list(list, tw) {
      return List(list, function(node) {
        return node.transform(tw, true);
      });
    }
    DEF(AST_Node, noop);
    DEF(AST_LabeledStatement, function(self, tw) {
      self.label = self.label.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_SimpleStatement, function(self, tw) {
      self.body = self.body.transform(tw);
    });
    DEF(AST_Block, function(self, tw) {
      self.body = do_list(self.body, tw);
    });
    DEF(AST_Do, function(self, tw) {
      self.body = self.body.transform(tw);
      self.condition = self.condition.transform(tw);
    });
    DEF(AST_While, function(self, tw) {
      self.condition = self.condition.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_For, function(self, tw) {
      if (self.init)
        self.init = self.init.transform(tw);
      if (self.condition)
        self.condition = self.condition.transform(tw);
      if (self.step)
        self.step = self.step.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_ForEnumeration, function(self, tw) {
      self.init = self.init.transform(tw);
      self.object = self.object.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_With, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_Exit, function(self, tw) {
      if (self.value)
        self.value = self.value.transform(tw);
    });
    DEF(AST_LoopControl, function(self, tw) {
      if (self.label)
        self.label = self.label.transform(tw);
    });
    DEF(AST_If, function(self, tw) {
      self.condition = self.condition.transform(tw);
      self.body = self.body.transform(tw);
      if (self.alternative)
        self.alternative = self.alternative.transform(tw);
    });
    DEF(AST_Switch, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.body = do_list(self.body, tw);
    });
    DEF(AST_Case, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.body = do_list(self.body, tw);
    });
    DEF(AST_Try, function(self, tw) {
      self.body = do_list(self.body, tw);
      if (self.bcatch)
        self.bcatch = self.bcatch.transform(tw);
      if (self.bfinally)
        self.bfinally = self.bfinally.transform(tw);
    });
    DEF(AST_Catch, function(self, tw) {
      if (self.argname)
        self.argname = self.argname.transform(tw);
      self.body = do_list(self.body, tw);
    });
    DEF(AST_Definitions, function(self, tw) {
      self.definitions = do_list(self.definitions, tw);
    });
    DEF(AST_VarDef, function(self, tw) {
      self.name = self.name.transform(tw);
      if (self.value)
        self.value = self.value.transform(tw);
    });
    DEF(AST_DefaultValue, function(self, tw) {
      self.name = self.name.transform(tw);
      self.value = self.value.transform(tw);
    });
    DEF(AST_Lambda, function(self, tw) {
      if (self.name)
        self.name = self.name.transform(tw);
      self.argnames = do_list(self.argnames, tw);
      if (self.rest)
        self.rest = self.rest.transform(tw);
      self.body = do_list(self.body, tw);
    });
    function transform_arrow(self, tw) {
      self.argnames = do_list(self.argnames, tw);
      if (self.rest)
        self.rest = self.rest.transform(tw);
      if (self.value) {
        self.value = self.value.transform(tw);
      } else {
        self.body = do_list(self.body, tw);
      }
    }
    DEF(AST_Arrow, transform_arrow);
    DEF(AST_AsyncArrow, transform_arrow);
    DEF(AST_Class, function(self, tw) {
      if (self.name)
        self.name = self.name.transform(tw);
      if (self.extends)
        self.extends = self.extends.transform(tw);
      self.properties = do_list(self.properties, tw);
    });
    DEF(AST_ClassProperty, function(self, tw) {
      if (self.key instanceof AST_Node)
        self.key = self.key.transform(tw);
      if (self.value)
        self.value = self.value.transform(tw);
    });
    DEF(AST_Call, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.args = do_list(self.args, tw);
    });
    DEF(AST_Sequence, function(self, tw) {
      self.expressions = do_list(self.expressions, tw);
    });
    DEF(AST_Await, function(self, tw) {
      self.expression = self.expression.transform(tw);
    });
    DEF(AST_Yield, function(self, tw) {
      if (self.expression)
        self.expression = self.expression.transform(tw);
    });
    DEF(AST_Dot, function(self, tw) {
      self.expression = self.expression.transform(tw);
    });
    DEF(AST_Sub, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.property = self.property.transform(tw);
    });
    DEF(AST_Spread, function(self, tw) {
      self.expression = self.expression.transform(tw);
    });
    DEF(AST_Unary, function(self, tw) {
      self.expression = self.expression.transform(tw);
    });
    DEF(AST_Binary, function(self, tw) {
      self.left = self.left.transform(tw);
      self.right = self.right.transform(tw);
    });
    DEF(AST_Conditional, function(self, tw) {
      self.condition = self.condition.transform(tw);
      self.consequent = self.consequent.transform(tw);
      self.alternative = self.alternative.transform(tw);
    });
    DEF(AST_Array, function(self, tw) {
      self.elements = do_list(self.elements, tw);
    });
    DEF(AST_DestructuredArray, function(self, tw) {
      self.elements = do_list(self.elements, tw);
      if (self.rest)
        self.rest = self.rest.transform(tw);
    });
    DEF(AST_DestructuredKeyVal, function(self, tw) {
      if (self.key instanceof AST_Node)
        self.key = self.key.transform(tw);
      self.value = self.value.transform(tw);
    });
    DEF(AST_DestructuredObject, function(self, tw) {
      self.properties = do_list(self.properties, tw);
      if (self.rest)
        self.rest = self.rest.transform(tw);
    });
    DEF(AST_Object, function(self, tw) {
      self.properties = do_list(self.properties, tw);
    });
    DEF(AST_ObjectProperty, function(self, tw) {
      if (self.key instanceof AST_Node)
        self.key = self.key.transform(tw);
      self.value = self.value.transform(tw);
    });
    DEF(AST_ExportDeclaration, function(self, tw) {
      self.body = self.body.transform(tw);
    });
    DEF(AST_ExportDefault, function(self, tw) {
      self.body = self.body.transform(tw);
    });
    DEF(AST_ExportReferences, function(self, tw) {
      self.properties = do_list(self.properties, tw);
    });
    DEF(AST_Import, function(self, tw) {
      if (self.all)
        self.all = self.all.transform(tw);
      if (self.default)
        self.default = self.default.transform(tw);
      if (self.properties)
        self.properties = do_list(self.properties, tw);
    });
    DEF(AST_Template, function(self, tw) {
      if (self.tag)
        self.tag = self.tag.transform(tw);
      self.expressions = do_list(self.expressions, tw);
    });
  })(function(node, descend) {
    node.DEFMETHOD("transform", function(tw, in_list) {
      var x2, y3;
      tw.push(this);
      if (tw.before)
        x2 = tw.before(this, descend, in_list);
      if (typeof x2 === "undefined") {
        x2 = this;
        descend(x2, tw);
        if (tw.after) {
          y3 = tw.after(x2, in_list);
          if (typeof y3 !== "undefined")
            x2 = y3;
        }
      }
      tw.pop();
      return x2;
    });
  });
});

// node_modules/uglify-js/lib/parse.js
var exports_parse = {};
var JS_Parse_Error2, KEYWORDS, KEYWORDS_ATOM, RESERVED_WORDS2, KEYWORDS_BEFORE_EXPRESSION, OPERATORS, NEWLINE_CHARS, OPERATOR_CHARS, PUNC_OPENERS, PUNC_SEPARATORS, PUNC_CLOSERS, PUNC_AFTER_EXPRESSION, PUNC_BEFORE_EXPRESSION, PUNC_CHARS, WHITESPACE_CHARS, NON_IDENTIFIER_CHARS, UNARY_PREFIX, UNARY_POSTFIX2, ASSIGNMENT, PRECEDENCE2, ATOMIC_START_TOKEN;
var init_parse = __esm(() => {
  JS_Parse_Error2 = function(message, filename, line, col, pos) {
    this.message = message;
    this.filename = filename;
    this.line = line;
    this.col = col;
    this.pos = pos;
  };
  KEYWORDS = "break case catch class const continue debugger default delete do else extends finally for function if in instanceof let new return switch throw try typeof var void while with";
  KEYWORDS_ATOM = "false null true";
  RESERVED_WORDS2 = [
    "abstract async await boolean byte char double enum export final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield",
    KEYWORDS_ATOM,
    KEYWORDS
  ].join(" ");
  KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case";
  KEYWORDS = makePredicate(KEYWORDS);
  RESERVED_WORDS2 = makePredicate(RESERVED_WORDS2);
  KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
  KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
  OPERATORS = makePredicate([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "/",
    "%",
    "**",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    "**=",
    ">>=",
    "<<=",
    ">>>=",
    "&=",
    "|=",
    "^=",
    "&&",
    "||",
    "??",
    "&&=",
    "||=",
    "??="
  ]);
  NEWLINE_CHARS = `
\r\u2028\u2029`;
  OPERATOR_CHARS = "+-*&%=<>!?|~^";
  PUNC_OPENERS = "[{(";
  PUNC_SEPARATORS = ",;:";
  PUNC_CLOSERS = ")}]";
  PUNC_AFTER_EXPRESSION = PUNC_SEPARATORS + PUNC_CLOSERS;
  PUNC_BEFORE_EXPRESSION = PUNC_OPENERS + PUNC_SEPARATORS;
  PUNC_CHARS = PUNC_BEFORE_EXPRESSION + "`" + PUNC_CLOSERS;
  WHITESPACE_CHARS = NEWLINE_CHARS + " \xA0\t\f\v\u200B\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF";
  NON_IDENTIFIER_CHARS = makePredicate(characters("./'\"#" + OPERATOR_CHARS + PUNC_CHARS + WHITESPACE_CHARS));
  NEWLINE_CHARS = makePredicate(characters(NEWLINE_CHARS));
  OPERATOR_CHARS = makePredicate(characters(OPERATOR_CHARS));
  PUNC_AFTER_EXPRESSION = makePredicate(characters(PUNC_AFTER_EXPRESSION));
  PUNC_BEFORE_EXPRESSION = makePredicate(characters(PUNC_BEFORE_EXPRESSION));
  PUNC_CHARS = makePredicate(characters(PUNC_CHARS));
  WHITESPACE_CHARS = makePredicate(characters(WHITESPACE_CHARS));
  JS_Parse_Error2.prototype = Object.create(Error.prototype);
  JS_Parse_Error2.prototype.constructor = JS_Parse_Error2;
  JS_Parse_Error2.prototype.name = "SyntaxError";
  configure_error_stack(JS_Parse_Error2);
  UNARY_PREFIX = makePredicate("typeof void delete -- ++ ! ~ - +");
  UNARY_POSTFIX2 = makePredicate("-- ++");
  ASSIGNMENT = makePredicate("= += -= /= *= %= **= >>= <<= >>>= &= |= ^= &&= ||= ??=");
  PRECEDENCE2 = function(a2, ret) {
    for (var i = 0;i < a2.length; ) {
      var b5 = a2[i++];
      for (var j2 = 0;j2 < b5.length; j2++) {
        ret[b5[j2]] = i;
      }
    }
    return ret;
  }([
    ["??"],
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ["==", "===", "!=", "!=="],
    ["<", ">", "<=", ">=", "in", "instanceof"],
    [">>", "<<", ">>>"],
    ["+", "-"],
    ["*", "/", "%"],
    ["**"]
  ], {});
  ATOMIC_START_TOKEN = makePredicate("atom bigint num regexp string");
});

// node_modules/uglify-js/lib/scope.js
var exports_scope = {};
var SymbolDef, is_lhs2, init_block_vars, init_scope_vars, names_in_use, next_mangled_name, _default_mangler_options, unary_side_effects2, base542;
var init_scope = __esm(() => {
  SymbolDef = function(id, scope, orig, init) {
    this.eliminated = 0;
    this.exported = false;
    this.global = false;
    this.id = id;
    this.init = init;
    this.mangled_name = null;
    this.name = orig.name;
    this.orig = [orig];
    this.references = [];
    this.replaced = 0;
    this.scope = scope;
    this.undeclared = false;
  };
  is_lhs2 = function(node, parent) {
    if (parent instanceof AST_Assign)
      return parent.left === node && node;
    if (parent instanceof AST_DefaultValue)
      return parent.name === node && node;
    if (parent instanceof AST_Destructured)
      return node;
    if (parent instanceof AST_DestructuredKeyVal)
      return node;
    if (parent instanceof AST_ForEnumeration)
      return parent.init === node && node;
    if (parent instanceof AST_Unary)
      return unary_side_effects2[parent.operator] && parent.expression;
  };
  init_block_vars = function(scope, parent) {
    scope.enclosed = [];
    scope.parent_scope = parent;
    scope.functions = new Dictionary;
    scope.variables = new Dictionary;
    if (parent)
      scope.make_def = parent.make_def;
  };
  init_scope_vars = function(scope, parent) {
    init_block_vars(scope, parent);
    scope.uses_eval = false;
    scope.uses_with = false;
  };
  names_in_use = function(scope, options) {
    var names = scope.names_in_use;
    if (!names) {
      scope.cname = -1;
      scope.cname_holes = [];
      scope.names_in_use = names = Object.create(null);
      var cache = options.cache && options.cache.props;
      scope.enclosed.forEach(function(def) {
        if (def.unmangleable(options))
          names[def.name] = true;
        if (def.global && cache && cache.has(def.name)) {
          names[cache.get(def.name)] = true;
        }
      });
    }
    return names;
  };
  next_mangled_name = function(def, options) {
    var scope = def.scope;
    var in_use = names_in_use(scope, options);
    var holes = scope.cname_holes;
    var names = Object.create(null);
    var scopes = [scope];
    def.forEach(function(sym) {
      var scope2 = sym.scope;
      do {
        if (scopes.indexOf(scope2) < 0) {
          for (var name2 in names_in_use(scope2, options)) {
            names[name2] = true;
          }
          scopes.push(scope2);
        } else
          break;
      } while (scope2 = scope2.parent_scope);
    });
    var name;
    for (var i = 0;i < holes.length; i++) {
      name = base542(holes[i]);
      if (names[name])
        continue;
      holes.splice(i, 1);
      in_use[name] = true;
      return name;
    }
    while (true) {
      name = base542(++scope.cname);
      if (in_use[name] || RESERVED_WORDS[name] || options.reserved.has[name])
        continue;
      if (!names[name])
        break;
      holes.push(scope.cname);
    }
    in_use[name] = true;
    return name;
  };
  _default_mangler_options = function(options) {
    options = defaults(options, {
      eval: false,
      ie: false,
      keep_fnames: false,
      reserved: [],
      toplevel: false,
      v8: false,
      webkit: false
    });
    if (!Array.isArray(options.reserved))
      options.reserved = [];
    push_uniq(options.reserved, "arguments");
    options.reserved.has = makePredicate(options.reserved);
    return options;
  };
  SymbolDef.prototype = {
    forEach: function(fn) {
      this.orig.forEach(fn);
      this.references.forEach(fn);
    },
    mangle: function(options) {
      var cache = options.cache && options.cache.props;
      if (this.global && cache && cache.has(this.name)) {
        this.mangled_name = cache.get(this.name);
      } else if (!this.mangled_name && !this.unmangleable(options)) {
        var def = this.redefined();
        if (def) {
          this.mangled_name = def.mangled_name || def.name;
        } else {
          this.mangled_name = next_mangled_name(this, options);
        }
        if (this.global && cache) {
          cache.set(this.name, this.mangled_name);
        }
      }
    },
    redefined: function() {
      var self = this;
      var scope = self.defun;
      if (!scope)
        return;
      var name = self.name;
      var def = scope.variables.get(name) || scope instanceof AST_Toplevel && scope.globals.get(name) || self.orig[0] instanceof AST_SymbolConst && find_if(function(def2) {
        return def2.name == name;
      }, scope.enclosed);
      if (def && def !== self)
        return def.redefined() || def;
    },
    unmangleable: function(options) {
      return this.global && !options.toplevel || this.exported || this.undeclared || !options.eval && this.scope.pinned() || options.keep_fnames && (this.orig[0] instanceof AST_SymbolClass || this.orig[0] instanceof AST_SymbolDefClass || this.orig[0] instanceof AST_SymbolDefun || this.orig[0] instanceof AST_SymbolLambda);
    }
  };
  unary_side_effects2 = makePredicate("delete ++ --");
  AST_Toplevel.DEFMETHOD("figure_out_scope", function(options) {
    options = defaults(options, {
      cache: null,
      ie: false
    });
    var self = this;
    var defun = null;
    var exported = false;
    var next_def_id = 0;
    var scope = self.parent_scope = null;
    var tw = new TreeWalker(function(node, descend) {
      if (node instanceof AST_DefClass) {
        var save_exported = exported;
        exported = tw.parent() instanceof AST_ExportDeclaration;
        node.name.walk(tw);
        exported = save_exported;
        walk_scope(function() {
          if (node.extends)
            node.extends.walk(tw);
          node.properties.forEach(function(prop) {
            prop.walk(tw);
          });
        });
        return true;
      }
      if (node instanceof AST_Definitions) {
        var save_exported = exported;
        exported = tw.parent() instanceof AST_ExportDeclaration;
        descend();
        exported = save_exported;
        return true;
      }
      if (node instanceof AST_LambdaDefinition) {
        var save_exported = exported;
        exported = tw.parent() instanceof AST_ExportDeclaration;
        node.name.walk(tw);
        exported = save_exported;
        walk_scope(function() {
          node.argnames.forEach(function(argname) {
            argname.walk(tw);
          });
          if (node.rest)
            node.rest.walk(tw);
          walk_body(node, tw);
        });
        return true;
      }
      if (node instanceof AST_SwitchBranch) {
        node.init_vars(scope);
        descend();
        return true;
      }
      if (node instanceof AST_Try) {
        walk_scope(function() {
          walk_body(node, tw);
        });
        if (node.bcatch)
          node.bcatch.walk(tw);
        if (node.bfinally)
          node.bfinally.walk(tw);
        return true;
      }
      if (node instanceof AST_With) {
        var s2 = scope;
        do {
          s2 = s2.resolve();
          if (s2.uses_with)
            break;
          s2.uses_with = true;
        } while (s2 = s2.parent_scope);
        walk_scope(descend);
        return true;
      }
      if (node instanceof AST_BlockScope) {
        walk_scope(descend);
        return true;
      }
      if (node instanceof AST_Symbol) {
        node.scope = scope;
      }
      if (node instanceof AST_Label) {
        node.thedef = node;
        node.references = [];
      }
      if (node instanceof AST_SymbolCatch) {
        scope.def_variable(node).defun = defun;
      } else if (node instanceof AST_SymbolConst) {
        var def = scope.def_variable(node);
        def.defun = defun;
        if (exported)
          def.exported = true;
      } else if (node instanceof AST_SymbolDefun) {
        var def = defun.def_function(node, tw.parent());
        if (exported)
          def.exported = true;
        entangle(defun, scope);
      } else if (node instanceof AST_SymbolFunarg) {
        defun.def_variable(node);
        entangle(defun, scope);
      } else if (node instanceof AST_SymbolLambda) {
        var def = defun.def_function(node, node.name == "arguments" ? undefined : defun);
        if (options.ie)
          def.defun = defun.parent_scope.resolve();
      } else if (node instanceof AST_SymbolLet) {
        var def = scope.def_variable(node);
        if (exported)
          def.exported = true;
      } else if (node instanceof AST_SymbolVar) {
        var def = defun.def_variable(node, node instanceof AST_SymbolImport ? undefined : null);
        if (exported)
          def.exported = true;
        entangle(defun, scope);
      }
      function walk_scope(descend2) {
        node.init_vars(scope);
        var save_defun = defun;
        var save_scope = scope;
        if (node instanceof AST_Scope)
          defun = node;
        scope = node;
        descend2();
        scope = save_scope;
        defun = save_defun;
      }
      function entangle(defun2, scope2) {
        if (defun2 === scope2)
          return;
        node.mark_enclosed(options);
        var def2 = scope2.find_variable(node.name);
        if (node.thedef === def2)
          return;
        node.thedef = def2;
        def2.orig.push(node);
        node.mark_enclosed(options);
      }
    });
    self.make_def = function(orig, init) {
      return new SymbolDef(++next_def_id, this, orig, init);
    };
    self.walk(tw);
    self.globals = new Dictionary;
    var in_arg = [];
    var tw = new TreeWalker(function(node) {
      if (node instanceof AST_Catch) {
        if (!(node.argname instanceof AST_Destructured))
          return;
        in_arg.push(node);
        node.argname.walk(tw);
        in_arg.pop();
        walk_body(node, tw);
        return true;
      }
      if (node instanceof AST_Lambda) {
        in_arg.push(node);
        node.argnames.forEach(function(argname) {
          argname.walk(tw);
        });
        if (node.rest)
          node.rest.walk(tw);
        in_arg.pop();
        walk_lambda(node, tw);
        return true;
      }
      if (node instanceof AST_LoopControl) {
        if (node.label)
          node.label.thedef.references.push(node);
        return true;
      }
      if (node instanceof AST_SymbolDeclaration) {
        var def = node.definition();
        def.preinit = def.references.length;
        if (node instanceof AST_SymbolCatch) {
          var redef = def.redefined();
          if (redef)
            for (var s2 = node.scope;s2; s2 = s2.parent_scope) {
              push_uniq(s2.enclosed, redef);
              if (s2 === redef.scope)
                break;
            }
        } else if (node instanceof AST_SymbolConst) {
          var redef = def.redefined();
          if (redef)
            redef.const_redefs = true;
        }
        if (node.name != "arguments")
          return true;
        var parent = node instanceof AST_SymbolVar && tw.parent();
        if (parent instanceof AST_VarDef && !parent.value)
          return true;
        var sym = node.scope.resolve().find_variable("arguments");
        if (sym && is_arguments(sym))
          sym.scope.uses_arguments = 3;
        return true;
      }
      if (node instanceof AST_SymbolRef) {
        var name = node.name;
        var sym = node.scope.find_variable(name);
        for (var i = in_arg.length;i > 0 && sym; ) {
          i = in_arg.lastIndexOf(sym.scope, i - 1);
          if (i < 0)
            break;
          var decl = sym.orig[0];
          if (decl instanceof AST_SymbolCatch || decl instanceof AST_SymbolFunarg || decl instanceof AST_SymbolLambda) {
            node.in_arg = true;
            break;
          }
          sym = sym.scope.parent_scope.find_variable(name);
        }
        if (!sym) {
          sym = self.def_global(node);
        } else if (name == "arguments" && is_arguments(sym)) {
          var parent = tw.parent();
          if (is_lhs2(node, parent)) {
            sym.scope.uses_arguments = 3;
          } else if (sym.scope.uses_arguments < 2 && !(parent instanceof AST_PropAccess && parent.expression === node)) {
            sym.scope.uses_arguments = 2;
          } else if (!sym.scope.uses_arguments) {
            sym.scope.uses_arguments = true;
          }
        }
        if (name == "eval") {
          var parent = tw.parent();
          if (parent.TYPE == "Call" && parent.expression === node) {
            var s2 = node.scope;
            do {
              s2 = s2.resolve();
              if (s2.uses_eval)
                break;
              s2.uses_eval = true;
            } while (s2 = s2.parent_scope);
          } else if (sym.undeclared) {
            self.uses_eval = true;
          }
        }
        if (sym.init instanceof AST_LambdaDefinition && sym.scope !== sym.init.name.scope) {
          var scope2 = node.scope;
          do {
            if (scope2 === sym.init.name.scope)
              break;
          } while (scope2 = scope2.parent_scope);
          if (!scope2)
            sym.init = undefined;
        }
        node.thedef = sym;
        node.reference(options);
        return true;
      }
    });
    self.walk(tw);
    if (options.ie)
      self.walk(new TreeWalker(function(node) {
        if (node instanceof AST_SymbolCatch) {
          var scope2 = node.thedef.defun;
          if (scope2.name instanceof AST_SymbolLambda && scope2.name.name == node.name) {
            scope2 = scope2.parent_scope.resolve();
          }
          redefine(node, scope2);
          return true;
        }
        if (node instanceof AST_SymbolLambda) {
          var def = node.thedef;
          if (!redefine(node, node.scope.parent_scope.resolve())) {
            delete def.defun;
          } else if (typeof node.thedef.init !== "undefined") {
            node.thedef.init = false;
          } else if (def.init) {
            node.thedef.init = def.init;
          }
          return true;
        }
      }));
    function is_arguments(sym) {
      return sym.orig[0] instanceof AST_SymbolFunarg && !(sym.orig[1] instanceof AST_SymbolFunarg || sym.orig[2] instanceof AST_SymbolFunarg) && !is_arrow(sym.scope);
    }
    function redefine(node, scope2) {
      var name = node.name;
      var old_def = node.thedef;
      if (!all(old_def.orig, function(sym) {
        return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet);
      }))
        return false;
      var new_def = scope2.find_variable(name);
      if (new_def) {
        var redef = new_def.redefined();
        if (redef)
          new_def = redef;
      } else {
        new_def = self.globals.get(name);
      }
      if (new_def) {
        new_def.orig.push(node);
      } else {
        new_def = scope2.def_variable(node);
      }
      if (new_def.undeclared)
        self.variables.set(name, new_def);
      if (name == "arguments" && is_arguments(old_def) && node instanceof AST_SymbolLambda)
        return true;
      old_def.defun = new_def.scope;
      old_def.forEach(function(node2) {
        node2.redef = old_def;
        node2.thedef = new_def;
        node2.reference(options);
      });
      return true;
    }
  });
  AST_Toplevel.DEFMETHOD("def_global", function(node) {
    var globals = this.globals, name = node.name;
    if (globals.has(name)) {
      return globals.get(name);
    } else {
      var g2 = this.make_def(node);
      g2.undeclared = true;
      g2.global = true;
      globals.set(name, g2);
      return g2;
    }
  });
  AST_BlockScope.DEFMETHOD("init_vars", function(parent_scope) {
    init_block_vars(this, parent_scope);
  });
  AST_Scope.DEFMETHOD("init_vars", function(parent_scope) {
    init_scope_vars(this, parent_scope);
  });
  AST_Arrow.DEFMETHOD("init_vars", function(parent_scope) {
    init_scope_vars(this, parent_scope);
    return this;
  });
  AST_AsyncArrow.DEFMETHOD("init_vars", function(parent_scope) {
    init_scope_vars(this, parent_scope);
  });
  AST_Lambda.DEFMETHOD("init_vars", function(parent_scope) {
    init_scope_vars(this, parent_scope);
    this.uses_arguments = false;
    this.def_variable(new AST_SymbolFunarg({
      name: "arguments",
      start: this.start,
      end: this.end
    }));
    return this;
  });
  AST_Symbol.DEFMETHOD("mark_enclosed", function(options) {
    var def = this.definition();
    for (var s2 = this.scope;s2; s2 = s2.parent_scope) {
      push_uniq(s2.enclosed, def);
      if (!options) {
        delete s2._var_names;
      } else if (options.keep_fnames) {
        s2.functions.each(function(d2) {
          push_uniq(def.scope.enclosed, d2);
        });
      }
      if (s2 === def.scope)
        break;
    }
  });
  AST_Symbol.DEFMETHOD("reference", function(options) {
    this.definition().references.push(this);
    this.mark_enclosed(options);
  });
  AST_BlockScope.DEFMETHOD("find_variable", function(name) {
    return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);
  });
  AST_BlockScope.DEFMETHOD("def_function", function(symbol, init) {
    var def = this.def_variable(symbol, init);
    if (!def.init || def.init instanceof AST_LambdaDefinition)
      def.init = init;
    this.functions.set(symbol.name, def);
    return def;
  });
  AST_BlockScope.DEFMETHOD("def_variable", function(symbol, init) {
    var def = this.variables.get(symbol.name);
    if (def) {
      def.orig.push(symbol);
      if (def.init instanceof AST_LambdaExpression)
        def.init = init;
    } else {
      def = this.make_def(symbol, init);
      this.variables.set(symbol.name, def);
      def.global = !this.parent_scope;
    }
    return symbol.thedef = def;
  });
  AST_Symbol.DEFMETHOD("unmangleable", function(options) {
    var def = this.definition();
    return !def || def.unmangleable(options);
  });
  AST_Label.DEFMETHOD("unmangleable", return_false);
  AST_Symbol.DEFMETHOD("definition", function() {
    return this.thedef;
  });
  AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
    options = _default_mangler_options(options);
    var lname = -1;
    if (options.cache && options.cache.props) {
      var mangled_names = names_in_use(this, options);
      options.cache.props.each(function(mangled_name) {
        mangled_names[mangled_name] = true;
      });
    }
    var redefined = [];
    var tw = new TreeWalker(function(node, descend) {
      if (node instanceof AST_LabeledStatement) {
        var save_nesting = lname;
        descend();
        if (!options.v8 || !in_label(tw))
          lname = save_nesting;
        return true;
      }
      if (node instanceof AST_BlockScope) {
        if (options.webkit && node instanceof AST_IterationStatement && node.init instanceof AST_Let) {
          node.init.definitions.forEach(function(defn) {
            defn.name.match_symbol(function(sym2) {
              if (!(sym2 instanceof AST_SymbolLet))
                return;
              var def = sym2.definition();
              var scope = sym2.scope.parent_scope;
              var redef = scope.def_variable(sym2);
              sym2.thedef = def;
              scope.to_mangle.push(redef);
              def.redefined = function() {
                return redef;
              };
            });
          }, true);
        }
        node.to_mangle = [];
        node.variables.each(function(def) {
          if (!defer_redef(def))
            node.to_mangle.push(def);
        });
        descend();
        if (options.cache && node instanceof AST_Toplevel) {
          node.globals.each(mangle);
        }
        if (node instanceof AST_Defun && tw.has_directive("use asm")) {
          var sym = new AST_SymbolRef(node.name);
          sym.scope = node;
          sym.reference(options);
        }
        node.to_mangle.forEach(mangle);
        return true;
      }
      if (node instanceof AST_Label) {
        var name;
        do {
          name = base542(++lname);
        } while (RESERVED_WORDS[name]);
        node.mangled_name = name;
        return true;
      }
    });
    this.walk(tw);
    redefined.forEach(mangle);
    function mangle(def) {
      if (options.reserved.has[def.name])
        return;
      def.mangle(options);
    }
    function defer_redef(def) {
      var sym = def.orig[0];
      var redef = def.redefined();
      if (!redef) {
        if (!(sym instanceof AST_SymbolConst))
          return false;
        var scope = def.scope.resolve();
        if (def.scope === scope)
          return false;
        if (def.scope.parent_scope.find_variable(sym.name))
          return false;
        redef = scope.def_variable(sym);
        scope.to_mangle.push(redef);
      }
      redefined.push(def);
      def.references.forEach(reference);
      if (sym instanceof AST_SymbolCatch || sym instanceof AST_SymbolConst)
        reference(sym);
      return true;
      function reference(sym2) {
        sym2.thedef = redef;
        sym2.reference(options);
        sym2.thedef = def;
      }
    }
    function in_label(tw2) {
      var level = 0, parent;
      while (parent = tw2.parent(level++)) {
        if (parent instanceof AST_Block)
          return parent instanceof AST_Toplevel && !options.toplevel;
        if (parent instanceof AST_LabeledStatement)
          return true;
      }
    }
  });
  AST_Toplevel.DEFMETHOD("find_colliding_names", function(options) {
    var cache = options.cache && options.cache.props;
    var avoid = Object.create(RESERVED_WORDS);
    options.reserved.forEach(to_avoid);
    this.globals.each(add_def);
    this.walk(new TreeWalker(function(node) {
      if (node instanceof AST_BlockScope)
        node.variables.each(add_def);
    }));
    return avoid;
    function to_avoid(name) {
      avoid[name] = true;
    }
    function add_def(def) {
      var name = def.name;
      if (def.global && cache && cache.has(name))
        name = cache.get(name);
      else if (!def.unmangleable(options))
        return;
      to_avoid(name);
    }
  });
  AST_Toplevel.DEFMETHOD("expand_names", function(options) {
    base542.reset();
    base542.sort();
    options = _default_mangler_options(options);
    var avoid = this.find_colliding_names(options);
    var cname = 0;
    this.globals.each(rename);
    this.walk(new TreeWalker(function(node) {
      if (node instanceof AST_BlockScope)
        node.variables.each(rename);
    }));
    function next_name() {
      var name;
      do {
        name = base542(cname++);
      } while (avoid[name]);
      return name;
    }
    function rename(def) {
      if (def.global && options.cache)
        return;
      if (def.unmangleable(options))
        return;
      if (options.reserved.has[def.name])
        return;
      var redef = def.redefined();
      var name = redef ? redef.rename || redef.name : next_name();
      def.rename = name;
      def.forEach(function(sym) {
        if (sym.definition() === def)
          sym.name = name;
      });
    }
  });
  AST_Node.DEFMETHOD("tail_node", return_this);
  AST_Sequence.DEFMETHOD("tail_node", function() {
    return this.expressions[this.expressions.length - 1];
  });
  AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
    options = _default_mangler_options(options);
    base542.reset();
    var fn = AST_Symbol.prototype.add_source_map;
    try {
      AST_Symbol.prototype.add_source_map = function() {
        if (!this.unmangleable(options))
          base542.consider(this.name, -1);
      };
      if (options.properties) {
        AST_Dot.prototype.add_source_map = function() {
          base542.consider(this.property, -1);
        };
        AST_Sub.prototype.add_source_map = function() {
          skip_string(this.property);
        };
      }
      base542.consider(this.print_to_string(), 1);
    } finally {
      AST_Symbol.prototype.add_source_map = fn;
      delete AST_Dot.prototype.add_source_map;
      delete AST_Sub.prototype.add_source_map;
    }
    base542.sort();
    function skip_string(node) {
      if (node instanceof AST_String) {
        base542.consider(node.value, -1);
      } else if (node instanceof AST_Conditional) {
        skip_string(node.consequent);
        skip_string(node.alternative);
      } else if (node instanceof AST_Sequence) {
        skip_string(node.tail_node());
      }
    }
  });
  base542 = function() {
    var freq = Object.create(null);
    function init(chars2) {
      var array = [];
      for (var i = 0;i < chars2.length; i++) {
        var ch = chars2[i];
        array.push(ch);
        freq[ch] = -0.01 * i;
      }
      return array;
    }
    var digits = init("0123456789");
    var leading = init("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_");
    var chars, frequency;
    function reset() {
      chars = null;
      frequency = Object.create(freq);
    }
    base543.consider = function(str, delta) {
      for (var i = str.length;--i >= 0; ) {
        frequency[str[i]] += delta;
      }
    };
    function compare(a2, b5) {
      return frequency[b5] - frequency[a2];
    }
    base543.sort = function() {
      chars = leading.sort(compare).concat(digits).sort(compare);
    };
    base543.reset = reset;
    reset();
    function base543(num) {
      var ret = leading[num % 54];
      for (num = Math.floor(num / 54);--num >= 0; num >>= 6) {
        ret += chars[num & 63];
      }
      return ret;
    }
    return base543;
  }();
});

// node_modules/uglify-js/lib/compress.js
var exports_compress = {};
var Compressor2;
var init_compress = __esm(() => {
  Compressor2 = function(options, false_by_default) {
    if (!(this instanceof Compressor2))
      return new Compressor2(options, false_by_default);
    TreeTransformer.call(this, this.before, this.after);
    this.options = defaults(options, {
      annotations: !false_by_default,
      arguments: !false_by_default,
      arrows: !false_by_default,
      assignments: !false_by_default,
      awaits: !false_by_default,
      booleans: !false_by_default,
      collapse_vars: !false_by_default,
      comparisons: !false_by_default,
      conditionals: !false_by_default,
      dead_code: !false_by_default,
      default_values: !false_by_default,
      directives: !false_by_default,
      drop_console: false,
      drop_debugger: !false_by_default,
      evaluate: !false_by_default,
      expression: false,
      functions: !false_by_default,
      global_defs: false,
      hoist_exports: !false_by_default,
      hoist_funs: false,
      hoist_props: !false_by_default,
      hoist_vars: false,
      ie: false,
      if_return: !false_by_default,
      imports: !false_by_default,
      inline: !false_by_default,
      join_vars: !false_by_default,
      keep_fargs: false_by_default,
      keep_fnames: false,
      keep_infinity: false,
      loops: !false_by_default,
      merge_vars: !false_by_default,
      negate_iife: !false_by_default,
      objects: !false_by_default,
      optional_chains: !false_by_default,
      passes: 1,
      properties: !false_by_default,
      pure_funcs: null,
      pure_getters: !false_by_default && "strict",
      reduce_funcs: !false_by_default,
      reduce_vars: !false_by_default,
      rests: !false_by_default,
      sequences: !false_by_default,
      side_effects: !false_by_default,
      spreads: !false_by_default,
      strings: !false_by_default,
      switches: !false_by_default,
      templates: !false_by_default,
      top_retain: null,
      toplevel: !!(options && options["top_retain"]),
      typeofs: !false_by_default,
      unsafe: false,
      unsafe_comps: false,
      unsafe_Function: false,
      unsafe_math: false,
      unsafe_proto: false,
      unsafe_regexp: false,
      unsafe_undefined: false,
      unused: !false_by_default,
      varify: !false_by_default,
      webkit: false,
      yields: !false_by_default
    }, true);
    var evaluate = this.options["evaluate"];
    this.eval_threshold = /eager/.test(evaluate) ? 1 / 0 : +evaluate;
    var global_defs = this.options["global_defs"];
    if (typeof global_defs == "object")
      for (var key in global_defs) {
        if (/^@/.test(key) && HOP(global_defs, key)) {
          global_defs[key.slice(1)] = parse(global_defs[key], {
            expression: true
          });
        }
      }
    if (this.options["inline"] === true)
      this.options["inline"] = 3;
    this.drop_fargs = this.options["keep_fargs"] ? return_false : function(lambda, parent) {
      if (lambda.length_read)
        return false;
      var name = lambda.name;
      if (!name)
        return parent && parent.TYPE == "Call" && parent.expression === lambda;
      if (name.fixed_value() !== lambda)
        return false;
      var def = name.definition();
      if (def.direct_access)
        return false;
      var escaped = def.escaped;
      return escaped && escaped.depth != 1;
    };
    var pure_funcs = this.options["pure_funcs"];
    if (typeof pure_funcs == "function") {
      this.pure_funcs = pure_funcs;
    } else if (typeof pure_funcs == "string") {
      this.pure_funcs = function(node) {
        var expr;
        if (node instanceof AST_Call) {
          expr = node.expression;
        } else if (node instanceof AST_Template) {
          expr = node.tag;
        }
        return !(expr && pure_funcs === expr.print_to_string());
      };
    } else if (Array.isArray(pure_funcs)) {
      this.pure_funcs = function(node) {
        var expr;
        if (node instanceof AST_Call) {
          expr = node.expression;
        } else if (node instanceof AST_Template) {
          expr = node.tag;
        }
        return !(expr && member(expr.print_to_string(), pure_funcs));
      };
    } else {
      this.pure_funcs = return_true;
    }
    var sequences = this.options["sequences"];
    this.sequences_limit = sequences == 1 ? 800 : sequences | 0;
    var top_retain = this.options["top_retain"];
    if (top_retain instanceof RegExp) {
      this.top_retain = function(def) {
        return top_retain.test(def.name);
      };
    } else if (typeof top_retain == "function") {
      this.top_retain = top_retain;
    } else if (top_retain) {
      if (typeof top_retain == "string") {
        top_retain = top_retain.split(/,/);
      }
      this.top_retain = function(def) {
        return member(def.name, top_retain);
      };
    }
    var toplevel = this.options["toplevel"];
    this.toplevel = typeof toplevel == "string" ? {
      funcs: /funcs/.test(toplevel),
      vars: /vars/.test(toplevel)
    } : {
      funcs: toplevel,
      vars: toplevel
    };
  };
  Compressor2.prototype = new TreeTransformer;
  merge(Compressor2.prototype, {
    option: function(key) {
      return this.options[key];
    },
    exposed: function(def) {
      if (def.exported)
        return true;
      if (def.undeclared)
        return true;
      if (!(def.global || def.scope.resolve() instanceof AST_Toplevel))
        return false;
      var toplevel = this.toplevel;
      return !all(def.orig, function(sym) {
        return toplevel[sym instanceof AST_SymbolDefun ? "funcs" : "vars"];
      });
    },
    compress: function(node) {
      node = node.resolve_defines(this);
      node.hoist_exports(this);
      if (this.option("expression")) {
        node.process_expression(true);
      }
      var passes = +this.options.passes || 1;
      var min_count = 1 / 0;
      var stopping = false;
      var mangle = { ie: this.option("ie") };
      for (var pass = 0;pass < passes; pass++) {
        node.figure_out_scope(mangle);
        if (pass > 0 || this.option("reduce_vars"))
          node.reset_opt_flags(this);
        node = node.transform(this);
        if (passes > 1) {
          var count = 0;
          node.walk(new TreeWalker(function() {
            count++;
          }));
          AST_Node.info("pass {pass}: last_count: {min_count}, count: {count}", {
            pass,
            min_count,
            count
          });
          if (count < min_count) {
            min_count = count;
            stopping = false;
          } else if (stopping) {
            break;
          } else {
            stopping = true;
          }
        }
      }
      if (this.option("expression")) {
        node.process_expression(false);
      }
      return node;
    },
    before: function(node, descend, in_list) {
      if (node._squeezed)
        return node;
      var is_scope = node instanceof AST_Scope;
      if (is_scope) {
        node.hoist_properties(this);
        node.hoist_declarations(this);
        node.process_boolean_returns(this);
      }
      descend(node, this);
      descend(node, this);
      var opt = node.optimize(this);
      if (is_scope && opt === node && !this.has_directive("use asm") && !opt.pinned()) {
        opt.merge_variables(this);
        opt.drop_unused(this);
        descend(opt, this);
      }
      if (opt === node)
        opt._squeezed = true;
      return opt;
    }
  });
  (function(OPT) {
    OPT(AST_Node, function(self, compressor) {
      return self;
    });
    AST_Node.DEFMETHOD("equivalent_to", function(node) {
      return this.TYPE == node.TYPE && this.print_to_string() == node.print_to_string();
    });
    AST_Toplevel.DEFMETHOD("hoist_exports", function(compressor) {
      if (!compressor.option("hoist_exports"))
        return;
      var body = this.body, props = [];
      for (var i = 0;i < body.length; i++) {
        var stat = body[i];
        if (stat instanceof AST_ExportDeclaration) {
          body[i] = stat = stat.body;
          if (stat instanceof AST_Definitions) {
            stat.definitions.forEach(function(defn) {
              defn.name.match_symbol(export_symbol, true);
            });
          } else {
            export_symbol(stat.name);
          }
        } else if (stat instanceof AST_ExportReferences) {
          body.splice(i--, 1);
          [].push.apply(props, stat.properties);
        }
      }
      if (props.length)
        body.push(make_node(AST_ExportReferences, this, { properties: props }));
      function export_symbol(sym) {
        if (!(sym instanceof AST_SymbolDeclaration))
          return;
        var node = make_node(AST_SymbolExport, sym, sym);
        node.alias = node.name;
        props.push(node);
      }
    });
    AST_Scope.DEFMETHOD("process_expression", function(insert, transform) {
      var self = this;
      var tt2 = new TreeTransformer(function(node) {
        if (insert && node instanceof AST_SimpleStatement) {
          return transform ? transform(node) : make_node(AST_Return, node, { value: node.body });
        }
        if (!insert && node instanceof AST_Return) {
          return transform ? transform(node) : make_node(AST_SimpleStatement, node, {
            body: node.value || make_node(AST_UnaryPrefix, node, {
              operator: "void",
              expression: make_node(AST_Number, node, { value: 0 })
            })
          });
        }
        if (node instanceof AST_Block) {
          if (node instanceof AST_Lambda) {
            if (node !== self)
              return node;
          } else if (insert === "awaits" && node instanceof AST_Try) {
            if (node.bfinally)
              return node;
          }
          for (var index = node.body.length;--index >= 0; ) {
            var stat = node.body[index];
            if (!is_declaration(stat, true)) {
              node.body[index] = stat.transform(tt2);
              break;
            }
          }
        } else if (node instanceof AST_If) {
          node.body = node.body.transform(tt2);
          if (node.alternative) {
            node.alternative = node.alternative.transform(tt2);
          }
        } else if (node instanceof AST_With) {
          node.body = node.body.transform(tt2);
        }
        return node;
      });
      self.transform(tt2);
    });
    function read_property(obj, node) {
      var key = node.get_property();
      if (key instanceof AST_Node)
        return;
      var value;
      if (obj instanceof AST_Array) {
        var elements = obj.elements;
        if (key == "length")
          return make_node_from_constant(elements.length, obj);
        if (typeof key == "number" && key in elements)
          value = elements[key];
      } else if (obj instanceof AST_Lambda) {
        if (key == "length") {
          obj.length_read = true;
          return make_node_from_constant(obj.argnames.length, obj);
        }
      } else if (obj instanceof AST_Object) {
        key = "" + key;
        var props = obj.properties;
        for (var i = props.length;--i >= 0; ) {
          var prop = props[i];
          if (!can_hoist_property(prop))
            return;
          if (!value && props[i].key === key)
            value = props[i].value;
        }
      }
      return value instanceof AST_SymbolRef && value.fixed_value() || value;
    }
    function is_read_only_fn(value, name) {
      if (value instanceof AST_Boolean)
        return native_fns.Boolean[name];
      if (value instanceof AST_Number)
        return native_fns.Number[name];
      if (value instanceof AST_String)
        return native_fns.String[name];
      if (name == "valueOf")
        return false;
      if (value instanceof AST_Array)
        return native_fns.Array[name];
      if (value instanceof AST_Lambda)
        return native_fns.Function[name];
      if (value instanceof AST_Object)
        return native_fns.Object[name];
      if (value instanceof AST_RegExp)
        return native_fns.RegExp[name] && !value.value.global;
    }
    function is_modified(compressor, tw, node, value, level, immutable, recursive) {
      var parent = tw.parent(level);
      if (compressor.option("unsafe") && parent instanceof AST_Dot && is_read_only_fn(value, parent.property)) {
        return;
      }
      var lhs = is_lhs(node, parent);
      if (lhs)
        return lhs;
      if (parent instanceof AST_Array)
        return is_modified(compressor, tw, parent, parent, level + 1);
      if (parent instanceof AST_Binary) {
        if (!lazy_op[parent.operator])
          return;
        return is_modified(compressor, tw, parent, parent, level + 1);
      }
      if (parent instanceof AST_Call) {
        return !immutable && parent.expression === node && !parent.is_expr_pure(compressor) && (!(value instanceof AST_LambdaExpression) || !(parent instanceof AST_New) && value.contains_this());
      }
      if (parent instanceof AST_Conditional) {
        if (parent.condition === node)
          return;
        return is_modified(compressor, tw, parent, parent, level + 1);
      }
      if (parent instanceof AST_ForEnumeration)
        return parent.init === node;
      if (parent instanceof AST_ObjectKeyVal) {
        if (parent.value !== node)
          return;
        var obj = tw.parent(level + 1);
        return is_modified(compressor, tw, obj, obj, level + 2);
      }
      if (parent instanceof AST_PropAccess) {
        if (parent.expression !== node)
          return;
        var prop = read_property(value, parent);
        return (!immutable || recursive) && is_modified(compressor, tw, parent, prop, level + 1);
      }
      if (parent instanceof AST_Sequence) {
        if (parent.tail_node() !== node)
          return;
        return is_modified(compressor, tw, parent, value, level + 1, immutable, recursive);
      }
    }
    function is_lambda(node) {
      return node instanceof AST_Class || node instanceof AST_Lambda;
    }
    function safe_for_extends(node) {
      return node instanceof AST_Class || node instanceof AST_Defun || node instanceof AST_Function;
    }
    function is_arguments(def) {
      return def.name == "arguments" && def.scope.uses_arguments;
    }
    function is_funarg(def) {
      return def.orig[0] instanceof AST_SymbolFunarg || def.orig[1] instanceof AST_SymbolFunarg;
    }
    function cross_scope(def, sym) {
      do {
        if (def === sym)
          return false;
        if (sym instanceof AST_Scope)
          return true;
      } while (sym = sym.parent_scope);
    }
    function can_drop_symbol(ref, compressor, keep_lambda) {
      var def = ref.definition();
      if (ref.in_arg && is_funarg(def))
        return false;
      return all(def.orig, function(sym) {
        if (sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet) {
          return compressor && can_varify(compressor, sym);
        }
        return !(keep_lambda && sym instanceof AST_SymbolLambda);
      });
    }
    function has_escaped(d2, scope, node, parent) {
      if (parent instanceof AST_Assign)
        return parent.operator == "=" && parent.right === node;
      if (parent instanceof AST_Call)
        return parent.expression !== node || parent instanceof AST_New;
      if (parent instanceof AST_Exit)
        return parent.value === node && scope.resolve() !== d2.scope.resolve();
      if (parent instanceof AST_VarDef)
        return parent.value === node;
    }
    var RE_POSITIVE_INTEGER = /^(0|[1-9][0-9]*)$/;
    (function(def) {
      def(AST_Node, noop);
      function reset_def(tw, compressor, def2) {
        def2.assignments = 0;
        def2.bool_fn = 0;
        def2.cross_loop = false;
        def2.direct_access = false;
        def2.escaped = [];
        def2.fixed = !def2.const_redefs && !def2.scope.pinned() && !compressor.exposed(def2) && !(def2.init instanceof AST_LambdaExpression && def2.init !== def2.scope) && def2.init;
        def2.reassigned = 0;
        def2.recursive_refs = 0;
        def2.references = [];
        def2.should_replace = undefined;
        def2.single_use = undefined;
      }
      function reset_block_variables(tw, compressor, scope) {
        scope.variables.each(function(def2) {
          reset_def(tw, compressor, def2);
        });
      }
      function reset_variables(tw, compressor, scope) {
        scope.fn_defs = [];
        scope.variables.each(function(def2) {
          reset_def(tw, compressor, def2);
          var init = def2.init;
          if (init instanceof AST_LambdaDefinition) {
            scope.fn_defs.push(init);
            init.safe_ids = null;
          }
          if (def2.fixed === null) {
            def2.safe_ids = tw.safe_ids;
            mark(tw, def2);
          } else if (def2.fixed) {
            tw.loop_ids[def2.id] = tw.in_loop;
            mark(tw, def2);
          }
        });
        scope.may_call_this = function() {
          scope.may_call_this = scope.contains_this() ? return_true : return_false;
        };
        if (scope.uses_arguments)
          scope.each_argname(function(node) {
            node.definition().last_ref = false;
          });
        if (compressor.option("ie"))
          scope.variables.each(function(def2) {
            var d2 = def2.orig[0].definition();
            if (d2 !== def2)
              d2.fixed = false;
          });
      }
      function walk_fn_def(tw, fn) {
        var was_scanning = tw.fn_scanning;
        tw.fn_scanning = fn;
        fn.walk(tw);
        tw.fn_scanning = was_scanning;
      }
      function revisit_fn_def(tw, fn) {
        fn.enclosed.forEach(function(d2) {
          if (fn.variables.get(d2.name) === d2)
            return;
          if (safe_to_read(tw, d2))
            return;
          d2.single_use = false;
          var fixed = d2.fixed;
          if (typeof fixed == "function")
            fixed = fixed();
          if (fixed instanceof AST_Lambda && HOP(fixed, "safe_ids"))
            return;
          d2.fixed = false;
        });
      }
      function mark_fn_def(tw, def2, fn) {
        if (!HOP(fn, "safe_ids"))
          return;
        var marker = fn.safe_ids;
        if (marker === false)
          return;
        if (fn.parent_scope.resolve().may_call_this === return_true) {
          if (member(fn, tw.fn_visited))
            revisit_fn_def(tw, fn);
        } else if (marker) {
          var visited = member(fn, tw.fn_visited);
          if (marker === tw.safe_ids) {
            if (!visited)
              walk_fn_def(tw, fn);
          } else if (visited) {
            revisit_fn_def(tw, fn);
          } else {
            fn.safe_ids = false;
          }
        } else if (tw.fn_scanning && tw.fn_scanning !== def2.scope.resolve()) {
          fn.safe_ids = false;
        } else {
          fn.safe_ids = tw.safe_ids;
          walk_fn_def(tw, fn);
        }
      }
      function pop_scope(tw, scope) {
        var fn_defs = scope.fn_defs;
        var tangled = scope.may_call_this === return_true ? fn_defs : fn_defs.filter(function(fn) {
          if (fn.safe_ids === false)
            return true;
          fn.safe_ids = tw.safe_ids;
          walk_fn_def(tw, fn);
          return false;
        });
        pop(tw);
        tangled.forEach(function(fn) {
          fn.safe_ids = tw.safe_ids;
          walk_fn_def(tw, fn);
        });
        fn_defs.forEach(function(fn) {
          delete fn.safe_ids;
        });
        delete scope.fn_defs;
        delete scope.may_call_this;
      }
      function push(tw) {
        tw.safe_ids = Object.create(tw.safe_ids);
      }
      function pop(tw) {
        tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);
      }
      function mark(tw, def2) {
        tw.safe_ids[def2.id] = {};
      }
      function push_ref(def2, ref) {
        def2.references.push(ref);
        if (def2.last_ref !== false)
          def2.last_ref = ref;
      }
      function safe_to_read(tw, def2) {
        if (def2.single_use == "m")
          return false;
        var safe = tw.safe_ids[def2.id];
        if (safe) {
          if (!HOP(tw.safe_ids, def2.id))
            safe.read = safe.read && safe.read !== tw.safe_ids ? true : tw.safe_ids;
          if (def2.fixed == null) {
            if (is_arguments(def2))
              return false;
            if (def2.global && def2.name == "arguments")
              return false;
            tw.loop_ids[def2.id] = null;
            def2.fixed = make_node(AST_Undefined, def2.orig[0]);
            return true;
          }
          return !safe.assign || safe.assign === tw.safe_ids;
        }
        return def2.fixed instanceof AST_LambdaDefinition;
      }
      function safe_to_assign(tw, def2, declare) {
        if (!declare) {
          if (is_funarg(def2) && def2.scope.uses_arguments && !tw.has_directive("use strict"))
            return false;
          if (!all(def2.orig, function(sym) {
            return !(sym instanceof AST_SymbolConst);
          }))
            return false;
        }
        if (def2.fixed === undefined)
          return declare || all(def2.orig, function(sym) {
            return !(sym instanceof AST_SymbolLet);
          });
        if (def2.fixed === false)
          return false;
        var safe = tw.safe_ids[def2.id];
        if (def2.safe_ids) {
          def2.safe_ids[def2.id] = false;
          delete def2.safe_ids;
          return def2.fixed === null || HOP(tw.safe_ids, def2.id) && !safe.read;
        }
        if (!HOP(tw.safe_ids, def2.id)) {
          if (!safe)
            return false;
          if (safe.read) {
            var scope = tw.find_parent(AST_BlockScope);
            if (scope instanceof AST_Class)
              return false;
            if (def2.scope.resolve() !== scope.resolve())
              return false;
          }
          safe.assign = safe.assign && safe.assign !== tw.safe_ids ? true : tw.safe_ids;
        }
        if (def2.fixed != null && safe.read) {
          if (safe.read !== tw.safe_ids)
            return false;
          if (tw.loop_ids[def2.id] !== tw.in_loop)
            return false;
        }
        return safe_to_read(tw, def2) && all(def2.orig, function(sym) {
          return !(sym instanceof AST_SymbolLambda);
        });
      }
      function make_ref(ref, fixed) {
        var node = make_node(AST_SymbolRef, ref, ref);
        node.fixed = fixed || make_node(AST_Undefined, ref);
        return node;
      }
      function ref_once(compressor, def2) {
        return compressor.option("unused") && !def2.scope.pinned() && def2.single_use !== false && def2.references.length - def2.recursive_refs == 1 && !(is_funarg(def2) && def2.scope.uses_arguments);
      }
      function is_immutable(value) {
        if (!value)
          return false;
        if (value instanceof AST_Assign) {
          var op = value.operator;
          return op == "=" ? is_immutable(value.right) : !lazy_op[op.slice(0, -1)];
        }
        if (value instanceof AST_Sequence)
          return is_immutable(value.tail_node());
        return value.is_constant() || is_lambda(value) || value instanceof AST_ObjectIdentity;
      }
      function value_in_use(node, parent) {
        if (parent instanceof AST_Array)
          return true;
        if (parent instanceof AST_Binary)
          return lazy_op[parent.operator];
        if (parent instanceof AST_Conditional)
          return parent.condition !== node;
        if (parent instanceof AST_Sequence)
          return parent.tail_node() === node;
        if (parent instanceof AST_Spread)
          return true;
      }
      function mark_escaped(tw, d2, scope, node, value, level, depth) {
        var parent = tw.parent(level);
        if (value && value.is_constant())
          return;
        if (has_escaped(d2, scope, node, parent)) {
          d2.escaped.push(parent);
          if (depth > 1 && !(value && value.is_constant_expression(scope)))
            depth = 1;
          if (!d2.escaped.depth || d2.escaped.depth > depth)
            d2.escaped.depth = depth;
          if (d2.scope.resolve() !== scope.resolve())
            d2.escaped.cross_scope = true;
          return;
        } else if (value_in_use(node, parent)) {
          mark_escaped(tw, d2, scope, parent, parent, level + 1, depth);
        } else if (parent instanceof AST_ObjectKeyVal && parent.value === node) {
          var obj = tw.parent(level + 1);
          mark_escaped(tw, d2, scope, obj, obj, level + 2, depth);
        } else if (parent instanceof AST_PropAccess && parent.expression === node) {
          value = read_property(value, parent);
          mark_escaped(tw, d2, scope, parent, value, level + 1, depth + 1);
          if (value)
            return;
        }
        if (level > 0)
          return;
        if (parent instanceof AST_Call && parent.expression === node)
          return;
        if (parent instanceof AST_Sequence && parent.tail_node() !== node)
          return;
        if (parent instanceof AST_SimpleStatement)
          return;
        if (parent instanceof AST_Unary && !unary_side_effects[parent.operator])
          return;
        d2.direct_access = true;
      }
      function mark_assignment_to_arguments(node) {
        if (!(node instanceof AST_Sub))
          return;
        var expr = node.expression;
        if (!(expr instanceof AST_SymbolRef))
          return;
        var def2 = expr.definition();
        if (!is_arguments(def2))
          return;
        var key = node.property;
        if (key.is_constant())
          key = key.value;
        if (!(key instanceof AST_Node) && !RE_POSITIVE_INTEGER.test(key))
          return;
        def2.reassigned++;
        (key instanceof AST_Node ? def2.scope.argnames : [def2.scope.argnames[key]]).forEach(function(argname) {
          if (argname instanceof AST_SymbolFunarg)
            argname.definition().fixed = false;
        });
      }
      function scan_declaration(tw, compressor, lhs, fixed, visit) {
        var scanner = new TreeWalker(function(node) {
          if (node instanceof AST_DefaultValue) {
            reset_flags(node);
            push(tw);
            node.value.walk(tw);
            pop(tw);
            var save = fixed;
            if (save)
              fixed = function() {
                var value = save();
                var ev;
                if (is_undefined(value, compressor) || (ev = fuzzy_eval(compressor, value, true)) === undefined) {
                  return make_sequence(node, [value, node.value]);
                }
                return ev instanceof AST_Node ? node : value;
              };
            node.name.walk(scanner);
            fixed = save;
            return true;
          }
          if (node instanceof AST_DestructuredArray) {
            reset_flags(node);
            var save = fixed;
            node.elements.forEach(function(node2, index) {
              if (node2 instanceof AST_Hole)
                return reset_flags(node2);
              if (save)
                fixed = function() {
                  return make_node(AST_Sub, node2, {
                    expression: save(),
                    property: make_node(AST_Number, node2, { value: index })
                  });
                };
              node2.walk(scanner);
            });
            if (node.rest) {
              if (save)
                fixed = compressor.option("rests") && function() {
                  var value = save();
                  return value instanceof AST_Array ? make_node(AST_Array, node, {
                    elements: value.elements.slice(node.elements.length)
                  }) : node;
                };
              node.rest.walk(scanner);
            }
            fixed = save;
            return true;
          }
          if (node instanceof AST_DestructuredObject) {
            reset_flags(node);
            var save = fixed;
            node.properties.forEach(function(node2) {
              reset_flags(node2);
              if (node2.key instanceof AST_Node) {
                push(tw);
                node2.key.walk(tw);
                pop(tw);
              }
              if (save)
                fixed = function() {
                  var key = node2.key;
                  var type = AST_Sub;
                  if (typeof key == "string") {
                    if (is_identifier_string(key)) {
                      type = AST_Dot;
                    } else {
                      key = make_node_from_constant(key, node2);
                    }
                  }
                  return make_node(type, node2, {
                    expression: save(),
                    property: key
                  });
                };
              node2.value.walk(scanner);
            });
            if (node.rest) {
              fixed = false;
              node.rest.walk(scanner);
            }
            fixed = save;
            return true;
          }
          visit(node, fixed, function() {
            var save_len = tw.stack.length;
            for (var i = 0, len = scanner.stack.length - 1;i < len; i++) {
              tw.stack.push(scanner.stack[i]);
            }
            node.walk(tw);
            tw.stack.length = save_len;
          });
          return true;
        });
        lhs.walk(scanner);
      }
      function reduce_iife(tw, descend, compressor) {
        var fn = this;
        fn.inlined = false;
        var iife = tw.parent();
        var hit = is_async(fn) || is_generator(fn);
        var aborts2 = false;
        fn.walk(new TreeWalker(function(node) {
          if (hit)
            return aborts2 = true;
          if (node instanceof AST_Return)
            return hit = true;
          if (node instanceof AST_Scope && node !== fn)
            return true;
        }));
        if (aborts2)
          push(tw);
        reset_variables(tw, compressor, fn);
        var safe = !fn.uses_arguments || tw.has_directive("use strict");
        fn.argnames.forEach(function(argname, i) {
          var value = iife.args[i];
          scan_declaration(tw, compressor, argname, function() {
            var j2 = fn.argnames.indexOf(argname);
            var arg = j2 < 0 ? value : iife.args[j2];
            if (arg instanceof AST_Sequence && arg.expressions.length < 2)
              arg = arg.expressions[0];
            return arg || make_node(AST_Undefined, iife);
          }, visit);
        });
        var rest = fn.rest;
        if (rest)
          scan_declaration(tw, compressor, rest, compressor.option("rests") && function() {
            return fn.rest === rest ? make_node(AST_Array, fn, {
              elements: iife.args.slice(fn.argnames.length)
            }) : rest;
          }, visit);
        walk_lambda(fn, tw);
        var safe_ids = tw.safe_ids;
        pop_scope(tw, fn);
        if (!aborts2)
          tw.safe_ids = safe_ids;
        return true;
        function visit(node, fixed) {
          var d2 = node.definition();
          if (fixed && safe && d2.fixed === undefined) {
            mark(tw, d2);
            tw.loop_ids[d2.id] = tw.in_loop;
            d2.fixed = fixed;
            d2.fixed.assigns = [node];
          } else {
            d2.fixed = false;
          }
        }
      }
      def(AST_Assign, function(tw, descend, compressor) {
        var node = this;
        var left = node.left;
        var right = node.right;
        var ld = left instanceof AST_SymbolRef && left.definition();
        var scan = ld || left instanceof AST_Destructured;
        switch (node.operator) {
          case "=":
            if (left.equivalent_to(right) && !left.has_side_effects(compressor)) {
              right.walk(tw);
              walk_prop(left);
              node.__drop = true;
              return true;
            }
            if (ld && right instanceof AST_LambdaExpression) {
              walk_assign();
              right.parent_scope.resolve().fn_defs.push(right);
              right.safe_ids = null;
              if (!ld.fixed || !node.write_only)
                mark_fn_def(tw, ld, right);
              return true;
            }
            if (scan) {
              right.walk(tw);
              walk_assign();
              return true;
            }
            mark_assignment_to_arguments(left);
            return;
          case "&&=":
          case "||=":
          case "??=":
            left.walk(tw);
            push(tw);
            if (scan) {
              right.walk(tw);
              walk_assign();
            } else {
              mark_assignment_to_arguments(left);
              right.walk(tw);
            }
            pop(tw);
            return true;
          default:
            if (!scan) {
              mark_assignment_to_arguments(left);
              return;
            }
            ld.assignments++;
            var fixed = ld.fixed;
            if (is_modified(compressor, tw, node, node, 0)) {
              ld.fixed = false;
              return;
            }
            var safe = safe_to_read(tw, ld);
            right.walk(tw);
            if (safe && !left.in_arg && safe_to_assign(tw, ld)) {
              push_ref(ld, left);
              mark(tw, ld);
              if (ld.single_use)
                ld.single_use = false;
              left.fixed = ld.fixed = function() {
                return make_node(AST_Binary, node, {
                  operator: node.operator.slice(0, -1),
                  left: make_ref(left, fixed),
                  right: node.right
                });
              };
              left.fixed.assigns = !fixed || !fixed.assigns ? [] : fixed.assigns.slice();
              left.fixed.assigns.push(node);
            } else {
              left.walk(tw);
              ld.fixed = false;
            }
            return true;
        }
        function walk_prop(lhs) {
          if (lhs instanceof AST_Dot) {
            walk_prop(lhs.expression);
          } else if (lhs instanceof AST_Sub) {
            walk_prop(lhs.expression);
            lhs.property.walk(tw);
          } else if (lhs instanceof AST_SymbolRef) {
            var d2 = lhs.definition();
            push_ref(d2, lhs);
            if (d2.fixed) {
              lhs.fixed = d2.fixed;
              if (lhs.fixed.assigns) {
                lhs.fixed.assigns.push(node);
              } else {
                lhs.fixed.assigns = [node];
              }
            }
          } else {
            lhs.walk(tw);
          }
        }
        function walk_assign() {
          var recursive = ld && recursive_ref(tw, ld);
          var modified = is_modified(compressor, tw, node, right, 0, is_immutable(right), recursive);
          scan_declaration(tw, compressor, left, function() {
            return node.right;
          }, function(sym, fixed2, walk) {
            if (!(sym instanceof AST_SymbolRef)) {
              mark_assignment_to_arguments(sym);
              walk();
              return;
            }
            var d2 = sym.definition();
            d2.assignments++;
            if (fixed2 && !modified && !sym.in_arg && safe_to_assign(tw, d2)) {
              push_ref(d2, sym);
              mark(tw, d2);
              if (left instanceof AST_Destructured || d2.orig.length == 1 && d2.orig[0] instanceof AST_SymbolDefun) {
                d2.single_use = false;
              }
              tw.loop_ids[d2.id] = tw.in_loop;
              mark_escaped(tw, d2, sym.scope, node, right, 0, 1);
              sym.fixed = d2.fixed = fixed2;
              sym.fixed.assigns = [node];
            } else {
              walk();
              d2.fixed = false;
            }
          });
        }
      });
      def(AST_Binary, function(tw) {
        if (!lazy_op[this.operator])
          return;
        this.left.walk(tw);
        push(tw);
        this.right.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_BlockScope, function(tw, descend, compressor) {
        reset_block_variables(tw, compressor, this);
      });
      def(AST_Call, function(tw, descend) {
        var node = this;
        var exp = node.expression;
        if (exp instanceof AST_LambdaExpression) {
          var iife = is_iife_single(node);
          node.args.forEach(function(arg) {
            arg.walk(tw);
            if (arg instanceof AST_Spread)
              iife = false;
          });
          if (iife)
            exp.reduce_vars = reduce_iife;
          exp.walk(tw);
          if (iife)
            delete exp.reduce_vars;
          return true;
        }
        if (node.TYPE == "Call" && tw.in_boolean_context()) {
          if (exp instanceof AST_SymbolRef) {
            exp.definition().bool_fn++;
          } else if (exp instanceof AST_Assign && exp.operator == "=" && exp.left instanceof AST_SymbolRef) {
            exp.left.definition().bool_fn++;
          }
        }
        exp.walk(tw);
        var optional = node.optional;
        if (optional)
          push(tw);
        node.args.forEach(function(arg) {
          arg.walk(tw);
        });
        if (optional)
          pop(tw);
        var fixed = exp instanceof AST_SymbolRef && exp.fixed_value();
        if (fixed instanceof AST_Lambda) {
          mark_fn_def(tw, exp.definition(), fixed);
        } else {
          tw.find_parent(AST_Scope).may_call_this();
        }
        return true;
      });
      def(AST_Class, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        if (node.extends)
          node.extends.walk(tw);
        var props = node.properties.filter(function(prop) {
          reset_flags(prop);
          if (prop.key instanceof AST_Node)
            prop.key.walk(tw);
          return prop.value;
        });
        if (node.name) {
          var d2 = node.name.definition();
          var parent = tw.parent();
          if (parent instanceof AST_ExportDeclaration || parent instanceof AST_ExportDefault)
            d2.single_use = false;
          if (safe_to_assign(tw, d2, true)) {
            mark(tw, d2);
            tw.loop_ids[d2.id] = tw.in_loop;
            d2.fixed = function() {
              return node;
            };
            d2.fixed.assigns = [node];
            if (!is_safe_lexical(d2))
              d2.single_use = false;
          } else {
            d2.fixed = false;
          }
        }
        props.forEach(function(prop) {
          if (!prop.static || prop instanceof AST_ClassField && prop.value.contains_this()) {
            push(tw);
            prop.value.walk(tw);
            pop(tw);
          } else {
            prop.value.walk(tw);
          }
        });
        return true;
      });
      def(AST_Conditional, function(tw) {
        this.condition.walk(tw);
        push(tw);
        this.consequent.walk(tw);
        pop(tw);
        push(tw);
        this.alternative.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_DefaultValue, function(tw) {
        this.name.walk(tw);
        push(tw);
        this.value.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_Do, function(tw) {
        var save_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        this.body.walk(tw);
        if (has_loop_control(this, tw.parent())) {
          pop(tw);
          push(tw);
        }
        this.condition.walk(tw);
        pop(tw);
        tw.in_loop = save_loop;
        return true;
      });
      def(AST_For, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        if (node.init)
          node.init.walk(tw);
        var save_loop = tw.in_loop;
        tw.in_loop = node;
        push(tw);
        if (node.condition)
          node.condition.walk(tw);
        node.body.walk(tw);
        if (node.step) {
          if (has_loop_control(node, tw.parent())) {
            pop(tw);
            push(tw);
          }
          node.step.walk(tw);
        }
        pop(tw);
        tw.in_loop = save_loop;
        return true;
      });
      def(AST_ForEnumeration, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        node.object.walk(tw);
        var save_loop = tw.in_loop;
        tw.in_loop = node;
        push(tw);
        var init = node.init;
        if (init instanceof AST_Definitions) {
          init.definitions[0].name.mark_symbol(function(node2) {
            if (node2 instanceof AST_SymbolDeclaration) {
              var def2 = node2.definition();
              def2.assignments++;
              def2.fixed = false;
            }
          }, tw);
        } else if (init instanceof AST_Destructured || init instanceof AST_SymbolRef) {
          init.mark_symbol(function(node2) {
            if (node2 instanceof AST_SymbolRef) {
              var def2 = node2.definition();
              push_ref(def2, node2);
              def2.assignments++;
              if (!node2.is_immutable())
                def2.fixed = false;
            }
          }, tw);
        } else {
          init.walk(tw);
        }
        node.body.walk(tw);
        pop(tw);
        tw.in_loop = save_loop;
        return true;
      });
      def(AST_If, function(tw) {
        this.condition.walk(tw);
        push(tw);
        this.body.walk(tw);
        pop(tw);
        if (this.alternative) {
          push(tw);
          this.alternative.walk(tw);
          pop(tw);
        }
        return true;
      });
      def(AST_LabeledStatement, function(tw) {
        push(tw);
        this.body.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_Lambda, function(tw, descend, compressor) {
        var fn = this;
        if (HOP(fn, "safe_ids") && fn.safe_ids !== tw.safe_ids)
          return true;
        if (!push_uniq(tw.fn_visited, fn))
          return true;
        fn.inlined = false;
        push(tw);
        reset_variables(tw, compressor, fn);
        descend();
        pop_scope(tw, fn);
        if (fn.name)
          mark_escaped(tw, fn.name.definition(), fn, fn.name, fn, 0, 1);
        return true;
      });
      def(AST_LambdaDefinition, function(tw, descend, compressor) {
        var fn = this;
        var def2 = fn.name.definition();
        var parent = tw.parent();
        if (parent instanceof AST_ExportDeclaration || parent instanceof AST_ExportDefault)
          def2.single_use = false;
        if (HOP(fn, "safe_ids") && fn.safe_ids !== tw.safe_ids)
          return true;
        if (!push_uniq(tw.fn_visited, fn))
          return true;
        fn.inlined = false;
        push(tw);
        reset_variables(tw, compressor, fn);
        descend();
        pop_scope(tw, fn);
        return true;
      });
      def(AST_Sub, function(tw) {
        if (!this.optional)
          return;
        this.expression.walk(tw);
        push(tw);
        this.property.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_Switch, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        node.expression.walk(tw);
        var first = true;
        node.body.forEach(function(branch) {
          if (branch instanceof AST_Default)
            return;
          branch.expression.walk(tw);
          if (first) {
            first = false;
            push(tw);
          }
        });
        if (!first)
          pop(tw);
        walk_body(node, tw);
        return true;
      });
      def(AST_SwitchBranch, function(tw) {
        push(tw);
        walk_body(this, tw);
        pop(tw);
        return true;
      });
      def(AST_SymbolCatch, function() {
        this.definition().fixed = false;
      });
      def(AST_SymbolImport, function() {
        this.definition().fixed = false;
      });
      def(AST_SymbolRef, function(tw, descend, compressor) {
        var d2 = this.definition();
        push_ref(d2, this);
        if (d2.references.length == 1 && !d2.fixed && d2.orig[0] instanceof AST_SymbolDefun) {
          tw.loop_ids[d2.id] = tw.in_loop;
        }
        var recursive = recursive_ref(tw, d2);
        if (recursive)
          recursive.enclosed.forEach(function(def2) {
            if (d2 === def2)
              return;
            if (def2.scope.resolve() === recursive)
              return;
            var assigns = def2.fixed && def2.fixed.assigns;
            if (!assigns)
              return;
            if (assigns[assigns.length - 1] instanceof AST_VarDef)
              return;
            var safe = tw.safe_ids[def2.id];
            if (!safe)
              return;
            safe.assign = true;
          });
        if (d2.fixed === false) {
          var redef = d2.redefined();
          if (redef && cross_scope(d2.scope, this.scope))
            redef.single_use = false;
        } else if (d2.fixed === undefined || !safe_to_read(tw, d2)) {
          d2.fixed = false;
        } else if (d2.fixed) {
          if (this.in_arg && d2.orig[0] instanceof AST_SymbolLambda)
            this.fixed = d2.scope;
          var value = this.fixed_value();
          if (recursive) {
            d2.recursive_refs++;
          } else if (value && ref_once(compressor, d2)) {
            d2.in_loop = tw.loop_ids[d2.id] !== tw.in_loop;
            d2.single_use = is_lambda(value) && !value.pinned() && (!d2.in_loop || tw.parent() instanceof AST_Call) || !d2.in_loop && d2.scope === this.scope.resolve() && value.is_constant_expression();
          } else {
            d2.single_use = false;
          }
          if (is_modified(compressor, tw, this, value, 0, is_immutable(value), recursive)) {
            if (d2.single_use) {
              d2.single_use = "m";
            } else {
              d2.fixed = false;
            }
          }
          if (d2.fixed && tw.loop_ids[d2.id] !== tw.in_loop)
            d2.cross_loop = true;
          mark_escaped(tw, d2, this.scope, this, value, 0, 1);
        }
        if (!this.fixed)
          this.fixed = d2.fixed;
        var parent;
        if (value instanceof AST_Lambda && !((parent = tw.parent()) instanceof AST_Call && parent.expression === this)) {
          mark_fn_def(tw, d2, value);
        }
      });
      def(AST_Template, function(tw, descend) {
        var node = this;
        var tag = node.tag;
        if (!tag)
          return;
        if (tag instanceof AST_LambdaExpression) {
          node.expressions.forEach(function(exp) {
            exp.walk(tw);
          });
          tag.walk(tw);
          return true;
        }
        tag.walk(tw);
        node.expressions.forEach(function(exp) {
          exp.walk(tw);
        });
        var fixed = tag instanceof AST_SymbolRef && tag.fixed_value();
        if (fixed instanceof AST_Lambda) {
          mark_fn_def(tw, tag.definition(), fixed);
        } else {
          tw.find_parent(AST_Scope).may_call_this();
        }
        return true;
      });
      def(AST_Toplevel, function(tw, descend, compressor) {
        var node = this;
        node.globals.each(function(def2) {
          reset_def(tw, compressor, def2);
        });
        push(tw);
        reset_variables(tw, compressor, node);
        descend();
        pop_scope(tw, node);
        return true;
      });
      def(AST_Try, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        push(tw);
        walk_body(node, tw);
        pop(tw);
        if (node.bcatch) {
          push(tw);
          node.bcatch.walk(tw);
          pop(tw);
        }
        if (node.bfinally)
          node.bfinally.walk(tw);
        return true;
      });
      def(AST_Unary, function(tw, descend) {
        var node = this;
        if (!UNARY_POSTFIX[node.operator])
          return;
        var exp = node.expression;
        if (!(exp instanceof AST_SymbolRef)) {
          mark_assignment_to_arguments(exp);
          return;
        }
        var d2 = exp.definition();
        d2.assignments++;
        var fixed = d2.fixed;
        if (safe_to_read(tw, d2) && !exp.in_arg && safe_to_assign(tw, d2)) {
          push_ref(d2, exp);
          mark(tw, d2);
          if (d2.single_use)
            d2.single_use = false;
          d2.fixed = function() {
            return make_node(AST_Binary, node, {
              operator: node.operator.slice(0, -1),
              left: make_node(AST_UnaryPrefix, node, {
                operator: "+",
                expression: make_ref(exp, fixed)
              }),
              right: make_node(AST_Number, node, {
                value: 1
              })
            });
          };
          d2.fixed.assigns = fixed && fixed.assigns ? fixed.assigns.slice() : [];
          d2.fixed.assigns.push(node);
          if (node instanceof AST_UnaryPrefix) {
            exp.fixed = d2.fixed;
          } else {
            exp.fixed = function() {
              return make_node(AST_UnaryPrefix, node, {
                operator: "+",
                expression: make_ref(exp, fixed)
              });
            };
            exp.fixed.assigns = fixed && fixed.assigns;
          }
        } else {
          exp.walk(tw);
          d2.fixed = false;
        }
        return true;
      });
      def(AST_VarDef, function(tw, descend, compressor) {
        var node = this;
        var value = node.value;
        if (value instanceof AST_LambdaExpression && node.name instanceof AST_SymbolDeclaration) {
          walk_defn();
          value.parent_scope.resolve().fn_defs.push(value);
          value.safe_ids = null;
          var ld = node.name.definition();
          if (!ld.fixed)
            mark_fn_def(tw, ld, value);
        } else if (value) {
          value.walk(tw);
          walk_defn();
        } else if (tw.parent() instanceof AST_Let) {
          walk_defn();
        }
        return true;
        function walk_defn() {
          scan_declaration(tw, compressor, node.name, function() {
            return node.value || make_node(AST_Undefined, node);
          }, function(name, fixed) {
            var d2 = name.definition();
            if (fixed && safe_to_assign(tw, d2, true)) {
              mark(tw, d2);
              tw.loop_ids[d2.id] = tw.in_loop;
              d2.fixed = fixed;
              d2.fixed.assigns = [node];
              if (name instanceof AST_SymbolConst && d2.redefined() || !(can_drop_symbol(name) || is_safe_lexical(d2))) {
                d2.single_use = false;
              }
            } else {
              d2.fixed = false;
            }
          });
        }
      });
      def(AST_While, function(tw, descend) {
        var save_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        descend();
        pop(tw);
        tw.in_loop = save_loop;
        return true;
      });
    })(function(node, func) {
      node.DEFMETHOD("reduce_vars", func);
    });
    function reset_flags(node) {
      node._squeezed = false;
      node._optimized = false;
      delete node.fixed;
      if (node instanceof AST_Scope)
        delete node._var_names;
    }
    AST_Toplevel.DEFMETHOD("reset_opt_flags", function(compressor) {
      var tw = new TreeWalker(compressor.option("reduce_vars") ? function(node, descend) {
        reset_flags(node);
        return node.reduce_vars(tw, descend, compressor);
      } : reset_flags);
      tw.fn_scanning = null;
      tw.fn_visited = [];
      tw.in_loop = null;
      tw.loop_ids = Object.create(null);
      tw.safe_ids = Object.create(null);
      this.walk(tw);
    });
    AST_Symbol.DEFMETHOD("fixed_value", function() {
      var fixed = this.definition().fixed;
      if (!fixed)
        return fixed;
      if (this.fixed)
        fixed = this.fixed;
      return fixed instanceof AST_Node ? fixed : fixed();
    });
    AST_SymbolRef.DEFMETHOD("is_immutable", function() {
      var def = this.redef || this.definition();
      return def.orig.length == 1 && def.orig[0] instanceof AST_SymbolLambda;
    });
    AST_Node.DEFMETHOD("convert_symbol", noop);
    function convert_destructured(type, process2) {
      return this.transform(new TreeTransformer(function(node, descend) {
        if (node instanceof AST_DefaultValue) {
          node = node.clone();
          node.name = node.name.transform(this);
          return node;
        }
        if (node instanceof AST_Destructured) {
          node = node.clone();
          descend(node, this);
          return node;
        }
        if (node instanceof AST_DestructuredKeyVal) {
          node = node.clone();
          node.value = node.value.transform(this);
          return node;
        }
        return node.convert_symbol(type, process2);
      }));
    }
    AST_DefaultValue.DEFMETHOD("convert_symbol", convert_destructured);
    AST_Destructured.DEFMETHOD("convert_symbol", convert_destructured);
    function convert_symbol(type, process2) {
      var node = make_node(type, this, this);
      process2(node, this);
      return node;
    }
    AST_SymbolDeclaration.DEFMETHOD("convert_symbol", convert_symbol);
    AST_SymbolRef.DEFMETHOD("convert_symbol", convert_symbol);
    function mark_destructured(process2, tw) {
      var marker = new TreeWalker(function(node) {
        if (node instanceof AST_DefaultValue) {
          node.value.walk(tw);
          node.name.walk(marker);
          return true;
        }
        if (node instanceof AST_DestructuredKeyVal) {
          if (node.key instanceof AST_Node)
            node.key.walk(tw);
          node.value.walk(marker);
          return true;
        }
        return process2(node);
      });
      this.walk(marker);
    }
    AST_DefaultValue.DEFMETHOD("mark_symbol", mark_destructured);
    AST_Destructured.DEFMETHOD("mark_symbol", mark_destructured);
    function mark_symbol(process2) {
      return process2(this);
    }
    AST_SymbolDeclaration.DEFMETHOD("mark_symbol", mark_symbol);
    AST_SymbolRef.DEFMETHOD("mark_symbol", mark_symbol);
    AST_Node.DEFMETHOD("match_symbol", function(predicate) {
      return predicate(this);
    });
    function match_destructured(predicate, ignore_side_effects) {
      var found = false;
      var tw = new TreeWalker(function(node) {
        if (found)
          return true;
        if (node instanceof AST_DefaultValue) {
          if (!ignore_side_effects)
            return found = true;
          node.name.walk(tw);
          return true;
        }
        if (node instanceof AST_DestructuredKeyVal) {
          if (!ignore_side_effects && node.key instanceof AST_Node)
            return found = true;
          node.value.walk(tw);
          return true;
        }
        if (predicate(node))
          return found = true;
      });
      this.walk(tw);
      return found;
    }
    AST_DefaultValue.DEFMETHOD("match_symbol", match_destructured);
    AST_Destructured.DEFMETHOD("match_symbol", match_destructured);
    function in_async_generator(scope) {
      return scope instanceof AST_AsyncGeneratorDefun || scope instanceof AST_AsyncGeneratorFunction;
    }
    function find_scope(compressor) {
      var level = 0, node;
      while (node = compressor.parent(level++)) {
        if (node.variables)
          return node;
      }
    }
    var identifier_atom = makePredicate("Infinity NaN undefined");
    function is_lhs_read_only(lhs, compressor) {
      if (lhs instanceof AST_ObjectIdentity)
        return true;
      if (lhs instanceof AST_PropAccess) {
        if (lhs.property === "__proto__")
          return true;
        lhs = lhs.expression;
        if (lhs instanceof AST_SymbolRef) {
          if (lhs.is_immutable())
            return false;
          lhs = lhs.fixed_value();
        }
        if (!lhs)
          return true;
        if (lhs.tail_node().is_constant())
          return true;
        return is_lhs_read_only(lhs, compressor);
      }
      if (lhs instanceof AST_SymbolRef) {
        if (lhs.is_immutable())
          return true;
        var def = lhs.definition();
        return compressor.exposed(def) && identifier_atom[def.name];
      }
      return false;
    }
    function make_node(ctor, orig, props) {
      if (!props)
        props = {};
      if (orig) {
        if (!props.start)
          props.start = orig.start;
        if (!props.end)
          props.end = orig.end;
      }
      return new ctor(props);
    }
    function make_sequence(orig, expressions) {
      if (expressions.length == 1)
        return expressions[0];
      return make_node(AST_Sequence, orig, {
        expressions: expressions.reduce(merge_sequence, [])
      });
    }
    function make_node_from_constant(val, orig) {
      switch (typeof val) {
        case "string":
          return make_node(AST_String, orig, {
            value: val
          });
        case "number":
          if (isNaN(val))
            return make_node(AST_NaN, orig);
          if (isFinite(val)) {
            return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {
              operator: "-",
              expression: make_node(AST_Number, orig, { value: -val })
            }) : make_node(AST_Number, orig, { value: val });
          }
          return val < 0 ? make_node(AST_UnaryPrefix, orig, {
            operator: "-",
            expression: make_node(AST_Infinity, orig)
          }) : make_node(AST_Infinity, orig);
        case "boolean":
          return make_node(val ? AST_True : AST_False, orig);
        case "undefined":
          return make_node(AST_Undefined, orig);
        default:
          if (val === null) {
            return make_node(AST_Null, orig, { value: null });
          }
          if (val instanceof RegExp) {
            return make_node(AST_RegExp, orig, { value: val });
          }
          throw new Error(string_template("Can't handle constant of type: {type}", {
            type: typeof val
          }));
      }
    }
    function needs_unbinding(compressor, val) {
      return val instanceof AST_PropAccess || is_undeclared_ref(val) && val.name == "eval";
    }
    function maintain_this_binding(compressor, parent, orig, val) {
      var wrap = false;
      if (parent.TYPE == "Call") {
        wrap = parent.expression === orig && needs_unbinding(compressor, val);
      } else if (parent instanceof AST_Template) {
        wrap = parent.tag === orig && needs_unbinding(compressor, val);
      } else if (parent instanceof AST_UnaryPrefix) {
        wrap = parent.operator == "delete" || parent.operator == "typeof" && is_undeclared_ref(val);
      }
      return wrap ? make_sequence(orig, [make_node(AST_Number, orig, { value: 0 }), val]) : val;
    }
    function merge_sequence(array, node) {
      if (node instanceof AST_Sequence) {
        array.push.apply(array, node.expressions);
      } else {
        array.push(node);
      }
      return array;
    }
    function is_lexical_definition(stat) {
      return stat instanceof AST_Const || stat instanceof AST_DefClass || stat instanceof AST_Let;
    }
    function safe_to_trim(stat) {
      if (stat instanceof AST_LambdaDefinition) {
        var def = stat.name.definition();
        var scope = stat.name.scope;
        return def.scope === scope || all(def.references, function(ref) {
          var s2 = ref.scope;
          do {
            if (s2 === scope)
              return true;
          } while (s2 = s2.parent_scope);
        });
      }
      return !is_lexical_definition(stat);
    }
    function as_statement_array(thing) {
      if (thing === null)
        return [];
      if (thing instanceof AST_BlockStatement)
        return all(thing.body, safe_to_trim) ? thing.body : [thing];
      if (thing instanceof AST_EmptyStatement)
        return [];
      if (is_statement(thing))
        return [thing];
      throw new Error("Can't convert thing to statement array");
    }
    function is_empty(thing) {
      if (thing === null)
        return true;
      if (thing instanceof AST_EmptyStatement)
        return true;
      if (thing instanceof AST_BlockStatement)
        return thing.body.length == 0;
      return false;
    }
    function has_declarations_only(block) {
      return all(block.body, function(stat) {
        return is_empty(stat) || stat instanceof AST_Defun || stat instanceof AST_Var && declarations_only(stat);
      });
    }
    function loop_body(x2) {
      if (x2 instanceof AST_IterationStatement) {
        return x2.body instanceof AST_BlockStatement ? x2.body : x2;
      }
      return x2;
    }
    function is_iife_call(node) {
      if (node.TYPE != "Call")
        return false;
      do {
        node = node.expression;
      } while (node instanceof AST_PropAccess);
      return node instanceof AST_LambdaExpression ? !is_arrow(node) : is_iife_call(node);
    }
    function is_iife_single(call) {
      var exp = call.expression;
      if (exp.name)
        return false;
      if (!(call instanceof AST_New))
        return true;
      var found = false;
      exp.walk(new TreeWalker(function(node) {
        if (found)
          return true;
        if (node instanceof AST_NewTarget)
          return found = true;
        if (node instanceof AST_Scope && node !== exp)
          return true;
      }));
      return !found;
    }
    function is_undeclared_ref(node) {
      return node instanceof AST_SymbolRef && node.definition().undeclared;
    }
    var global_names = makePredicate("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Map Math Number parseFloat parseInt RangeError ReferenceError RegExp Object Set setInterval setTimeout String SyntaxError TypeError unescape URIError WeakMap WeakSet");
    AST_SymbolRef.DEFMETHOD("is_declared", function(compressor) {
      return this.defined || !this.definition().undeclared || compressor.option("unsafe") && global_names[this.name];
    });
    function declarations_only(node) {
      return all(node.definitions, function(var_def) {
        return !var_def.value;
      });
    }
    function is_declaration(stat, lexical) {
      if (stat instanceof AST_DefClass)
        return lexical && !stat.extends && all(stat.properties, function(prop) {
          if (prop.key instanceof AST_Node)
            return false;
          if (prop instanceof AST_ClassField && prop.static && prop.value)
            return false;
          return true;
        });
      if (stat instanceof AST_Definitions)
        return (lexical || stat instanceof AST_Var) && declarations_only(stat);
      if (stat instanceof AST_ExportDeclaration)
        return is_declaration(stat.body, lexical);
      if (stat instanceof AST_ExportDefault)
        return is_declaration(stat.body, lexical);
      return stat instanceof AST_LambdaDefinition;
    }
    function is_last_statement(body, stat) {
      var index = body.lastIndexOf(stat);
      if (index < 0)
        return false;
      while (++index < body.length) {
        if (!is_declaration(body[index], true))
          return false;
      }
      return true;
    }
    function tighten_body(statements, compressor) {
      var in_loop, in_try, scope;
      find_loop_scope_try();
      var CHANGED, max_iter = 10;
      do {
        CHANGED = false;
        eliminate_spurious_blocks(statements);
        if (compressor.option("dead_code")) {
          eliminate_dead_code(statements, compressor);
        }
        if (compressor.option("if_return")) {
          handle_if_return(statements, compressor);
        }
        if (compressor.sequences_limit > 0) {
          sequencesize(statements, compressor);
          sequencesize_2(statements, compressor);
        }
        if (compressor.option("join_vars")) {
          join_consecutive_vars(statements);
        }
        if (compressor.option("collapse_vars")) {
          collapse(statements, compressor);
        }
      } while (CHANGED && max_iter-- > 0);
      return statements;
      function find_loop_scope_try() {
        var node = compressor.self(), level = 0;
        do {
          if (node instanceof AST_Catch) {
            if (compressor.parent(level).bfinally) {
              if (!in_try)
                in_try = {};
              in_try.bfinally = true;
            }
            level++;
          } else if (node instanceof AST_Finally) {
            level++;
          } else if (node instanceof AST_IterationStatement) {
            in_loop = true;
          } else if (node instanceof AST_Scope) {
            scope = node;
            break;
          } else if (node instanceof AST_Try) {
            if (!in_try)
              in_try = {};
            if (node.bcatch)
              in_try.bcatch = true;
            if (node.bfinally)
              in_try.bfinally = true;
          }
        } while (node = compressor.parent(level++));
      }
      function collapse(statements2, compressor2) {
        if (scope.pinned())
          return statements2;
        var args;
        var assignments = Object.create(null);
        var candidates = [];
        var declare_only = Object.create(null);
        var force_single;
        var stat_index = statements2.length;
        var scanner = new TreeTransformer(function(node, descend) {
          if (abort)
            return node;
          if (!hit) {
            if (node !== hit_stack[hit_index])
              return node;
            hit_index++;
            if (hit_index < hit_stack.length)
              return handle_custom_scan_order(node, scanner);
            hit = true;
            stop_after = (value_def ? find_stop_value : find_stop)(node, 0);
            if (stop_after === node)
              abort = true;
            return node;
          }
          var parent = scanner.parent();
          if (should_stop(node, parent)) {
            abort = true;
            return node;
          }
          if (!stop_if_hit && in_conditional(node, parent)) {
            stop_if_hit = parent;
          }
          if (node.single_use && parent instanceof AST_VarDef && parent.value === node)
            return node;
          var hit_rhs;
          if (!(node instanceof AST_SymbolDeclaration) && (scan_lhs && lhs.equivalent_to(node) || scan_rhs && (hit_rhs = scan_rhs(node, this)))) {
            if (!can_replace || stop_if_hit && (hit_rhs || !lhs_local || !replace_all)) {
              if (!hit_rhs && !value_def)
                abort = true;
              return node;
            }
            if (is_lhs(node, parent)) {
              if (value_def && !hit_rhs)
                assign_used = true;
              return node;
            } else if (value_def) {
              if (stop_if_hit && assign_pos == 0)
                assign_pos = remaining - replaced;
              if (!hit_rhs)
                replaced++;
              return node;
            } else {
              replaced++;
            }
            CHANGED = abort = true;
            AST_Node.info("Collapsing {node} [{file}:{line},{col}]", {
              node,
              file: node.start.file,
              line: node.start.line,
              col: node.start.col
            });
            if (candidate.TYPE == "Binary")
              return make_node(AST_Assign, candidate, {
                operator: "=",
                left: candidate.right.left,
                right: make_node(AST_Conditional, candidate, {
                  condition: candidate.operator == "&&" ? candidate.left : candidate.left.negate(compressor2),
                  consequent: candidate.right.right,
                  alternative: node
                })
              });
            if (candidate instanceof AST_UnaryPostfix) {
              if (lhs instanceof AST_SymbolRef)
                lhs.definition().fixed = false;
              return make_node(AST_UnaryPrefix, candidate, candidate);
            }
            if (candidate instanceof AST_VarDef) {
              var def2 = candidate.name.definition();
              if (def2.references.length - def2.replaced == 1 && !compressor2.exposed(def2)) {
                def2.replaced++;
                return maintain_this_binding(compressor2, parent, node, candidate.value);
              }
              return make_node(AST_Assign, candidate, {
                operator: "=",
                left: make_node(AST_SymbolRef, candidate.name, candidate.name),
                right: candidate.value
              });
            }
            var assign = candidate;
            while (assign.write_only) {
              assign.write_only = false;
              if (!(assign instanceof AST_Assign))
                break;
              assign = assign.right;
            }
            return candidate;
          }
          if (is_last_node(node, parent) || may_throw(node)) {
            stop_after = node;
            if (node instanceof AST_Scope)
              abort = true;
          }
          if (node instanceof AST_Accessor) {
            var replace = can_replace;
            can_replace = false;
            descend(node, scanner);
            can_replace = replace;
            return signal_abort(node);
          }
          if (node instanceof AST_Destructured) {
            var replace = can_replace;
            can_replace = false;
            descend(node, scanner);
            can_replace = replace;
            return signal_abort(node);
          }
          if (node instanceof AST_DefaultValue) {
            node.name = node.name.transform(scanner);
            var replace = can_replace;
            can_replace = false;
            node.value = node.value.transform(scanner);
            can_replace = replace;
            return signal_abort(node);
          }
          if (node instanceof AST_BlockScope && !(node instanceof AST_Scope) && !(node.variables && node.variables.all(function(def3) {
            return !lvalues.has(def3.name);
          }))) {
            var replace = can_replace;
            can_replace = false;
            if (!handle_custom_scan_order(node, scanner))
              descend(node, scanner);
            can_replace = replace;
            return signal_abort(node);
          }
          return handle_custom_scan_order(node, scanner);
        }, signal_abort);
        var multi_replacer = new TreeTransformer(function(node) {
          if (abort)
            return node;
          if (!hit) {
            if (node !== hit_stack[hit_index])
              return node;
            hit_index++;
            switch (hit_stack.length - hit_index) {
              case 0:
                hit = true;
                if (assign_used)
                  return node;
                if (node !== candidate)
                  return node;
                if (node instanceof AST_VarDef)
                  return node;
                def.replaced++;
                var parent = multi_replacer.parent();
                if (parent instanceof AST_Sequence && parent.tail_node() !== node) {
                  value_def.replaced++;
                  return List.skip;
                }
                return rvalue;
              case 1:
                if (!assign_used && node.body === candidate) {
                  hit = true;
                  def.replaced++;
                  value_def.replaced++;
                  return null;
                }
              default:
                return handle_custom_scan_order(node, multi_replacer);
            }
          }
          if (node instanceof AST_SymbolRef && node.definition() === def) {
            if (is_lhs(node, multi_replacer.parent()))
              return node;
            if (!--replaced)
              abort = true;
            var ref = rvalue.clone();
            ref.scope = node.scope;
            ref.reference();
            if (replaced == assign_pos) {
              abort = true;
              return make_node(AST_Assign, candidate, {
                operator: "=",
                left: node,
                right: ref
              });
            }
            def.replaced++;
            return ref;
          }
          if (node instanceof AST_Default || node instanceof AST_Scope)
            return node;
        }, patch_sequence);
        while (--stat_index >= 0) {
          if (stat_index == 0 && compressor2.option("unused"))
            extract_args();
          var hit_stack = [];
          extract_candidates(statements2[stat_index]);
          while (candidates.length > 0) {
            hit_stack = candidates.pop();
            var hit_index = 0;
            var candidate = hit_stack[hit_stack.length - 1];
            var assign_pos = -1;
            var assign_used = false;
            var remaining;
            var value_def = null;
            var stop_after = null;
            var stop_if_hit = null;
            var lhs = get_lhs(candidate);
            var side_effects = lhs && lhs.has_side_effects(compressor2);
            var scan_lhs = lhs && !side_effects && !is_lhs_read_only(lhs, compressor2);
            var scan_rhs = foldable(candidate);
            if (!scan_lhs && !scan_rhs)
              continue;
            var funarg = candidate.name instanceof AST_SymbolFunarg;
            var may_throw = return_false;
            if (candidate.may_throw(compressor2)) {
              if (funarg && is_async(scope))
                continue;
              may_throw = in_try ? function(node) {
                return node.has_side_effects(compressor2);
              } : side_effects_external;
            }
            var read_toplevel = false;
            var modify_toplevel = false;
            var well_defined = true;
            var lvalues = get_lvalues(candidate);
            var lhs_local = is_lhs_local(lhs);
            var rvalue = get_rvalue(candidate);
            if (!side_effects)
              side_effects = value_has_side_effects();
            var check_destructured = in_try || !lhs_local ? function(node) {
              return node instanceof AST_Destructured;
            } : return_false;
            var replace_all = replace_all_symbols(candidate);
            var hit = funarg;
            var abort = false;
            var replaced = 0;
            var can_replace = !args || !hit;
            if (!can_replace) {
              for (var j2 = candidate.arg_index + 1;!abort && j2 < args.length; j2++) {
                if (args[j2])
                  args[j2].transform(scanner);
              }
              can_replace = true;
            }
            for (var i = stat_index;!abort && i < statements2.length; i++) {
              statements2[i].transform(scanner);
            }
            if (value_def) {
              if (!replaced || remaining > replaced + assign_used) {
                candidates.push(hit_stack);
                force_single = true;
                continue;
              }
              if (replaced == assign_pos)
                assign_used = true;
              var def = lhs.definition();
              abort = false;
              hit_index = 0;
              hit = funarg;
              for (var i = stat_index;!abort && i < statements2.length; i++) {
                if (!statements2[i].transform(multi_replacer))
                  statements2.splice(i--, 1);
              }
              replaced = candidate instanceof AST_VarDef && candidate === hit_stack[hit_stack.length - 1] && def.references.length == def.replaced && !compressor2.exposed(def);
              value_def.last_ref = false;
              value_def.single_use = false;
              CHANGED = true;
            }
            if (replaced && !remove_candidate(candidate))
              statements2.splice(stat_index, 1);
          }
        }
        function signal_abort(node) {
          if (abort)
            return node;
          if (stop_after === node)
            abort = true;
          if (stop_if_hit === node)
            stop_if_hit = null;
          return node;
        }
        function handle_custom_scan_order(node, tt2) {
          if (!(node instanceof AST_BlockScope)) {
            if (!(node instanceof AST_ClassProperty && !node.static))
              return;
            if (node.key instanceof AST_Node)
              node.key = node.key.transform(tt2);
            return node;
          }
          if (node instanceof AST_Scope)
            return node;
          if (node instanceof AST_ForEnumeration) {
            node.object = node.object.transform(tt2);
            abort = true;
            return node;
          }
          if (node instanceof AST_Switch) {
            node.expression = node.expression.transform(tt2);
            for (var i2 = 0;!abort && i2 < node.body.length; i2++) {
              var branch = node.body[i2];
              if (branch instanceof AST_Case) {
                if (!hit) {
                  if (branch !== hit_stack[hit_index])
                    continue;
                  hit_index++;
                }
                branch.expression = branch.expression.transform(tt2);
                if (!replace_all)
                  break;
                scan_rhs = false;
              }
            }
            abort = true;
            return node;
          }
        }
        function is_direct_assignment(node, parent) {
          if (parent instanceof AST_Assign)
            return parent.operator == "=" && parent.left === node;
          if (parent instanceof AST_DefaultValue)
            return parent.name === node;
          if (parent instanceof AST_DestructuredArray)
            return true;
          if (parent instanceof AST_DestructuredKeyVal)
            return parent.value === node;
        }
        function should_stop(node, parent) {
          if (node === rvalue)
            return true;
          if (parent instanceof AST_For) {
            if (node !== parent.init)
              return true;
          }
          if (node instanceof AST_Assign) {
            return node.operator != "=" && lhs.equivalent_to(node.left);
          }
          if (node instanceof AST_Call) {
            if (!(lhs instanceof AST_PropAccess))
              return false;
            if (!lhs.equivalent_to(node.expression))
              return false;
            return !(rvalue instanceof AST_LambdaExpression && !rvalue.contains_this());
          }
          if (node instanceof AST_Class)
            return !compressor2.has_directive("use strict");
          if (node instanceof AST_Debugger)
            return true;
          if (node instanceof AST_Defun)
            return funarg && lhs.name === node.name.name;
          if (node instanceof AST_DestructuredKeyVal)
            return node.key instanceof AST_Node;
          if (node instanceof AST_DWLoop)
            return true;
          if (node instanceof AST_LoopControl)
            return true;
          if (node instanceof AST_SymbolRef) {
            if (node.is_declared(compressor2)) {
              if (node.fixed_value())
                return false;
              if (can_drop_symbol(node)) {
                return !(parent instanceof AST_PropAccess && parent.expression === node) && is_arguments(node.definition());
              }
            } else if (is_direct_assignment(node, parent)) {
              return false;
            }
            if (!replace_all)
              return true;
            scan_rhs = false;
            return false;
          }
          if (node instanceof AST_Try)
            return true;
          if (node instanceof AST_With)
            return true;
          return false;
        }
        function in_conditional(node, parent) {
          if (parent instanceof AST_Assign)
            return parent.left !== node && lazy_op[parent.operator.slice(0, -1)];
          if (parent instanceof AST_Binary)
            return parent.left !== node && lazy_op[parent.operator];
          if (parent instanceof AST_Call)
            return parent.optional && parent.expression !== node;
          if (parent instanceof AST_Case)
            return parent.expression !== node;
          if (parent instanceof AST_Conditional)
            return parent.condition !== node;
          if (parent instanceof AST_If)
            return parent.condition !== node;
          if (parent instanceof AST_Sub)
            return parent.optional && parent.expression !== node;
        }
        function is_last_node(node, parent) {
          if (node instanceof AST_Await)
            return true;
          if (node.TYPE == "Binary")
            return node.operator == "in" && !is_object(node.right);
          if (node instanceof AST_Call) {
            var def2, fn = node.expression;
            if (fn instanceof AST_SymbolRef) {
              def2 = fn.definition();
              fn = fn.fixed_value();
            }
            if (!(fn instanceof AST_Lambda))
              return !node.is_expr_pure(compressor2);
            if (def2 && recursive_ref(compressor2, def2, fn))
              return true;
            if (fn.collapse_scanning)
              return false;
            fn.collapse_scanning = true;
            var replace = can_replace;
            can_replace = false;
            var after = stop_after;
            var if_hit = stop_if_hit;
            if (!all(fn.argnames, function(argname) {
              if (argname instanceof AST_DefaultValue) {
                argname.value.transform(scanner);
                if (abort)
                  return false;
                argname = argname.name;
              }
              return !(argname instanceof AST_Destructured);
            })) {
              abort = true;
            } else if (is_arrow(fn) && fn.value) {
              fn.value.transform(scanner);
            } else
              for (var i2 = 0;!abort && i2 < fn.body.length; i2++) {
                var stat = fn.body[i2];
                if (stat instanceof AST_Return) {
                  if (stat.value)
                    stat.value.transform(scanner);
                  break;
                }
                stat.transform(scanner);
              }
            stop_if_hit = if_hit;
            stop_after = after;
            can_replace = replace;
            delete fn.collapse_scanning;
            if (!abort)
              return false;
            abort = false;
            return true;
          }
          if (node instanceof AST_Exit) {
            if (in_try) {
              if (in_try.bfinally)
                return true;
              if (in_try.bcatch && node instanceof AST_Throw)
                return true;
            }
            return side_effects || lhs instanceof AST_PropAccess || may_modify(lhs);
          }
          if (node instanceof AST_Function) {
            return compressor2.option("ie") && node.name && lvalues.has(node.name.name);
          }
          if (node instanceof AST_ObjectIdentity)
            return symbol_in_lvalues(node, parent);
          if (node instanceof AST_PropAccess) {
            if (side_effects)
              return true;
            var exp = node.expression;
            if (exp instanceof AST_SymbolRef && is_arguments(exp.definition()))
              return true;
            if (compressor2.option("unsafe")) {
              if (is_undeclared_ref(exp) && global_names[exp.name])
                return false;
              if (is_static_fn(exp))
                return false;
            }
            if (!well_defined)
              return true;
            if (value_def)
              return false;
            if (!in_try && lhs_local)
              return false;
            if (node.optional)
              return false;
            return exp.may_throw_on_access(compressor2);
          }
          if (node instanceof AST_Spread)
            return true;
          if (node instanceof AST_SymbolRef) {
            if (symbol_in_lvalues(node, parent))
              return !is_direct_assignment(node, parent);
            if (side_effects && may_modify(node))
              return true;
            var def2 = node.definition();
            return (in_try || def2.scope.resolve() !== scope) && !can_drop_symbol(node);
          }
          if (node instanceof AST_Template)
            return !node.is_expr_pure(compressor2);
          if (node instanceof AST_VarDef) {
            if (check_destructured(node.name))
              return true;
            return (node.value || parent instanceof AST_Let) && node.name.match_symbol(function(node2) {
              return node2 instanceof AST_SymbolDeclaration && (lvalues.has(node2.name) || side_effects && may_modify(node2));
            }, true);
          }
          if (node instanceof AST_Yield)
            return true;
          var sym = is_lhs(node.left, node);
          if (!sym)
            return false;
          if (sym instanceof AST_PropAccess)
            return true;
          if (check_destructured(sym))
            return true;
          return sym.match_symbol(function(node2) {
            return node2 instanceof AST_SymbolRef && (lvalues.has(node2.name) || read_toplevel && compressor2.exposed(node2.definition()));
          }, true);
        }
        function may_throw_destructured(node, value) {
          if (!value)
            return !(node instanceof AST_Symbol);
          if (node instanceof AST_DefaultValue) {
            return value.has_side_effects(compressor2) || node.value.has_side_effects(compressor2) || may_throw_destructured(node.name, is_undefined(value) && node.value);
          }
          if (node instanceof AST_Destructured) {
            if (node.rest && may_throw_destructured(node.rest))
              return true;
            if (node instanceof AST_DestructuredArray) {
              if (!(value instanceof AST_Array || value.is_string(compressor2)))
                return true;
              return !all(node.elements, function(element) {
                return !may_throw_destructured(element);
              });
            }
            if (node instanceof AST_DestructuredObject) {
              if (!value.is_defined(compressor2))
                return true;
              return !all(node.properties, function(prop) {
                if (prop instanceof AST_Node && prop.has_side_effects(compressor2))
                  return false;
                return !may_throw_destructured(prop.value);
              });
            }
          }
        }
        function extract_args() {
          var iife, fn = compressor2.self();
          if (fn instanceof AST_LambdaExpression && !is_generator(fn) && !fn.uses_arguments && !fn.pinned() && (iife = compressor2.parent()) instanceof AST_Call && iife.expression === fn && is_iife_single(iife) && all(iife.args, function(arg2) {
            return !(arg2 instanceof AST_Spread);
          })) {
            var fn_strict = compressor2.has_directive("use strict");
            if (fn_strict && !member(fn_strict, fn.body))
              fn_strict = false;
            var has_await = is_async(fn) ? function(node) {
              return node instanceof AST_Symbol && node.name == "await";
            } : function(node) {
              return node instanceof AST_Await && !tw.find_parent(AST_Scope);
            };
            var arg_scope = null;
            var tw = new TreeWalker(function(node, descend) {
              if (!arg)
                return true;
              if (has_await(node) || node instanceof AST_Yield) {
                arg = null;
                return true;
              }
              if (node instanceof AST_ObjectIdentity && (fn_strict || !arg_scope)) {
                arg = null;
                return true;
              }
              if (node instanceof AST_SymbolRef && fn.variables.has(node.name)) {
                var s2 = node.definition().scope;
                if (s2 !== scope)
                  while (s2 = s2.parent_scope) {
                    if (s2 === scope)
                      return true;
                  }
                arg = null;
              }
              if (node instanceof AST_Scope && !is_arrow(node)) {
                var save_scope = arg_scope;
                arg_scope = node;
                descend();
                arg_scope = save_scope;
                return true;
              }
            });
            args = iife.args.slice();
            var len = args.length;
            var names = Object.create(null);
            for (var i2 = fn.argnames.length;--i2 >= 0; ) {
              var sym = fn.argnames[i2];
              var arg = args[i2];
              var value;
              if (sym instanceof AST_DefaultValue) {
                value = sym.value;
                sym = sym.name;
                args[len + i2] = value;
              }
              if (sym instanceof AST_Destructured) {
                if (!may_throw_destructured(sym, arg))
                  continue;
                candidates.length = 0;
                break;
              }
              if (sym.name in names)
                continue;
              names[sym.name] = true;
              if (value)
                arg = !arg || is_undefined(arg) ? value : null;
              if (!arg && !value) {
                arg = make_node(AST_Undefined, sym).transform(compressor2);
              } else if (arg instanceof AST_Lambda && arg.pinned()) {
                arg = null;
              } else if (arg) {
                arg.walk(tw);
              }
              if (!arg)
                continue;
              var candidate2 = make_node(AST_VarDef, sym, {
                name: sym,
                value: arg
              });
              candidate2.name_index = i2;
              candidate2.arg_index = value ? len + i2 : i2;
              candidates.unshift([candidate2]);
            }
          }
        }
        function extract_candidates(expr, unused) {
          hit_stack.push(expr);
          if (expr instanceof AST_Array) {
            expr.elements.forEach(function(node) {
              extract_candidates(node, unused);
            });
          } else if (expr instanceof AST_Assign) {
            var lhs2 = expr.left;
            if (!(lhs2 instanceof AST_Destructured))
              candidates.push(hit_stack.slice());
            extract_candidates(lhs2);
            extract_candidates(expr.right);
            if (lhs2 instanceof AST_SymbolRef && expr.operator == "=") {
              assignments[lhs2.name] = (assignments[lhs2.name] || 0) + 1;
            }
          } else if (expr instanceof AST_Await) {
            extract_candidates(expr.expression, unused);
          } else if (expr instanceof AST_Binary) {
            var lazy = lazy_op[expr.operator];
            if (unused && lazy && expr.operator != "??" && expr.right instanceof AST_Assign && expr.right.operator == "=" && !(expr.right.left instanceof AST_Destructured)) {
              candidates.push(hit_stack.slice());
            }
            extract_candidates(expr.left, !lazy && unused);
            extract_candidates(expr.right, unused);
          } else if (expr instanceof AST_Call) {
            extract_candidates(expr.expression);
            expr.args.forEach(extract_candidates);
          } else if (expr instanceof AST_Case) {
            extract_candidates(expr.expression);
          } else if (expr instanceof AST_Conditional) {
            extract_candidates(expr.condition);
            extract_candidates(expr.consequent, unused);
            extract_candidates(expr.alternative, unused);
          } else if (expr instanceof AST_Definitions) {
            expr.definitions.forEach(extract_candidates);
          } else if (expr instanceof AST_Dot) {
            extract_candidates(expr.expression);
          } else if (expr instanceof AST_DWLoop) {
            extract_candidates(expr.condition);
            if (!(expr.body instanceof AST_Block)) {
              extract_candidates(expr.body);
            }
          } else if (expr instanceof AST_Exit) {
            if (expr.value)
              extract_candidates(expr.value);
          } else if (expr instanceof AST_For) {
            if (expr.init)
              extract_candidates(expr.init, true);
            if (expr.condition)
              extract_candidates(expr.condition);
            if (expr.step)
              extract_candidates(expr.step, true);
            if (!(expr.body instanceof AST_Block)) {
              extract_candidates(expr.body);
            }
          } else if (expr instanceof AST_ForEnumeration) {
            extract_candidates(expr.object);
            if (!(expr.body instanceof AST_Block)) {
              extract_candidates(expr.body);
            }
          } else if (expr instanceof AST_If) {
            extract_candidates(expr.condition);
            if (!(expr.body instanceof AST_Block)) {
              extract_candidates(expr.body);
            }
            if (expr.alternative && !(expr.alternative instanceof AST_Block)) {
              extract_candidates(expr.alternative);
            }
          } else if (expr instanceof AST_Object) {
            expr.properties.forEach(function(prop) {
              hit_stack.push(prop);
              if (prop.key instanceof AST_Node)
                extract_candidates(prop.key);
              if (prop instanceof AST_ObjectKeyVal)
                extract_candidates(prop.value, unused);
              hit_stack.pop();
            });
          } else if (expr instanceof AST_Sequence) {
            var end = expr.expressions.length - (unused ? 0 : 1);
            expr.expressions.forEach(function(node, index) {
              extract_candidates(node, index < end);
            });
          } else if (expr instanceof AST_SimpleStatement) {
            extract_candidates(expr.body, true);
          } else if (expr instanceof AST_Spread) {
            extract_candidates(expr.expression);
          } else if (expr instanceof AST_Sub) {
            extract_candidates(expr.expression);
            extract_candidates(expr.property);
          } else if (expr instanceof AST_Switch) {
            extract_candidates(expr.expression);
            expr.body.forEach(extract_candidates);
          } else if (expr instanceof AST_Unary) {
            if (UNARY_POSTFIX[expr.operator]) {
              candidates.push(hit_stack.slice());
            } else {
              extract_candidates(expr.expression);
            }
          } else if (expr instanceof AST_VarDef) {
            if (expr.name instanceof AST_SymbolVar) {
              if (expr.value) {
                var def2 = expr.name.definition();
                if (def2.references.length > def2.replaced) {
                  candidates.push(hit_stack.slice());
                }
              } else {
                declare_only[expr.name.name] = (declare_only[expr.name.name] || 0) + 1;
              }
            }
            if (expr.value)
              extract_candidates(expr.value);
          } else if (expr instanceof AST_Yield) {
            if (expr.expression)
              extract_candidates(expr.expression);
          }
          hit_stack.pop();
        }
        function find_stop(node, level) {
          var parent = scanner.parent(level);
          if (parent instanceof AST_Array)
            return node;
          if (parent instanceof AST_Assign)
            return node;
          if (parent instanceof AST_Await)
            return node;
          if (parent instanceof AST_Binary)
            return node;
          if (parent instanceof AST_Call)
            return node;
          if (parent instanceof AST_Case)
            return node;
          if (parent instanceof AST_Conditional)
            return node;
          if (parent instanceof AST_Definitions)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Exit)
            return node;
          if (parent instanceof AST_If)
            return node;
          if (parent instanceof AST_IterationStatement)
            return node;
          if (parent instanceof AST_ObjectProperty)
            return node;
          if (parent instanceof AST_PropAccess)
            return node;
          if (parent instanceof AST_Sequence) {
            return (parent.tail_node() === node ? find_stop : find_stop_unused)(parent, level + 1);
          }
          if (parent instanceof AST_SimpleStatement)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Spread)
            return node;
          if (parent instanceof AST_Switch)
            return node;
          if (parent instanceof AST_Unary)
            return node;
          if (parent instanceof AST_VarDef)
            return node;
          if (parent instanceof AST_Yield)
            return node;
          return null;
        }
        function find_stop_logical(parent, op, level) {
          var node;
          do {
            node = parent;
            parent = scanner.parent(++level);
          } while (parent instanceof AST_Assign && parent.operator.slice(0, -1) == op || parent instanceof AST_Binary && parent.operator == op);
          return node;
        }
        function find_stop_expr(expr, cont, node, parent, level) {
          var replace = can_replace;
          can_replace = false;
          var after = stop_after;
          var if_hit = stop_if_hit;
          var stack = scanner.stack;
          scanner.stack = [parent];
          expr.transform(scanner);
          scanner.stack = stack;
          stop_if_hit = if_hit;
          stop_after = after;
          can_replace = replace;
          if (abort) {
            abort = false;
            return node;
          }
          return cont(parent, level + 1);
        }
        function find_stop_value(node, level) {
          var parent = scanner.parent(level);
          if (parent instanceof AST_Array)
            return find_stop_value(parent, level + 1);
          if (parent instanceof AST_Assign) {
            if (may_throw(parent))
              return node;
            if (parent.left.match_symbol(function(ref) {
              return ref instanceof AST_SymbolRef && (lhs.name == ref.name || value_def.name == ref.name);
            }))
              return node;
            var op;
            if (parent.left === node || !lazy_op[op = parent.operator.slice(0, -1)]) {
              return find_stop_value(parent, level + 1);
            }
            return find_stop_logical(parent, op, level);
          }
          if (parent instanceof AST_Binary) {
            var op;
            if (parent.left === node || !lazy_op[op = parent.operator]) {
              return find_stop_value(parent, level + 1);
            }
            return find_stop_logical(parent, op, level);
          }
          if (parent instanceof AST_Call)
            return parent;
          if (parent instanceof AST_Case) {
            if (parent.expression !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_Conditional) {
            if (parent.condition !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_Definitions)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Do)
            return node;
          if (parent instanceof AST_Exit)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_For) {
            if (parent.init !== node && parent.condition !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_ForEnumeration) {
            if (parent.init !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_If) {
            if (parent.condition !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_ObjectProperty) {
            var obj = scanner.parent(level + 1);
            return all(obj.properties, function(prop) {
              return prop instanceof AST_ObjectKeyVal;
            }) ? find_stop_value(obj, level + 2) : obj;
          }
          if (parent instanceof AST_PropAccess) {
            var exp = parent.expression;
            return exp === node ? find_stop_value(parent, level + 1) : node;
          }
          if (parent instanceof AST_Sequence) {
            return (parent.tail_node() === node ? find_stop_value : find_stop_unused)(parent, level + 1);
          }
          if (parent instanceof AST_SimpleStatement)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Spread)
            return find_stop_value(parent, level + 1);
          if (parent instanceof AST_Switch) {
            if (parent.expression !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_Unary) {
            if (parent.operator == "delete")
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_VarDef)
            return parent.name.match_symbol(function(sym) {
              return sym instanceof AST_SymbolDeclaration && (lhs.name == sym.name || value_def.name == sym.name);
            }) ? node : find_stop_value(parent, level + 1);
          if (parent instanceof AST_While) {
            if (parent.condition !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_Yield)
            return find_stop_value(parent, level + 1);
          return null;
        }
        function find_stop_unused(node, level) {
          var parent = scanner.parent(level);
          if (is_last_node(node, parent))
            return node;
          if (in_conditional(node, parent))
            return node;
          if (parent instanceof AST_Array)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Assign)
            return check_assignment(parent.left);
          if (parent instanceof AST_Await)
            return node;
          if (parent instanceof AST_Binary)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Call)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Case)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Conditional)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Definitions)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Exit)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_If)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_IterationStatement)
            return node;
          if (parent instanceof AST_ObjectProperty) {
            var obj = scanner.parent(level + 1);
            return all(obj.properties, function(prop) {
              return prop instanceof AST_ObjectKeyVal;
            }) ? find_stop_unused(obj, level + 2) : obj;
          }
          if (parent instanceof AST_PropAccess) {
            var exp = parent.expression;
            if (exp === node)
              return find_stop_unused(parent, level + 1);
            return find_stop_expr(exp, find_stop_unused, node, parent, level);
          }
          if (parent instanceof AST_Sequence)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_SimpleStatement)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Spread)
            return node;
          if (parent instanceof AST_Switch)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Unary)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_VarDef)
            return check_assignment(parent.name);
          if (parent instanceof AST_Yield)
            return node;
          return null;
          function check_assignment(lhs2) {
            if (may_throw(parent))
              return node;
            if (lhs2 !== node && lhs2 instanceof AST_Destructured) {
              return find_stop_expr(lhs2, find_stop_unused, node, parent, level);
            }
            return find_stop_unused(parent, level + 1);
          }
        }
        function mangleable_var(rhs) {
          if (force_single) {
            force_single = false;
            return;
          }
          if (remaining < 1)
            return;
          var value = rhs instanceof AST_Assign && rhs.operator == "=" ? rhs.left : rhs;
          if (!(value instanceof AST_SymbolRef))
            return;
          var def2 = value.definition();
          if (def2.undeclared)
            return;
          if (is_arguments(def2))
            return;
          if (value !== rhs) {
            if (is_lhs_read_only(value, compressor2))
              return;
            var referenced = def2.references.length - def2.replaced;
            if (referenced < 2)
              return;
            var expr = candidate.clone();
            expr[expr instanceof AST_Assign ? "right" : "value"] = value;
            if (candidate.name_index >= 0) {
              expr.name_index = candidate.name_index;
              expr.arg_index = candidate.arg_index;
            }
            candidate = expr;
          }
          return value_def = def2;
        }
        function remaining_refs(def2) {
          return def2.references.length - def2.replaced - (assignments[def2.name] || 0);
        }
        function get_lhs(expr) {
          if (expr instanceof AST_Assign) {
            var lhs2 = expr.left;
            if (expr.operator != "=")
              return lhs2;
            if (!(lhs2 instanceof AST_SymbolRef))
              return lhs2;
            var def2 = lhs2.definition();
            if (scope.uses_arguments && is_funarg(def2))
              return lhs2;
            if (compressor2.exposed(def2))
              return lhs2;
            remaining = remaining_refs(def2);
            if (def2.fixed && lhs2.fixed) {
              var matches = def2.references.filter(function(ref) {
                return ref.fixed === lhs2.fixed;
              }).length - 1;
              if (matches < remaining) {
                remaining = matches;
                assign_pos = 0;
              }
            }
            mangleable_var(expr.right);
            return lhs2;
          }
          if (expr instanceof AST_Binary)
            return expr.right.left;
          if (expr instanceof AST_Unary)
            return expr.expression;
          if (expr instanceof AST_VarDef) {
            var lhs2 = expr.name;
            var def2 = lhs2.definition();
            if (def2.const_redefs)
              return;
            if (!member(lhs2, def2.orig))
              return;
            if (scope.uses_arguments && is_funarg(def2))
              return;
            var declared = def2.orig.length - def2.eliminated - (declare_only[def2.name] || 0);
            remaining = remaining_refs(def2);
            if (def2.fixed)
              remaining = Math.min(remaining, def2.references.filter(function(ref) {
                if (!ref.fixed)
                  return true;
                if (!ref.fixed.assigns)
                  return true;
                var assign = ref.fixed.assigns[0];
                return assign === lhs2 || get_rvalue(assign) === expr.value;
              }).length);
            if (declared > 1 && !(lhs2 instanceof AST_SymbolFunarg)) {
              mangleable_var(expr.value);
              return make_node(AST_SymbolRef, lhs2, lhs2);
            }
            if (mangleable_var(expr.value) || remaining == 1 && !compressor2.exposed(def2)) {
              return make_node(AST_SymbolRef, lhs2, lhs2);
            }
            return;
          }
        }
        function get_rvalue(expr) {
          if (expr instanceof AST_Assign)
            return expr.right;
          if (expr instanceof AST_Binary) {
            var node = expr.clone();
            node.right = expr.right.right;
            return node;
          }
          if (expr instanceof AST_VarDef)
            return expr.value;
        }
        function invariant(expr) {
          if (expr instanceof AST_Array)
            return false;
          if (expr instanceof AST_Binary && lazy_op[expr.operator]) {
            return invariant(expr.left) && invariant(expr.right);
          }
          if (expr instanceof AST_Call)
            return false;
          if (expr instanceof AST_Conditional) {
            return invariant(expr.consequent) && invariant(expr.alternative);
          }
          if (expr instanceof AST_Object)
            return false;
          return !expr.has_side_effects(compressor2);
        }
        function foldable(expr) {
          if (expr instanceof AST_Assign && expr.right.single_use)
            return;
          var lhs_ids = Object.create(null);
          var marker = new TreeWalker(function(node) {
            if (node instanceof AST_SymbolRef)
              lhs_ids[node.definition().id] = true;
          });
          while (expr instanceof AST_Assign && expr.operator == "=") {
            expr.left.walk(marker);
            expr = expr.right;
          }
          if (expr instanceof AST_ObjectIdentity)
            return rhs_exact_match;
          if (expr instanceof AST_SymbolRef) {
            var value = expr.evaluate(compressor2);
            if (value === expr)
              return rhs_exact_match;
            return rhs_fuzzy_match(value, rhs_exact_match);
          }
          if (expr.is_truthy())
            return rhs_fuzzy_match(true, return_false);
          if (expr.is_constant()) {
            var ev = expr.evaluate(compressor2);
            if (!(ev instanceof AST_Node))
              return rhs_fuzzy_match(ev, rhs_exact_match);
          }
          if (!(lhs instanceof AST_SymbolRef))
            return false;
          if (!invariant(expr))
            return false;
          var circular;
          expr.walk(new TreeWalker(function(node) {
            if (circular)
              return true;
            if (node instanceof AST_SymbolRef && lhs_ids[node.definition().id])
              circular = true;
          }));
          return !circular && rhs_exact_match;
          function rhs_exact_match(node) {
            return expr.equivalent_to(node);
          }
        }
        function rhs_fuzzy_match(value, fallback) {
          return function(node, tw) {
            if (tw.in_boolean_context()) {
              if (value && node.is_truthy() && !node.has_side_effects(compressor2)) {
                return true;
              }
              if (node.is_constant()) {
                var ev = node.evaluate(compressor2);
                if (!(ev instanceof AST_Node))
                  return !ev == !value;
              }
            }
            return fallback(node);
          };
        }
        function may_be_global(node) {
          if (node instanceof AST_SymbolRef) {
            node = node.fixed_value();
            if (!node)
              return true;
          }
          if (node instanceof AST_Assign)
            return node.operator == "=" && may_be_global(node.right);
          return node instanceof AST_PropAccess || node instanceof AST_ObjectIdentity;
        }
        function get_lvalues(expr) {
          var lvalues2 = new Dictionary;
          if (expr instanceof AST_VarDef) {
            if (!expr.name.definition().fixed)
              well_defined = false;
            lvalues2.add(expr.name.name, lhs);
          }
          var find_arguments = scope.uses_arguments && !compressor2.has_directive("use strict");
          var scan_toplevel = scope instanceof AST_Toplevel;
          var tw = new TreeWalker(function(node) {
            var value;
            if (node instanceof AST_SymbolRef) {
              value = node.fixed_value();
              if (!value) {
                value = node;
                var def2 = node.definition();
                if (!def2.undeclared && (def2.assignments || !def2.escaped || def2.escaped.cross_scope) && (has_escaped(def2, node.scope, node, tw.parent()) || !same_scope(def2))) {
                  well_defined = false;
                }
              }
            } else if (node instanceof AST_ObjectIdentity) {
              value = node;
            }
            if (value)
              lvalues2.add(node.name, is_modified(compressor2, tw, node, value, 0));
            if (find_arguments && node instanceof AST_Sub) {
              scope.each_argname(function(argname) {
                if (!compressor2.option("reduce_vars") || argname.definition().assignments) {
                  if (!argname.definition().fixed)
                    well_defined = false;
                  lvalues2.add(argname.name, true);
                }
              });
              find_arguments = false;
            }
            if (!scan_toplevel)
              return;
            if (node.TYPE == "Call") {
              if (modify_toplevel)
                return;
              var exp = node.expression;
              if (exp instanceof AST_PropAccess)
                return;
              if (exp instanceof AST_LambdaExpression && !exp.contains_this())
                return;
              modify_toplevel = true;
            } else if (node instanceof AST_PropAccess && may_be_global(node.expression)) {
              if (node === lhs && !(expr instanceof AST_Unary)) {
                modify_toplevel = true;
              } else {
                read_toplevel = true;
              }
            }
          });
          expr.walk(tw);
          return lvalues2;
        }
        function remove_candidate(expr) {
          var index = expr.name_index;
          if (index >= 0) {
            var argname = scope.argnames[index];
            if (argname instanceof AST_DefaultValue) {
              argname.value = make_node(AST_Number, argname, {
                value: 0
              });
              argname.name.definition().fixed = false;
            } else {
              var args2 = compressor2.parent().args;
              if (args2[index]) {
                args2[index] = make_node(AST_Number, args2[index], {
                  value: 0
                });
                argname.definition().fixed = false;
              }
            }
            return true;
          }
          var end = hit_stack.length - 1;
          if (hit_stack[end - 1].body === hit_stack[end])
            end--;
          var tt2 = new TreeTransformer(function(node, descend, in_list) {
            if (hit)
              return node;
            if (node !== hit_stack[hit_index])
              return node;
            hit_index++;
            if (hit_index <= end)
              return handle_custom_scan_order(node, tt2);
            hit = true;
            if (node instanceof AST_VarDef) {
              declare_only[node.name.name] = (declare_only[node.name.name] || 0) + 1;
              if (value_def)
                value_def.replaced++;
              node = node.clone();
              node.value = null;
              return node;
            }
            return in_list ? List.skip : null;
          }, patch_sequence);
          abort = false;
          hit = false;
          hit_index = 0;
          return statements2[stat_index].transform(tt2);
        }
        function patch_sequence(node) {
          if (node instanceof AST_Sequence)
            switch (node.expressions.length) {
              case 0:
                return null;
              case 1:
                return maintain_this_binding(compressor2, this.parent(), node, node.expressions[0]);
            }
        }
        function is_lhs_local(lhs2) {
          var sym = root_expr(lhs2);
          return sym instanceof AST_SymbolRef && sym.definition().scope.resolve() === scope && !(in_loop && (lvalues.has(sym.name) && lvalues.get(sym.name)[0] !== lhs2 || candidate instanceof AST_Unary || candidate instanceof AST_Assign && candidate.operator != "="));
        }
        function value_has_side_effects() {
          if (candidate instanceof AST_Unary)
            return false;
          return rvalue.has_side_effects(compressor2);
        }
        function replace_all_symbols(expr) {
          if (expr instanceof AST_Unary)
            return false;
          if (side_effects)
            return false;
          if (value_def)
            return true;
          if (!(lhs instanceof AST_SymbolRef))
            return false;
          var referenced;
          if (expr instanceof AST_VarDef) {
            referenced = 1;
          } else if (expr.operator == "=") {
            referenced = 2;
          } else {
            return false;
          }
          var def2 = lhs.definition();
          return def2.references.length - def2.replaced == referenced;
        }
        function symbol_in_lvalues(sym, parent) {
          var lvalue = lvalues.get(sym.name);
          if (!lvalue || all(lvalue, function(lhs2) {
            return !lhs2;
          }))
            return;
          if (lvalue[0] !== lhs)
            return true;
          scan_rhs = false;
        }
        function may_modify(sym) {
          var def2 = sym.definition();
          if (def2.orig.length == 1 && def2.orig[0] instanceof AST_SymbolDefun)
            return false;
          if (def2.scope.resolve() !== scope)
            return true;
          if (modify_toplevel && compressor2.exposed(def2))
            return true;
          return !all(def2.references, function(ref) {
            return ref.scope.resolve() === scope;
          });
        }
        function side_effects_external(node, lhs2) {
          if (node instanceof AST_Assign)
            return side_effects_external(node.left, true);
          if (node instanceof AST_Unary)
            return side_effects_external(node.expression, true);
          if (node instanceof AST_VarDef)
            return node.value && side_effects_external(node.value);
          if (lhs2) {
            if (node instanceof AST_Dot)
              return side_effects_external(node.expression, true);
            if (node instanceof AST_Sub)
              return side_effects_external(node.expression, true);
            if (node instanceof AST_SymbolRef)
              return node.definition().scope.resolve() !== scope;
          }
          return false;
        }
      }
      function eliminate_spurious_blocks(statements2) {
        var seen_dirs = [];
        for (var i = 0;i < statements2.length; ) {
          var stat = statements2[i];
          if (stat instanceof AST_BlockStatement) {
            if (all(stat.body, safe_to_trim)) {
              CHANGED = true;
              eliminate_spurious_blocks(stat.body);
              [].splice.apply(statements2, [i, 1].concat(stat.body));
              i += stat.body.length;
              continue;
            }
          }
          if (stat instanceof AST_Directive) {
            if (member(stat.value, seen_dirs)) {
              CHANGED = true;
              statements2.splice(i, 1);
              continue;
            }
            seen_dirs.push(stat.value);
          }
          if (stat instanceof AST_EmptyStatement) {
            CHANGED = true;
            statements2.splice(i, 1);
            continue;
          }
          i++;
        }
      }
      function handle_if_return(statements2, compressor2) {
        var self = compressor2.self();
        var parent = compressor2.parent();
        var in_lambda = last_of(function(node) {
          return node instanceof AST_Lambda;
        });
        var in_iife = in_lambda && parent && parent.TYPE == "Call";
        var multiple_if_returns = has_multiple_if_returns(statements2);
        for (var i = statements2.length;--i >= 0; ) {
          var stat = statements2[i];
          var j2 = next_index(i);
          var next = statements2[j2];
          if (in_lambda && !next && stat instanceof AST_Return) {
            if (!stat.value) {
              CHANGED = true;
              statements2.splice(i, 1);
              continue;
            }
            var tail = stat.value.tail_node();
            if (tail instanceof AST_UnaryPrefix && tail.operator == "void") {
              CHANGED = true;
              var body;
              if (tail === stat.value) {
                body = tail.expression;
              } else {
                body = stat.value.clone();
                body.expressions[body.length - 1] = tail.expression;
              }
              statements2[i] = make_node(AST_SimpleStatement, stat, {
                body
              });
              continue;
            }
          }
          if (stat instanceof AST_If) {
            var ab = aborts(stat.body);
            if (can_merge_flow(ab)) {
              if (ab.label)
                remove(ab.label.thedef.references, ab);
              CHANGED = true;
              stat = stat.clone();
              stat.condition = stat.condition.negate(compressor2);
              var body = as_statement_array_with_return(stat.body, ab);
              stat.body = make_node(AST_BlockStatement, stat, {
                body: as_statement_array(stat.alternative).concat(extract_functions())
              });
              stat.alternative = make_node(AST_BlockStatement, stat, {
                body
              });
              statements2[i] = stat;
              statements2[i] = stat.transform(compressor2);
              continue;
            }
            if (ab && !stat.alternative && stat.body instanceof AST_BlockStatement && next instanceof AST_Jump) {
              var negated = stat.condition.negate(compressor2);
              if (negated.print_to_string().length <= stat.condition.print_to_string().length) {
                CHANGED = true;
                stat = stat.clone();
                stat.condition = negated;
                statements2[j2] = stat.body;
                stat.body = next;
                statements2[i] = stat;
                statements2[i] = stat.transform(compressor2);
                continue;
              }
            }
            var alt = aborts(stat.alternative);
            if (can_merge_flow(alt)) {
              if (alt.label)
                remove(alt.label.thedef.references, alt);
              CHANGED = true;
              stat = stat.clone();
              stat.body = make_node(AST_BlockStatement, stat.body, {
                body: as_statement_array(stat.body).concat(extract_functions())
              });
              var body = as_statement_array_with_return(stat.alternative, alt);
              stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                body
              });
              statements2[i] = stat;
              statements2[i] = stat.transform(compressor2);
              continue;
            }
            if (compressor2.option("typeofs")) {
              if (ab && !alt) {
                mark_locally_defined(stat.condition, null, make_node(AST_BlockStatement, self, {
                  body: statements2.slice(i + 1)
                }));
              }
              if (!ab && alt) {
                mark_locally_defined(stat.condition, make_node(AST_BlockStatement, self, {
                  body: statements2.slice(i + 1)
                }));
              }
            }
          }
          if (stat instanceof AST_If && stat.body instanceof AST_Return) {
            var value = stat.body.value;
            var in_bool = stat.body.in_bool || next instanceof AST_Return && next.in_bool;
            if (!value && !stat.alternative && (in_lambda && !next || next instanceof AST_Return && !next.value)) {
              CHANGED = true;
              statements2[i] = make_node(AST_SimpleStatement, stat.condition, {
                body: stat.condition
              });
              continue;
            }
            if (!stat.alternative && next instanceof AST_Return) {
              CHANGED = true;
              stat = stat.clone();
              stat.alternative = next;
              statements2.splice(i, 1, stat.transform(compressor2));
              statements2.splice(j2, 1);
              continue;
            }
            if (!stat.alternative && !next && in_lambda && (in_bool || value && multiple_if_returns)) {
              CHANGED = true;
              stat = stat.clone();
              stat.alternative = make_node(AST_Return, stat, {
                value: null
              });
              statements2.splice(i, 1, stat.transform(compressor2));
              continue;
            }
            var prev = statements2[prev_index(i)];
            if (compressor2.option("sequences") && in_lambda && !stat.alternative && (!prev && in_iife || prev instanceof AST_If && prev.body instanceof AST_Return) && next_index(j2) == statements2.length && next instanceof AST_SimpleStatement) {
              CHANGED = true;
              stat = stat.clone();
              stat.alternative = make_node(AST_BlockStatement, next, {
                body: [
                  next,
                  make_node(AST_Return, next, {
                    value: null
                  })
                ]
              });
              statements2.splice(i, 1, stat.transform(compressor2));
              statements2.splice(j2, 1);
              continue;
            }
          }
        }
        function has_multiple_if_returns(statements3) {
          var n = 0;
          for (var i2 = statements3.length;--i2 >= 0; ) {
            var stat2 = statements3[i2];
            if (stat2 instanceof AST_If && stat2.body instanceof AST_Return) {
              if (++n > 1)
                return true;
            }
          }
          return false;
        }
        function is_return_void(value2) {
          return !value2 || value2 instanceof AST_UnaryPrefix && value2.operator == "void";
        }
        function last_of(predicate) {
          var block = self, stat2, level = 0;
          do {
            do {
              if (predicate(block))
                return true;
              block = compressor2.parent(level++);
            } while (block instanceof AST_If && (stat2 = block));
          } while ((block instanceof AST_BlockStatement || block instanceof AST_Scope) && is_last_statement(block.body, stat2));
        }
        function match_target(target) {
          return last_of(function(node) {
            return node === target;
          });
        }
        function can_drop_abort(ab2) {
          if (ab2 instanceof AST_Return)
            return in_lambda && is_return_void(ab2.value);
          if (!(ab2 instanceof AST_LoopControl))
            return false;
          var lct = compressor2.loopcontrol_target(ab2);
          if (ab2 instanceof AST_Continue)
            return match_target(loop_body(lct));
          if (lct instanceof AST_IterationStatement)
            return false;
          return match_target(lct);
        }
        function can_merge_flow(ab2) {
          if (!can_drop_abort(ab2))
            return false;
          for (var j3 = statements2.length;--j3 > i; ) {
            var stat2 = statements2[j3];
            if (stat2 instanceof AST_DefClass) {
              if (stat2.name.definition().preinit)
                return false;
            } else if (stat2 instanceof AST_Const || stat2 instanceof AST_Let) {
              if (!all(stat2.definitions, function(defn) {
                return !defn.name.match_symbol(function(node) {
                  return node instanceof AST_SymbolDeclaration && node.definition().preinit;
                });
              }))
                return false;
            }
          }
          return true;
        }
        function extract_functions() {
          var defuns = [];
          var lexical = false;
          var tail2 = statements2.splice(i + 1).filter(function(stat2) {
            if (stat2 instanceof AST_LambdaDefinition) {
              defuns.push(stat2);
              return false;
            }
            if (is_lexical_definition(stat2))
              lexical = true;
            return true;
          });
          [].push.apply(lexical ? tail2 : statements2, defuns);
          return tail2;
        }
        function as_statement_array_with_return(node, ab2) {
          var body2 = as_statement_array(node);
          var block = body2, last;
          while ((last = block[block.length - 1]) !== ab2) {
            block = last.body;
          }
          block.pop();
          if (ab2.value)
            block.push(make_node(AST_SimpleStatement, ab2.value, {
              body: ab2.value.expression
            }));
          return body2;
        }
        function next_index(i2) {
          for (var j3 = i2 + 1;j3 < statements2.length; j3++) {
            if (!is_declaration(statements2[j3]))
              break;
          }
          return j3;
        }
        function prev_index(i2) {
          for (var j3 = i2;--j3 >= 0; ) {
            if (!is_declaration(statements2[j3]))
              break;
          }
          return j3;
        }
      }
      function eliminate_dead_code(statements2, compressor2) {
        var has_quit;
        var self = compressor2.self();
        for (var i = 0, n = 0, len = statements2.length;i < len; i++) {
          var stat = statements2[i];
          if (stat instanceof AST_LoopControl) {
            var lct = compressor2.loopcontrol_target(stat);
            if (stat instanceof AST_Break && !(lct instanceof AST_IterationStatement) && loop_body(lct) === self || stat instanceof AST_Continue && loop_body(lct) === self) {
              if (stat.label)
                remove(stat.label.thedef.references, stat);
            } else {
              statements2[n++] = stat;
            }
          } else {
            statements2[n++] = stat;
          }
          if (aborts(stat)) {
            has_quit = statements2.slice(i + 1);
            break;
          }
        }
        statements2.length = n;
        CHANGED = n != len;
        if (has_quit)
          has_quit.forEach(function(stat2) {
            extract_declarations_from_unreachable_code(compressor2, stat2, statements2);
          });
      }
      function sequencesize(statements2, compressor2) {
        if (statements2.length < 2)
          return;
        var seq = [], n = 0;
        function push_seq() {
          if (!seq.length)
            return;
          var body2 = make_sequence(seq[0], seq);
          statements2[n++] = make_node(AST_SimpleStatement, body2, { body: body2 });
          seq = [];
        }
        for (var i = 0, len = statements2.length;i < len; i++) {
          var stat = statements2[i];
          if (stat instanceof AST_SimpleStatement) {
            if (seq.length >= compressor2.sequences_limit)
              push_seq();
            var body = stat.body;
            if (seq.length > 0)
              body = body.drop_side_effect_free(compressor2);
            if (body)
              merge_sequence(seq, body);
          } else if (is_declaration(stat)) {
            statements2[n++] = stat;
          } else {
            push_seq();
            statements2[n++] = stat;
          }
        }
        push_seq();
        statements2.length = n;
        if (n != len)
          CHANGED = true;
      }
      function to_simple_statement(block, decls) {
        if (!(block instanceof AST_BlockStatement))
          return block;
        var stat = null;
        for (var i = 0;i < block.body.length; i++) {
          var line = block.body[i];
          if (line instanceof AST_Var && declarations_only(line)) {
            decls.push(line);
          } else if (stat || is_lexical_definition(line)) {
            return false;
          } else {
            stat = line;
          }
        }
        return stat;
      }
      function sequencesize_2(statements2, compressor2) {
        function cons_seq(right) {
          n--;
          CHANGED = true;
          var left = prev.body;
          return make_sequence(left, [left, right]);
        }
        var n = 0, prev;
        for (var i = 0;i < statements2.length; i++) {
          var stat = statements2[i];
          if (prev) {
            if (stat instanceof AST_Exit) {
              if (stat.value || !in_async_generator(scope)) {
                stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat)).optimize(compressor2);
              }
            } else if (stat instanceof AST_For) {
              if (!(stat.init instanceof AST_Definitions)) {
                var abort = false;
                prev.body.walk(new TreeWalker(function(node) {
                  if (abort || node instanceof AST_Scope)
                    return true;
                  if (node instanceof AST_Binary && node.operator == "in") {
                    abort = true;
                    return true;
                  }
                }));
                if (!abort) {
                  if (stat.init)
                    stat.init = cons_seq(stat.init);
                  else {
                    stat.init = prev.body;
                    n--;
                    CHANGED = true;
                  }
                }
              }
            } else if (stat instanceof AST_ForIn) {
              if (!is_lexical_definition(stat.init))
                stat.object = cons_seq(stat.object);
            } else if (stat instanceof AST_If) {
              stat.condition = cons_seq(stat.condition);
            } else if (stat instanceof AST_Switch) {
              stat.expression = cons_seq(stat.expression);
            } else if (stat instanceof AST_With) {
              stat.expression = cons_seq(stat.expression);
            }
          }
          if (compressor2.option("conditionals") && stat instanceof AST_If) {
            var decls = [];
            var body = to_simple_statement(stat.body, decls);
            var alt = to_simple_statement(stat.alternative, decls);
            if (body !== false && alt !== false && decls.length > 0) {
              var len = decls.length;
              decls.push(make_node(AST_If, stat, {
                condition: stat.condition,
                body: body || make_node(AST_EmptyStatement, stat.body),
                alternative: alt
              }));
              decls.unshift(n, 1);
              [].splice.apply(statements2, decls);
              i += len;
              n += len + 1;
              prev = null;
              CHANGED = true;
              continue;
            }
          }
          statements2[n++] = stat;
          prev = stat instanceof AST_SimpleStatement ? stat : null;
        }
        statements2.length = n;
      }
      function extract_exprs(body) {
        if (body instanceof AST_Assign)
          return [body];
        if (body instanceof AST_Sequence)
          return body.expressions.slice();
      }
      function join_assigns(defn, body, keep) {
        var exprs = extract_exprs(body);
        if (!exprs)
          return;
        var trimmed = false;
        for (var i = exprs.length - 1;--i >= 0; ) {
          var expr = exprs[i];
          if (!(expr instanceof AST_Assign))
            continue;
          if (expr.operator != "=")
            continue;
          if (!(expr.left instanceof AST_SymbolRef))
            continue;
          var tail = exprs.slice(i + 1);
          if (!trim_assigns(expr.left, expr.right, tail))
            continue;
          trimmed = true;
          exprs = exprs.slice(0, i + 1).concat(tail);
        }
        if (defn instanceof AST_Definitions) {
          keep = keep || 0;
          for (var i = defn.definitions.length;--i >= 0; ) {
            var def = defn.definitions[i];
            if (!def.value)
              continue;
            if (trim_assigns(def.name, def.value, exprs))
              trimmed = true;
            if (merge_conditional_assignments(def, exprs, keep))
              trimmed = true;
            break;
          }
          if (defn instanceof AST_Var && join_var_assign(defn.definitions, exprs, keep))
            trimmed = true;
        }
        return trimmed && exprs;
      }
      function merge_assigns(prev, defn) {
        if (!(prev instanceof AST_SimpleStatement))
          return;
        if (declarations_only(defn))
          return;
        var exprs = extract_exprs(prev.body);
        if (!exprs)
          return;
        var definitions = [];
        if (!join_var_assign(definitions, exprs.reverse(), 0))
          return;
        defn.definitions = definitions.reverse().concat(defn.definitions);
        return exprs.reverse();
      }
      function merge_conditional_assignments(var_def, exprs, keep) {
        if (!compressor.option("conditionals"))
          return;
        if (var_def.name instanceof AST_Destructured)
          return;
        var trimmed = false;
        var def = var_def.name.definition();
        while (exprs.length > keep) {
          var cond = to_conditional_assignment(compressor, def, var_def.value, exprs[0]);
          if (!cond)
            break;
          var_def.value = cond;
          exprs.shift();
          trimmed = true;
        }
        return trimmed;
      }
      function join_var_assign(definitions, exprs, keep) {
        var trimmed = false;
        while (exprs.length > keep) {
          var expr = exprs[0];
          if (!(expr instanceof AST_Assign))
            break;
          if (expr.operator != "=")
            break;
          var lhs = expr.left;
          if (!(lhs instanceof AST_SymbolRef))
            break;
          if (is_undeclared_ref(lhs))
            break;
          if (lhs.scope.resolve() !== scope)
            break;
          var def = lhs.definition();
          if (def.scope !== scope)
            break;
          if (def.orig.length > def.eliminated + 1)
            break;
          if (def.orig[0].TYPE != "SymbolVar")
            break;
          var name = make_node(AST_SymbolVar, lhs, lhs);
          definitions.push(make_node(AST_VarDef, expr, {
            name,
            value: expr.right
          }));
          def.orig.push(name);
          def.replaced++;
          exprs.shift();
          trimmed = true;
        }
        return trimmed;
      }
      function trim_assigns(name, value, exprs) {
        if (!(value instanceof AST_Object))
          return;
        var trimmed = false;
        do {
          var node = exprs[0];
          if (!(node instanceof AST_Assign))
            break;
          if (node.operator != "=")
            break;
          if (!(node.left instanceof AST_PropAccess))
            break;
          var sym = node.left.expression;
          if (!(sym instanceof AST_SymbolRef))
            break;
          if (name.name != sym.name)
            break;
          if (!node.right.is_constant_expression(scope))
            break;
          var prop = node.left.property;
          if (prop instanceof AST_Node) {
            prop = prop.evaluate(compressor);
          }
          if (prop instanceof AST_Node)
            break;
          prop = "" + prop;
          var diff = prop == "__proto__" || compressor.has_directive("use strict") ? function(node2) {
            var key = node2.key;
            return typeof key == "string" && key != prop && key != "__proto__";
          } : function(node2) {
            var key = node2.key;
            if (node2 instanceof AST_ObjectGetter || node2 instanceof AST_ObjectSetter) {
              return typeof key == "string" && key != prop;
            }
            return key !== "__proto__";
          };
          if (!all(value.properties, diff))
            break;
          value.properties.push(make_node(AST_ObjectKeyVal, node, {
            key: prop,
            value: node.right
          }));
          exprs.shift();
          trimmed = true;
        } while (exprs.length);
        return trimmed;
      }
      function join_consecutive_vars(statements2) {
        var defs;
        for (var i = 0, j2 = -1;i < statements2.length; i++) {
          var stat = statements2[i];
          var prev = statements2[j2];
          if (stat instanceof AST_Definitions) {
            if (prev && prev.TYPE == stat.TYPE) {
              prev.definitions = prev.definitions.concat(stat.definitions);
              CHANGED = true;
            } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {
              defs.definitions = defs.definitions.concat(stat.definitions);
              CHANGED = true;
            } else if (stat instanceof AST_Var) {
              var exprs = merge_assigns(prev, stat);
              if (exprs) {
                if (exprs.length) {
                  prev.body = make_sequence(prev, exprs);
                  j2++;
                }
                CHANGED = true;
              } else {
                j2++;
              }
              statements2[j2] = defs = stat;
            } else {
              statements2[++j2] = stat;
            }
            continue;
          } else if (stat instanceof AST_Exit) {
            stat.value = join_assigns_expr(stat.value);
          } else if (stat instanceof AST_For) {
            var exprs = join_assigns(prev, stat.init);
            if (exprs) {
              CHANGED = true;
              stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;
            } else if (prev instanceof AST_Var && (!stat.init || stat.init.TYPE == prev.TYPE)) {
              if (stat.init) {
                prev.definitions = prev.definitions.concat(stat.init.definitions);
              }
              defs = stat.init = prev;
              statements2[j2] = merge_defns(stat);
              CHANGED = true;
              continue;
            } else if (defs && stat.init && defs.TYPE == stat.init.TYPE && declarations_only(stat.init)) {
              defs.definitions = defs.definitions.concat(stat.init.definitions);
              stat.init = null;
              CHANGED = true;
            } else if (stat.init instanceof AST_Var) {
              defs = stat.init;
              exprs = merge_assigns(prev, stat.init);
              if (exprs) {
                CHANGED = true;
                if (exprs.length == 0) {
                  statements2[j2] = merge_defns(stat);
                  continue;
                }
                prev.body = make_sequence(prev, exprs);
              }
            }
          } else if (stat instanceof AST_ForEnumeration) {
            if (defs && defs.TYPE == stat.init.TYPE) {
              var defns = defs.definitions.slice();
              stat.init = stat.init.definitions[0].name.convert_symbol(AST_SymbolRef, function(ref, name) {
                defns.push(make_node(AST_VarDef, name, {
                  name,
                  value: null
                }));
                name.definition().references.push(ref);
              });
              defs.definitions = defns;
              CHANGED = true;
            }
            stat.object = join_assigns_expr(stat.object);
          } else if (stat instanceof AST_If) {
            stat.condition = join_assigns_expr(stat.condition);
          } else if (stat instanceof AST_SimpleStatement) {
            var exprs = join_assigns(prev, stat.body);
            if (exprs) {
              CHANGED = true;
              if (!exprs.length)
                continue;
              stat.body = make_sequence(stat.body, exprs);
            }
          } else if (stat instanceof AST_Switch) {
            stat.expression = join_assigns_expr(stat.expression);
          } else if (stat instanceof AST_With) {
            stat.expression = join_assigns_expr(stat.expression);
          }
          statements2[++j2] = defs ? merge_defns(stat) : stat;
        }
        statements2.length = j2 + 1;
        function join_assigns_expr(value) {
          var exprs2 = join_assigns(prev, value, 1);
          if (!exprs2)
            return value;
          CHANGED = true;
          var tail = value.tail_node();
          if (exprs2[exprs2.length - 1] !== tail)
            exprs2.push(tail.left);
          return make_sequence(value, exprs2);
        }
        function merge_defns(stat2) {
          return stat2.transform(new TreeTransformer(function(node, descend, in_list) {
            if (node instanceof AST_Definitions) {
              if (defs === node)
                return node;
              if (defs.TYPE != node.TYPE)
                return node;
              var parent = this.parent();
              if (parent instanceof AST_ForEnumeration && parent.init === node)
                return node;
              if (!declarations_only(node))
                return node;
              defs.definitions = defs.definitions.concat(node.definitions);
              CHANGED = true;
              if (parent instanceof AST_For && parent.init === node)
                return null;
              return in_list ? List.skip : make_node(AST_EmptyStatement, node);
            }
            if (node instanceof AST_ExportDeclaration)
              return node;
            if (node instanceof AST_Scope)
              return node;
            if (!is_statement(node))
              return node;
          }));
        }
      }
    }
    function extract_declarations_from_unreachable_code(compressor, stat, target) {
      var block;
      var dropped = false;
      stat.walk(new TreeWalker(function(node, descend) {
        if (node instanceof AST_DefClass) {
          node.extends = null;
          node.properties = [];
          push(node);
          return true;
        }
        if (node instanceof AST_Definitions) {
          var defns = [];
          if (node.remove_initializers(compressor, defns)) {
            AST_Node.warn("Dropping initialization in unreachable code [{file}:{line},{col}]", node.start);
          }
          if (defns.length > 0) {
            node.definitions = defns;
            push(node);
          }
          return true;
        }
        if (node instanceof AST_LambdaDefinition) {
          push(node);
          return true;
        }
        if (node instanceof AST_Scope)
          return true;
        if (node instanceof AST_BlockScope) {
          var save = block;
          block = [];
          descend();
          if (block.required) {
            target.push(make_node(AST_BlockStatement, stat, { body: block }));
          } else if (block.length) {
            [].push.apply(target, block);
          }
          block = save;
          return true;
        }
        if (!(node instanceof AST_LoopControl))
          dropped = true;
      }));
      if (dropped)
        AST_Node.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
      function push(node) {
        if (block) {
          block.push(node);
          if (!safe_to_trim(node))
            block.required = true;
        } else {
          target.push(node);
        }
      }
    }
    function is_undefined(node, compressor) {
      return node.is_undefined || node instanceof AST_Undefined || node instanceof AST_UnaryPrefix && node.operator == "void" && !(compressor && node.expression.has_side_effects(compressor));
    }
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Array, return_true);
      def(AST_Assign, function() {
        return this.operator == "=" && this.right.is_truthy();
      });
      def(AST_Lambda, return_true);
      def(AST_Object, return_true);
      def(AST_RegExp, return_true);
      def(AST_Sequence, function() {
        return this.tail_node().is_truthy();
      });
      def(AST_SymbolRef, function() {
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_truthy = return_false;
        var result = fixed.is_truthy();
        delete this.is_truthy;
        return result;
      });
    })(function(node, func) {
      node.DEFMETHOD("is_truthy", func);
    });
    (function(def) {
      def(AST_Node, return_true);
      def(AST_Array, return_false);
      function binary(op, left, right) {
        switch (op) {
          case "-":
            return left.is_negative_zero() && (!(right instanceof AST_Constant) || right.value == 0);
          case "&&":
          case "||":
            return left.is_negative_zero() || right.is_negative_zero();
          case "*":
          case "/":
          case "%":
          case "**":
            return true;
          default:
            return false;
        }
      }
      def(AST_Assign, function() {
        var op = this.operator;
        if (op == "=")
          return this.right.is_negative_zero();
        return binary(op.slice(0, -1), this.left, this.right);
      });
      def(AST_Binary, function() {
        return binary(this.operator, this.left, this.right);
      });
      def(AST_Constant, function() {
        return this.value == 0 && 1 / this.value < 0;
      });
      def(AST_Lambda, return_false);
      def(AST_Object, return_false);
      def(AST_RegExp, return_false);
      def(AST_Sequence, function() {
        return this.tail_node().is_negative_zero();
      });
      def(AST_SymbolRef, function() {
        var fixed = this.fixed_value();
        if (!fixed)
          return true;
        this.is_negative_zero = return_true;
        var result = fixed.is_negative_zero();
        delete this.is_negative_zero;
        return result;
      });
      def(AST_UnaryPrefix, function() {
        return this.operator == "+" && this.expression.is_negative_zero() || this.operator == "-";
      });
    })(function(node, func) {
      node.DEFMETHOD("is_negative_zero", func);
    });
    (function(def) {
      AST_Node.DEFMETHOD("may_throw_on_access", function(compressor, force) {
        return !compressor.option("pure_getters") || this._dot_throw(compressor, force);
      });
      function is_strict(compressor, force) {
        return force || /strict/.test(compressor.option("pure_getters"));
      }
      def(AST_Node, is_strict);
      def(AST_Array, return_false);
      def(AST_Assign, function(compressor) {
        var op = this.operator;
        var sym = this.left;
        var rhs = this.right;
        if (op != "=") {
          return lazy_op[op.slice(0, -1)] && (sym._dot_throw(compressor) || rhs._dot_throw(compressor));
        }
        if (!rhs._dot_throw(compressor))
          return false;
        if (!(sym instanceof AST_SymbolRef))
          return true;
        if (rhs instanceof AST_Binary && rhs.operator == "||" && sym.name == rhs.left.name) {
          return rhs.right._dot_throw(compressor);
        }
        return true;
      });
      def(AST_Binary, function(compressor) {
        return lazy_op[this.operator] && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));
      });
      def(AST_Class, return_false);
      def(AST_Conditional, function(compressor) {
        return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);
      });
      def(AST_Constant, return_false);
      def(AST_Dot, function(compressor, force) {
        if (!is_strict(compressor, force))
          return false;
        var exp = this.expression;
        if (exp instanceof AST_SymbolRef)
          exp = exp.fixed_value();
        return !(this.property == "prototype" && is_lambda(exp));
      });
      def(AST_Lambda, return_false);
      def(AST_Null, return_true);
      def(AST_Object, function(compressor, force) {
        return is_strict(compressor, force) && !all(this.properties, function(prop) {
          if (!(prop instanceof AST_ObjectKeyVal))
            return false;
          return !(prop.key === "__proto__" && prop.value._dot_throw(compressor, force));
        });
      });
      def(AST_ObjectIdentity, function(compressor, force) {
        return is_strict(compressor, force) && !this.scope.resolve().new;
      });
      def(AST_Sequence, function(compressor) {
        return this.tail_node()._dot_throw(compressor);
      });
      def(AST_SymbolRef, function(compressor, force) {
        if (this.is_undefined)
          return true;
        if (!is_strict(compressor, force))
          return false;
        if (is_undeclared_ref(this) && this.is_declared(compressor))
          return false;
        if (this.is_immutable())
          return false;
        var def2 = this.definition();
        if (is_arguments(def2) && !def2.scope.rest && all(def2.scope.argnames, function(argname) {
          return argname instanceof AST_SymbolFunarg;
        }))
          return def2.scope.uses_arguments > 2;
        var fixed = this.fixed_value();
        if (!fixed)
          return true;
        this._dot_throw = return_true;
        if (fixed._dot_throw(compressor)) {
          delete this._dot_throw;
          return true;
        }
        this._dot_throw = return_false;
        return false;
      });
      def(AST_UnaryPrefix, function() {
        return this.operator == "void";
      });
      def(AST_UnaryPostfix, return_false);
      def(AST_Undefined, return_true);
    })(function(node, func) {
      node.DEFMETHOD("_dot_throw", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Array, return_true);
      function is_binary_defined(compressor, op, node) {
        switch (op) {
          case "&&":
            return node.left.is_defined(compressor) && node.right.is_defined(compressor);
          case "||":
            return node.left.is_truthy() || node.right.is_defined(compressor);
          case "??":
            return node.left.is_defined(compressor) || node.right.is_defined(compressor);
          default:
            return true;
        }
      }
      def(AST_Assign, function(compressor) {
        var op = this.operator;
        if (op == "=")
          return this.right.is_defined(compressor);
        return is_binary_defined(compressor, op.slice(0, -1), this);
      });
      def(AST_Binary, function(compressor) {
        return is_binary_defined(compressor, this.operator, this);
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent.is_defined(compressor) && this.alternative.is_defined(compressor);
      });
      def(AST_Constant, return_true);
      def(AST_Hole, return_false);
      def(AST_Lambda, return_true);
      def(AST_Object, return_true);
      def(AST_Sequence, function(compressor) {
        return this.tail_node().is_defined(compressor);
      });
      def(AST_SymbolRef, function(compressor) {
        if (this.is_undefined)
          return false;
        if (is_undeclared_ref(this) && this.is_declared(compressor))
          return true;
        if (this.is_immutable())
          return true;
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_defined = return_false;
        var result = fixed.is_defined(compressor);
        delete this.is_defined;
        return result;
      });
      def(AST_UnaryPrefix, function() {
        return this.operator != "void";
      });
      def(AST_UnaryPostfix, return_true);
      def(AST_Undefined, return_false);
    })(function(node, func) {
      node.DEFMETHOD("is_defined", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Assign, function(compressor) {
        return this.operator == "=" && this.right.is_boolean(compressor);
      });
      var binary = makePredicate("in instanceof == != === !== < <= >= >");
      def(AST_Binary, function(compressor) {
        return binary[this.operator] || lazy_op[this.operator] && this.left.is_boolean(compressor) && this.right.is_boolean(compressor);
      });
      def(AST_Boolean, return_true);
      var fn = makePredicate("every hasOwnProperty isPrototypeOf propertyIsEnumerable some");
      def(AST_Call, function(compressor) {
        if (!compressor.option("unsafe"))
          return false;
        var exp = this.expression;
        return exp instanceof AST_Dot && (fn[exp.property] || exp.property == "test" && exp.expression instanceof AST_RegExp);
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent.is_boolean(compressor) && this.alternative.is_boolean(compressor);
      });
      def(AST_New, return_false);
      def(AST_Sequence, function(compressor) {
        return this.tail_node().is_boolean(compressor);
      });
      def(AST_SymbolRef, function(compressor) {
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_boolean = return_false;
        var result = fixed.is_boolean(compressor);
        delete this.is_boolean;
        return result;
      });
      var unary = makePredicate("! delete");
      def(AST_UnaryPrefix, function() {
        return unary[this.operator];
      });
    })(function(node, func) {
      node.DEFMETHOD("is_boolean", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      var binary = makePredicate("- * / % ** & | ^ << >> >>>");
      def(AST_Assign, function(compressor) {
        return binary[this.operator.slice(0, -1)] || this.operator == "=" && this.right.is_number(compressor);
      });
      def(AST_Binary, function(compressor) {
        if (binary[this.operator])
          return true;
        if (this.operator != "+")
          return false;
        return (this.left.is_boolean(compressor) || this.left.is_number(compressor)) && (this.right.is_boolean(compressor) || this.right.is_number(compressor));
      });
      var fn = makePredicate([
        "charCodeAt",
        "getDate",
        "getDay",
        "getFullYear",
        "getHours",
        "getMilliseconds",
        "getMinutes",
        "getMonth",
        "getSeconds",
        "getTime",
        "getTimezoneOffset",
        "getUTCDate",
        "getUTCDay",
        "getUTCFullYear",
        "getUTCHours",
        "getUTCMilliseconds",
        "getUTCMinutes",
        "getUTCMonth",
        "getUTCSeconds",
        "getYear",
        "indexOf",
        "lastIndexOf",
        "localeCompare",
        "push",
        "search",
        "setDate",
        "setFullYear",
        "setHours",
        "setMilliseconds",
        "setMinutes",
        "setMonth",
        "setSeconds",
        "setTime",
        "setUTCDate",
        "setUTCFullYear",
        "setUTCHours",
        "setUTCMilliseconds",
        "setUTCMinutes",
        "setUTCMonth",
        "setUTCSeconds",
        "setYear",
        "toExponential",
        "toFixed",
        "toPrecision"
      ]);
      def(AST_Call, function(compressor) {
        if (!compressor.option("unsafe"))
          return false;
        var exp = this.expression;
        return exp instanceof AST_Dot && (fn[exp.property] || is_undeclared_ref(exp.expression) && exp.expression.name == "Math");
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);
      });
      def(AST_New, return_false);
      def(AST_Number, return_true);
      def(AST_Sequence, function(compressor) {
        return this.tail_node().is_number(compressor);
      });
      def(AST_SymbolRef, function(compressor) {
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_number = return_false;
        var result = fixed.is_number(compressor);
        delete this.is_number;
        return result;
      });
      var unary = makePredicate("+ - ~ ++ --");
      def(AST_Unary, function() {
        return unary[this.operator];
      });
    })(function(node, func) {
      node.DEFMETHOD("is_number", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Assign, function(compressor) {
        switch (this.operator) {
          case "+=":
            if (this.left.is_string(compressor))
              return true;
          case "=":
            return this.right.is_string(compressor);
        }
      });
      def(AST_Binary, function(compressor) {
        return this.operator == "+" && (this.left.is_string(compressor) || this.right.is_string(compressor));
      });
      var fn = makePredicate([
        "charAt",
        "substr",
        "substring",
        "toLowerCase",
        "toString",
        "toUpperCase",
        "trim"
      ]);
      def(AST_Call, function(compressor) {
        if (!compressor.option("unsafe"))
          return false;
        var exp = this.expression;
        return exp instanceof AST_Dot && fn[exp.property];
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
      });
      def(AST_Sequence, function(compressor) {
        return this.tail_node().is_string(compressor);
      });
      def(AST_String, return_true);
      def(AST_SymbolRef, function(compressor) {
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_string = return_false;
        var result = fixed.is_string(compressor);
        delete this.is_string;
        return result;
      });
      def(AST_Template, function(compressor) {
        return !this.tag || is_raw_tag(compressor, this.tag);
      });
      def(AST_UnaryPrefix, function() {
        return this.operator == "typeof";
      });
    })(function(node, func) {
      node.DEFMETHOD("is_string", func);
    });
    var lazy_op = makePredicate("&& || ??");
    (function(def) {
      function to_node(value, orig) {
        if (value instanceof AST_Node)
          return value.clone(true);
        if (Array.isArray(value))
          return make_node(AST_Array, orig, {
            elements: value.map(function(value2) {
              return to_node(value2, orig);
            })
          });
        if (value && typeof value == "object") {
          var props = [];
          for (var key in value)
            if (HOP(value, key)) {
              props.push(make_node(AST_ObjectKeyVal, orig, {
                key,
                value: to_node(value[key], orig)
              }));
            }
          return make_node(AST_Object, orig, {
            properties: props
          });
        }
        return make_node_from_constant(value, orig);
      }
      function warn(node) {
        AST_Node.warn("global_defs {node} redefined [{file}:{line},{col}]", {
          node,
          file: node.start.file,
          line: node.start.line,
          col: node.start.col
        });
      }
      AST_Toplevel.DEFMETHOD("resolve_defines", function(compressor) {
        if (!compressor.option("global_defs"))
          return this;
        this.figure_out_scope({ ie: compressor.option("ie") });
        return this.transform(new TreeTransformer(function(node) {
          var def2 = node._find_defs(compressor, "");
          if (!def2)
            return;
          var level = 0, child = node, parent;
          while (parent = this.parent(level++)) {
            if (!(parent instanceof AST_PropAccess))
              break;
            if (parent.expression !== child)
              break;
            child = parent;
          }
          if (is_lhs(child, parent)) {
            warn(node);
            return;
          }
          return def2;
        }));
      });
      def(AST_Node, noop);
      def(AST_Dot, function(compressor, suffix) {
        return this.expression._find_defs(compressor, "." + this.property + suffix);
      });
      def(AST_SymbolDeclaration, function(compressor) {
        if (!this.definition().global)
          return;
        if (HOP(compressor.option("global_defs"), this.name))
          warn(this);
      });
      def(AST_SymbolRef, function(compressor, suffix) {
        if (!this.definition().global)
          return;
        var defines = compressor.option("global_defs");
        var name = this.name + suffix;
        if (HOP(defines, name))
          return to_node(defines[name], this);
      });
    })(function(node, func) {
      node.DEFMETHOD("_find_defs", func);
    });
    function best_of_expression(ast1, ast2, threshold) {
      var delta = ast2.print_to_string().length - ast1.print_to_string().length;
      return delta < (threshold || 0) ? ast2 : ast1;
    }
    function best_of_statement(ast1, ast2, threshold) {
      return best_of_expression(make_node(AST_SimpleStatement, ast1, {
        body: ast1
      }), make_node(AST_SimpleStatement, ast2, {
        body: ast2
      }), threshold).body;
    }
    function best_of(compressor, ast1, ast2, threshold) {
      return (first_in_statement(compressor) ? best_of_statement : best_of_expression)(ast1, ast2, threshold);
    }
    function convert_to_predicate(obj) {
      var map = Object.create(null);
      Object.keys(obj).forEach(function(key) {
        map[key] = makePredicate(obj[key]);
      });
      return map;
    }
    function skip_directives(body) {
      for (var i = 0;i < body.length; i++) {
        var stat = body[i];
        if (!(stat instanceof AST_Directive))
          return stat;
      }
    }
    function arrow_first_statement() {
      if (this.value)
        return make_node(AST_Return, this.value, {
          value: this.value
        });
      return skip_directives(this.body);
    }
    AST_Arrow.DEFMETHOD("first_statement", arrow_first_statement);
    AST_AsyncArrow.DEFMETHOD("first_statement", arrow_first_statement);
    AST_Lambda.DEFMETHOD("first_statement", function() {
      return skip_directives(this.body);
    });
    AST_Lambda.DEFMETHOD("length", function() {
      var argnames = this.argnames;
      for (var i = 0;i < argnames.length; i++) {
        if (argnames[i] instanceof AST_DefaultValue)
          break;
      }
      return i;
    });
    function try_evaluate(compressor, node) {
      var ev = node.evaluate(compressor);
      if (ev === node)
        return node;
      ev = make_node_from_constant(ev, node).optimize(compressor);
      return best_of(compressor, node, ev, compressor.eval_threshold);
    }
    var object_fns = [
      "constructor",
      "toString",
      "valueOf"
    ];
    var native_fns = convert_to_predicate({
      Array: [
        "indexOf",
        "join",
        "lastIndexOf",
        "slice"
      ].concat(object_fns),
      Boolean: object_fns,
      Function: object_fns,
      Number: [
        "toExponential",
        "toFixed",
        "toPrecision"
      ].concat(object_fns),
      Object: object_fns,
      RegExp: [
        "exec",
        "test"
      ].concat(object_fns),
      String: [
        "charAt",
        "charCodeAt",
        "concat",
        "indexOf",
        "italics",
        "lastIndexOf",
        "match",
        "replace",
        "search",
        "slice",
        "split",
        "substr",
        "substring",
        "toLowerCase",
        "toUpperCase",
        "trim"
      ].concat(object_fns)
    });
    var static_fns = convert_to_predicate({
      Array: [
        "isArray"
      ],
      Math: [
        "abs",
        "acos",
        "asin",
        "atan",
        "ceil",
        "cos",
        "exp",
        "floor",
        "log",
        "round",
        "sin",
        "sqrt",
        "tan",
        "atan2",
        "pow",
        "max",
        "min"
      ],
      Number: [
        "isFinite",
        "isNaN"
      ],
      Object: [
        "create",
        "getOwnPropertyDescriptor",
        "getOwnPropertyNames",
        "getPrototypeOf",
        "isExtensible",
        "isFrozen",
        "isSealed",
        "keys"
      ],
      String: [
        "fromCharCode",
        "raw"
      ]
    });
    function is_static_fn(node) {
      if (!(node instanceof AST_Dot))
        return false;
      var expr = node.expression;
      if (!is_undeclared_ref(expr))
        return false;
      var static_fn = static_fns[expr.name];
      return static_fn && (static_fn[node.property] || expr.name == "Math" && node.property == "random");
    }
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Constant, return_true);
      def(AST_RegExp, return_false);
      var unaryPrefix = makePredicate("! ~ - + void");
      def(AST_UnaryPrefix, function() {
        return unaryPrefix[this.operator] && this.expression instanceof AST_Constant;
      });
    })(function(node, func) {
      node.DEFMETHOD("is_constant", func);
    });
    (function(def) {
      AST_Node.DEFMETHOD("evaluate", function(compressor, ignore_side_effects) {
        if (!compressor.option("evaluate"))
          return this;
        var cached = [];
        var val = this._eval(compressor, ignore_side_effects, cached, 1);
        cached.forEach(function(node) {
          delete node._eval;
        });
        if (ignore_side_effects)
          return val;
        if (!val || val instanceof RegExp)
          return val;
        if (typeof val == "function" || typeof val == "object")
          return this;
        return val;
      });
      var scan_modified = new TreeWalker(function(node) {
        if (node instanceof AST_Assign)
          modified(node.left);
        if (node instanceof AST_Unary && UNARY_POSTFIX[node.operator])
          modified(node.expression);
      });
      function modified(node) {
        if (node instanceof AST_DestructuredArray) {
          node.elements.forEach(modified);
        } else if (node instanceof AST_DestructuredObject) {
          node.properties.forEach(function(prop) {
            modified(prop.value);
          });
        } else if (node instanceof AST_PropAccess) {
          modified(node.expression);
        } else if (node instanceof AST_SymbolRef) {
          node.definition().references.forEach(function(ref) {
            delete ref._eval;
          });
        }
      }
      def(AST_Statement, function() {
        throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
      });
      def(AST_Accessor, return_this);
      def(AST_BigInt, return_this);
      def(AST_Class, return_this);
      def(AST_Node, return_this);
      def(AST_Constant, function() {
        return this.value;
      });
      def(AST_Assign, function(compressor, ignore_side_effects, cached, depth) {
        var lhs = this.left;
        if (!ignore_side_effects) {
          if (!(lhs instanceof AST_SymbolRef))
            return this;
          if (!HOP(lhs, "_eval")) {
            if (!lhs.fixed)
              return this;
            var def2 = lhs.definition();
            if (!def2.fixed)
              return this;
            if (def2.undeclared)
              return this;
            if (def2.last_ref !== lhs)
              return this;
            if (def2.single_use == "m")
              return this;
          }
        }
        var op = this.operator;
        var node;
        if (!HOP(lhs, "_eval") && lhs instanceof AST_SymbolRef && lhs.fixed && lhs.definition().fixed) {
          node = lhs;
        } else if (op == "=") {
          node = this.right;
        } else {
          node = make_node(AST_Binary, this, {
            operator: op.slice(0, -1),
            left: lhs,
            right: this.right
          });
        }
        lhs.walk(scan_modified);
        var value = node._eval(compressor, ignore_side_effects, cached, depth);
        if (typeof value == "object")
          return this;
        modified(lhs);
        return value;
      });
      def(AST_Sequence, function(compressor, ignore_side_effects, cached, depth) {
        if (!ignore_side_effects)
          return this;
        var exprs = this.expressions;
        for (var i = 0, last = exprs.length - 1;i < last; i++) {
          exprs[i].walk(scan_modified);
        }
        var tail = exprs[last];
        var value = tail._eval(compressor, ignore_side_effects, cached, depth);
        return value === tail ? this : value;
      });
      def(AST_Lambda, function(compressor) {
        if (compressor.option("unsafe")) {
          var fn = function() {
          };
          fn.node = this;
          fn.toString = function() {
            return "function(){}";
          };
          return fn;
        }
        return this;
      });
      def(AST_Array, function(compressor, ignore_side_effects, cached, depth) {
        if (compressor.option("unsafe")) {
          var elements = [];
          for (var i = 0;i < this.elements.length; i++) {
            var element = this.elements[i];
            if (element instanceof AST_Hole)
              return this;
            var value = element._eval(compressor, ignore_side_effects, cached, depth);
            if (element === value)
              return this;
            elements.push(value);
          }
          return elements;
        }
        return this;
      });
      var nonsafe_props = makePredicate("__proto__ toString valueOf");
      def(AST_Object, function(compressor, ignore_side_effects, cached, depth) {
        if (compressor.option("unsafe")) {
          var val = {};
          for (var i = 0;i < this.properties.length; i++) {
            var prop = this.properties[i];
            if (!(prop instanceof AST_ObjectKeyVal))
              return this;
            var key = prop.key;
            if (key instanceof AST_Node) {
              key = key._eval(compressor, ignore_side_effects, cached, depth);
              if (key === prop.key)
                return this;
            }
            if (nonsafe_props[key])
              return this;
            val[key] = prop.value._eval(compressor, ignore_side_effects, cached, depth);
            if (val[key] === prop.value)
              return this;
          }
          return val;
        }
        return this;
      });
      var non_converting_unary = makePredicate("! typeof void");
      def(AST_UnaryPrefix, function(compressor, ignore_side_effects, cached, depth) {
        var e = this.expression;
        var op = this.operator;
        if (compressor.option("typeofs") && op == "typeof" && (e instanceof AST_Lambda || e instanceof AST_SymbolRef && e.fixed_value() instanceof AST_Lambda)) {
          return "function";
        }
        var def2 = e instanceof AST_SymbolRef && e.definition();
        if (!non_converting_unary[op] && !(def2 && def2.fixed))
          depth++;
        e.walk(scan_modified);
        var v = e._eval(compressor, ignore_side_effects, cached, depth);
        if (v === e) {
          if (ignore_side_effects && op == "void")
            return;
          return this;
        }
        switch (op) {
          case "!":
            return !v;
          case "typeof":
            if (v instanceof RegExp)
              return this;
            return typeof v;
          case "void":
            return;
          case "~":
            return ~v;
          case "-":
            return -v;
          case "+":
            return +v;
          case "++":
          case "--":
            if (!def2)
              return this;
            if (!ignore_side_effects) {
              if (def2.undeclared)
                return this;
              if (def2.last_ref !== e)
                return this;
            }
            if (HOP(e, "_eval"))
              v = +(op[0] + 1) + +v;
            modified(e);
            return v;
        }
        return this;
      });
      def(AST_UnaryPostfix, function(compressor, ignore_side_effects, cached, depth) {
        var e = this.expression;
        if (!(e instanceof AST_SymbolRef)) {
          if (!ignore_side_effects)
            return this;
        } else if (!HOP(e, "_eval")) {
          if (!e.fixed)
            return this;
          if (!ignore_side_effects) {
            var def2 = e.definition();
            if (!def2.fixed)
              return this;
            if (def2.undeclared)
              return this;
            if (def2.last_ref !== e)
              return this;
          }
        }
        if (!(e instanceof AST_SymbolRef && e.definition().fixed))
          depth++;
        e.walk(scan_modified);
        var v = e._eval(compressor, ignore_side_effects, cached, depth);
        if (v === e)
          return this;
        modified(e);
        return +v;
      });
      var non_converting_binary = makePredicate("&& || === !==");
      def(AST_Binary, function(compressor, ignore_side_effects, cached, depth) {
        if (!non_converting_binary[this.operator])
          depth++;
        var left = this.left._eval(compressor, ignore_side_effects, cached, depth);
        if (left === this.left)
          return this;
        if (this.operator == (left ? "||" : "&&"))
          return left;
        var rhs_ignore_side_effects = ignore_side_effects && !(left && typeof left == "object");
        var right = this.right._eval(compressor, rhs_ignore_side_effects, cached, depth);
        if (right === this.right)
          return this;
        var result;
        switch (this.operator) {
          case "&&":
            result = left && right;
            break;
          case "||":
            result = left || right;
            break;
          case "??":
            result = left == null ? right : left;
            break;
          case "|":
            result = left | right;
            break;
          case "&":
            result = left & right;
            break;
          case "^":
            result = left ^ right;
            break;
          case "+":
            result = left + right;
            break;
          case "-":
            result = left - right;
            break;
          case "*":
            result = left * right;
            break;
          case "/":
            result = left / right;
            break;
          case "%":
            result = left % right;
            break;
          case "<<":
            result = left << right;
            break;
          case ">>":
            result = left >> right;
            break;
          case ">>>":
            result = left >>> right;
            break;
          case "==":
            result = left == right;
            break;
          case "===":
            result = left === right;
            break;
          case "!=":
            result = left != right;
            break;
          case "!==":
            result = left !== right;
            break;
          case "<":
            result = left < right;
            break;
          case "<=":
            result = left <= right;
            break;
          case ">":
            result = left > right;
            break;
          case ">=":
            result = left >= right;
            break;
          case "**":
            result = Math.pow(left, right);
            break;
          case "in":
            if (right && typeof right == "object" && HOP(right, left)) {
              result = true;
              break;
            }
          default:
            return this;
        }
        if (isNaN(result))
          return compressor.find_parent(AST_With) ? this : result;
        if (compressor.option("unsafe_math") && !ignore_side_effects && result && typeof result == "number" && (this.operator == "+" || this.operator == "-")) {
          var digits = Math.max(0, decimals(left), decimals(right));
          if (digits < 16)
            return +result.toFixed(digits);
        }
        return result;
        function decimals(operand) {
          var match = /(\.[0-9]*)?(e.+)?$/.exec(+operand);
          return (match[1] || ".").length - 1 - (match[2] || "").slice(1);
        }
      });
      def(AST_Conditional, function(compressor, ignore_side_effects, cached, depth) {
        var condition = this.condition._eval(compressor, ignore_side_effects, cached, depth);
        if (condition === this.condition)
          return this;
        var node = condition ? this.consequent : this.alternative;
        var value = node._eval(compressor, ignore_side_effects, cached, depth);
        return value === node ? this : value;
      });
      function verify_escaped(ref, depth) {
        var escaped = ref.definition().escaped;
        switch (escaped.length) {
          case 0:
            return true;
          case 1:
            var found = false;
            escaped[0].walk(new TreeWalker(function(node) {
              if (found)
                return true;
              if (node === ref)
                return found = true;
              if (node instanceof AST_Scope)
                return true;
            }));
            return found;
          default:
            return depth <= escaped.depth;
        }
      }
      def(AST_SymbolRef, function(compressor, ignore_side_effects, cached, depth) {
        var fixed = this.fixed_value();
        if (!fixed)
          return this;
        var value;
        if (HOP(fixed, "_eval")) {
          value = fixed._eval();
        } else {
          this._eval = return_this;
          value = fixed._eval(compressor, ignore_side_effects, cached, depth);
          delete this._eval;
          if (value === fixed)
            return this;
          fixed._eval = function() {
            return value;
          };
          cached.push(fixed);
        }
        return value && typeof value == "object" && !verify_escaped(this, depth) ? this : value;
      });
      var global_objs = {
        Array,
        Math,
        Number,
        Object,
        String
      };
      var static_values = convert_to_predicate({
        Math: [
          "E",
          "LN10",
          "LN2",
          "LOG2E",
          "LOG10E",
          "PI",
          "SQRT1_2",
          "SQRT2"
        ],
        Number: [
          "MAX_VALUE",
          "MIN_VALUE",
          "NaN",
          "NEGATIVE_INFINITY",
          "POSITIVE_INFINITY"
        ]
      });
      var regexp_props = makePredicate("global ignoreCase multiline source");
      def(AST_PropAccess, function(compressor, ignore_side_effects, cached, depth) {
        if (compressor.option("unsafe")) {
          var val;
          var exp = this.expression;
          if (!is_undeclared_ref(exp)) {
            val = exp._eval(compressor, ignore_side_effects, cached, depth + 1);
            if (val == null || val === exp)
              return this;
          }
          var key = this.property;
          if (key instanceof AST_Node) {
            key = key._eval(compressor, ignore_side_effects, cached, depth);
            if (key === this.property)
              return this;
          }
          if (val === undefined) {
            var static_value = static_values[exp.name];
            if (!static_value || !static_value[key])
              return this;
            val = global_objs[exp.name];
          } else if (val instanceof RegExp) {
            if (!regexp_props[key])
              return this;
          } else if (typeof val == "object") {
            if (!HOP(val, key))
              return this;
          } else if (typeof val == "function")
            switch (key) {
              case "name":
                return val.node.name ? val.node.name.name : "";
              case "length":
                return val.node.length();
              default:
                return this;
            }
          return val[key];
        }
        return this;
      });
      function eval_all(nodes, compressor, ignore_side_effects, cached, depth) {
        var values = [];
        for (var i = 0;i < nodes.length; i++) {
          var node = nodes[i];
          var value = node._eval(compressor, ignore_side_effects, cached, depth);
          if (node === value)
            return;
          values.push(value);
        }
        return values;
      }
      def(AST_Call, function(compressor, ignore_side_effects, cached, depth) {
        var exp = this.expression;
        var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;
        if (fn instanceof AST_Arrow || fn instanceof AST_Defun || fn instanceof AST_Function) {
          if (fn.evaluating)
            return this;
          if (fn.name && fn.name.definition().recursive_refs > 0)
            return this;
          if (this.is_expr_pure(compressor))
            return this;
          var args = eval_all(this.args, compressor, ignore_side_effects, cached, depth);
          if (!all(fn.argnames, function(sym, index) {
            if (sym instanceof AST_DefaultValue) {
              if (!args)
                return false;
              if (args[index] !== undefined)
                return false;
              var value = sym.value._eval(compressor, ignore_side_effects, cached, depth);
              if (value === sym.value)
                return false;
              args[index] = value;
              sym = sym.name;
            }
            return !(sym instanceof AST_Destructured);
          }))
            return this;
          if (fn.rest instanceof AST_Destructured)
            return this;
          if (!args && !ignore_side_effects)
            return this;
          var stat = fn.first_statement();
          if (!(stat instanceof AST_Return)) {
            if (ignore_side_effects) {
              fn.walk(scan_modified);
              var found = false;
              fn.evaluating = true;
              walk_body(fn, new TreeWalker(function(node) {
                if (found)
                  return true;
                if (node instanceof AST_Return) {
                  if (node.value && node.value._eval(compressor, true, cached, depth) !== undefined) {
                    found = true;
                  }
                  return true;
                }
                if (node instanceof AST_Scope && node !== fn)
                  return true;
              }));
              delete fn.evaluating;
              if (!found)
                return;
            }
            return this;
          }
          var val = stat.value;
          if (!val)
            return;
          var cached_args = [];
          if (!args || all(fn.argnames, function(sym, i) {
            return assign(sym, args[i]);
          }) && !(fn.rest && !assign(fn.rest, args.slice(fn.argnames.length))) || ignore_side_effects) {
            fn.evaluating = true;
            val = val._eval(compressor, ignore_side_effects, cached, depth);
            delete fn.evaluating;
          }
          cached_args.forEach(function(node) {
            delete node._eval;
          });
          return val === stat.value ? this : val;
        } else if (compressor.option("unsafe") && exp instanceof AST_PropAccess) {
          var key = exp.property;
          if (key instanceof AST_Node) {
            key = key._eval(compressor, ignore_side_effects, cached, depth);
            if (key === exp.property)
              return this;
          }
          var val;
          var e = exp.expression;
          if (is_undeclared_ref(e)) {
            var static_fn = static_fns[e.name];
            if (!static_fn || !static_fn[key])
              return this;
            val = global_objs[e.name];
          } else {
            val = e._eval(compressor, ignore_side_effects, cached, depth + 1);
            if (val == null || val === e)
              return this;
            var native_fn = native_fns[val.constructor.name];
            if (!native_fn || !native_fn[key])
              return this;
            if (val instanceof RegExp && val.global && !(e instanceof AST_RegExp))
              return this;
          }
          var args = eval_all(this.args, compressor, ignore_side_effects, cached, depth);
          if (!args)
            return this;
          if (key == "replace" && typeof args[1] == "function")
            return this;
          try {
            return val[key].apply(val, args);
          } catch (ex) {
            AST_Node.warn("Error evaluating {code} [{file}:{line},{col}]", {
              code: this,
              file: this.start.file,
              line: this.start.line,
              col: this.start.col
            });
          } finally {
            if (val instanceof RegExp)
              val.lastIndex = 0;
          }
        }
        return this;
        function assign(sym, arg) {
          if (sym instanceof AST_DefaultValue)
            sym = sym.name;
          var def2 = sym.definition();
          if (def2.orig[def2.orig.length - 1] !== sym)
            return false;
          var value = arg;
          def2.references.forEach(function(node) {
            node._eval = function() {
              return value;
            };
            cached_args.push(node);
          });
          return true;
        }
      });
      def(AST_New, return_this);
      def(AST_Template, function(compressor, ignore_side_effects, cached, depth) {
        if (!compressor.option("templates"))
          return this;
        if (this.tag) {
          if (!is_raw_tag(compressor, this.tag))
            return this;
          decode = function(str) {
            return str;
          };
        }
        var exprs = eval_all(this.expressions, compressor, ignore_side_effects, cached, depth);
        if (!exprs)
          return this;
        var malformed = false;
        var ret = decode(this.strings[0]);
        for (var i = 0;i < exprs.length; i++) {
          ret += exprs[i] + decode(this.strings[i + 1]);
        }
        if (!malformed)
          return ret;
        this._eval = return_this;
        return this;
        function decode(str) {
          return str.replace(/\\(u\{[^}]*\}?|u[\s\S]{0,4}|x[\s\S]{0,2}|[0-9]+|[\s\S])/g, function(match, seq) {
            var s2 = decode_escape_sequence(seq);
            if (typeof s2 != "string")
              malformed = true;
            return s2;
          });
        }
      });
    })(function(node, func) {
      node.DEFMETHOD("_eval", func);
    });
    (function(def) {
      function basic_negation(exp) {
        return make_node(AST_UnaryPrefix, exp, {
          operator: "!",
          expression: exp
        });
      }
      function best(orig, alt, first_in_statement2) {
        var negated = basic_negation(orig);
        if (first_in_statement2) {
          var stat = make_node(AST_SimpleStatement, alt, {
            body: alt
          });
          return best_of_expression(negated, stat) === stat ? alt : negated;
        }
        return best_of_expression(negated, alt);
      }
      def(AST_Node, function() {
        return basic_negation(this);
      });
      def(AST_Statement, function() {
        throw new Error("Cannot negate a statement");
      });
      def(AST_Binary, function(compressor, first_in_statement2) {
        var self = this.clone(), op = this.operator;
        if (compressor.option("unsafe_comps")) {
          switch (op) {
            case "<=":
              self.operator = ">";
              return self;
            case "<":
              self.operator = ">=";
              return self;
            case ">=":
              self.operator = "<";
              return self;
            case ">":
              self.operator = "<=";
              return self;
          }
        }
        switch (op) {
          case "==":
            self.operator = "!=";
            return self;
          case "!=":
            self.operator = "==";
            return self;
          case "===":
            self.operator = "!==";
            return self;
          case "!==":
            self.operator = "===";
            return self;
          case "&&":
            self.operator = "||";
            self.left = self.left.negate(compressor, first_in_statement2);
            self.right = self.right.negate(compressor);
            return best(this, self, first_in_statement2);
          case "||":
            self.operator = "&&";
            self.left = self.left.negate(compressor, first_in_statement2);
            self.right = self.right.negate(compressor);
            return best(this, self, first_in_statement2);
        }
        return basic_negation(this);
      });
      def(AST_ClassExpression, function() {
        return basic_negation(this);
      });
      def(AST_Conditional, function(compressor, first_in_statement2) {
        var self = this.clone();
        self.consequent = self.consequent.negate(compressor);
        self.alternative = self.alternative.negate(compressor);
        return best(this, self, first_in_statement2);
      });
      def(AST_LambdaExpression, function() {
        return basic_negation(this);
      });
      def(AST_Sequence, function(compressor) {
        var expressions = this.expressions.slice();
        expressions.push(expressions.pop().negate(compressor));
        return make_sequence(this, expressions);
      });
      def(AST_UnaryPrefix, function() {
        if (this.operator == "!")
          return this.expression;
        return basic_negation(this);
      });
    })(function(node, func) {
      node.DEFMETHOD("negate", function(compressor, first_in_statement2) {
        return func.call(this, compressor, first_in_statement2);
      });
    });
    var global_pure_fns = makePredicate("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");
    var global_pure_constructors = makePredicate("Map Set WeakMap WeakSet");
    AST_Call.DEFMETHOD("is_expr_pure", function(compressor) {
      if (compressor.option("unsafe")) {
        var expr = this.expression;
        if (is_undeclared_ref(expr)) {
          if (global_pure_fns[expr.name])
            return true;
          if (this instanceof AST_New && global_pure_constructors[expr.name])
            return true;
        }
        if (is_static_fn(expr))
          return true;
      }
      return compressor.option("annotations") && this.pure || !compressor.pure_funcs(this);
    });
    AST_Template.DEFMETHOD("is_expr_pure", function(compressor) {
      var tag = this.tag;
      if (!tag)
        return true;
      if (compressor.option("unsafe")) {
        if (is_undeclared_ref(tag) && global_pure_fns[tag.name])
          return true;
        if (tag instanceof AST_Dot && is_undeclared_ref(tag.expression)) {
          var static_fn = static_fns[tag.expression.name];
          return static_fn && (static_fn[tag.property] || tag.expression.name == "Math" && tag.property == "random");
        }
      }
      return !compressor.pure_funcs(this);
    });
    AST_Node.DEFMETHOD("is_call_pure", return_false);
    AST_Call.DEFMETHOD("is_call_pure", function(compressor) {
      if (!compressor.option("unsafe"))
        return false;
      var dot = this.expression;
      if (!(dot instanceof AST_Dot))
        return false;
      var exp = dot.expression;
      var map;
      var prop = dot.property;
      if (exp instanceof AST_Array) {
        map = native_fns.Array;
      } else if (exp.is_boolean(compressor)) {
        map = native_fns.Boolean;
      } else if (exp.is_number(compressor)) {
        map = native_fns.Number;
      } else if (exp instanceof AST_RegExp) {
        map = native_fns.RegExp;
      } else if (exp.is_string(compressor)) {
        map = native_fns.String;
        if (prop == "replace") {
          var arg = this.args[1];
          if (arg && !arg.is_string(compressor))
            return false;
        }
      } else if (!dot.may_throw_on_access(compressor)) {
        map = native_fns.Object;
      }
      return map && map[prop];
    });
    function spread_side_effects(exp) {
      while ((exp = exp.tail_node()) instanceof AST_SymbolRef) {
        exp = exp.fixed_value();
        if (!exp)
          return true;
      }
      return !(exp instanceof AST_Array || exp.TYPE == "Binary" && !lazy_op[exp.operator] || exp instanceof AST_Constant || exp instanceof AST_Lambda || exp instanceof AST_Object && all(exp.properties, function(prop) {
        return !(prop instanceof AST_ObjectGetter || prop instanceof AST_Spread);
      }) || exp instanceof AST_ObjectIdentity || exp instanceof AST_Unary);
    }
    (function(def) {
      function any(list, compressor, spread) {
        return !all(list, spread ? function(node) {
          return node instanceof AST_Spread ? !spread(node, compressor) : !node.has_side_effects(compressor);
        } : function(node) {
          return !node.has_side_effects(compressor);
        });
      }
      function array_spread(node, compressor) {
        return !node.expression.is_string(compressor) || node.expression.has_side_effects(compressor);
      }
      def(AST_Node, return_true);
      def(AST_Array, function(compressor) {
        return any(this.elements, compressor, array_spread);
      });
      def(AST_Assign, function(compressor) {
        var lhs = this.left;
        if (!(lhs instanceof AST_PropAccess))
          return true;
        var node = lhs.expression;
        return !(node instanceof AST_ObjectIdentity) || !node.scope.resolve().new || lhs instanceof AST_Sub && lhs.property.has_side_effects(compressor) || this.right.has_side_effects(compressor);
      });
      def(AST_Binary, function(compressor) {
        return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor) || this.operator == "in" && !is_object(this.right);
      });
      def(AST_Block, function(compressor) {
        return any(this.body, compressor);
      });
      def(AST_Call, function(compressor) {
        if (!this.is_expr_pure(compressor) && (!this.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {
          return true;
        }
        return any(this.args, compressor, array_spread);
      });
      def(AST_Case, function(compressor) {
        return this.expression.has_side_effects(compressor) || any(this.body, compressor);
      });
      def(AST_Class, function(compressor) {
        var base = this.extends;
        if (base) {
          if (base instanceof AST_SymbolRef)
            base = base.fixed_value();
          if (!safe_for_extends(base))
            return true;
        }
        return any(this.properties, compressor);
      });
      def(AST_ClassProperty, function(compressor) {
        return this.key instanceof AST_Node && this.key.has_side_effects(compressor) || this.static && this.value && this.value.has_side_effects(compressor);
      });
      def(AST_Conditional, function(compressor) {
        return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);
      });
      def(AST_Constant, return_false);
      def(AST_Definitions, function(compressor) {
        return any(this.definitions, compressor);
      });
      def(AST_DestructuredArray, function(compressor) {
        return any(this.elements, compressor);
      });
      def(AST_DestructuredKeyVal, function(compressor) {
        return this.key instanceof AST_Node && this.key.has_side_effects(compressor) || this.value.has_side_effects(compressor);
      });
      def(AST_DestructuredObject, function(compressor) {
        return any(this.properties, compressor);
      });
      def(AST_Dot, function(compressor) {
        return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.has_side_effects(compressor);
      });
      def(AST_EmptyStatement, return_false);
      def(AST_If, function(compressor) {
        return this.condition.has_side_effects(compressor) || this.body && this.body.has_side_effects(compressor) || this.alternative && this.alternative.has_side_effects(compressor);
      });
      def(AST_LabeledStatement, function(compressor) {
        return this.body.has_side_effects(compressor);
      });
      def(AST_Lambda, return_false);
      def(AST_Object, function(compressor) {
        return any(this.properties, compressor, function(node, compressor2) {
          var exp = node.expression;
          return spread_side_effects(exp) || exp.has_side_effects(compressor2);
        });
      });
      def(AST_ObjectIdentity, return_false);
      def(AST_ObjectProperty, function(compressor) {
        return this.key instanceof AST_Node && this.key.has_side_effects(compressor) || this.value.has_side_effects(compressor);
      });
      def(AST_Sequence, function(compressor) {
        return any(this.expressions, compressor);
      });
      def(AST_SimpleStatement, function(compressor) {
        return this.body.has_side_effects(compressor);
      });
      def(AST_Sub, function(compressor) {
        return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.has_side_effects(compressor) || this.property.has_side_effects(compressor);
      });
      def(AST_Switch, function(compressor) {
        return this.expression.has_side_effects(compressor) || any(this.body, compressor);
      });
      def(AST_SymbolDeclaration, return_false);
      def(AST_SymbolRef, function(compressor) {
        return !this.is_declared(compressor) || !can_drop_symbol(this, compressor);
      });
      def(AST_Template, function(compressor) {
        return !this.is_expr_pure(compressor) || any(this.expressions, compressor);
      });
      def(AST_Try, function(compressor) {
        return any(this.body, compressor) || this.bcatch && this.bcatch.has_side_effects(compressor) || this.bfinally && this.bfinally.has_side_effects(compressor);
      });
      def(AST_Unary, function(compressor) {
        return unary_side_effects[this.operator] || this.expression.has_side_effects(compressor);
      });
      def(AST_VarDef, function() {
        return this.value;
      });
    })(function(node, func) {
      node.DEFMETHOD("has_side_effects", func);
    });
    (function(def) {
      def(AST_Node, return_true);
      def(AST_Constant, return_false);
      def(AST_Destructured, return_true);
      def(AST_EmptyStatement, return_false);
      def(AST_Lambda, return_false);
      def(AST_ObjectIdentity, return_false);
      def(AST_SymbolDeclaration, return_false);
      function any(list, compressor) {
        for (var i = list.length;--i >= 0; )
          if (list[i].may_throw(compressor))
            return true;
        return false;
      }
      function call_may_throw(exp, compressor) {
        if (exp.may_throw(compressor))
          return true;
        if (exp instanceof AST_SymbolRef)
          exp = exp.fixed_value();
        if (!(exp instanceof AST_Lambda))
          return true;
        if (any(exp.argnames, compressor))
          return true;
        if (any(exp.body, compressor))
          return true;
        return is_arrow(exp) && exp.value && exp.value.may_throw(compressor);
      }
      def(AST_Array, function(compressor) {
        return any(this.elements, compressor);
      });
      def(AST_Assign, function(compressor) {
        if (this.right.may_throw(compressor))
          return true;
        if (!compressor.has_directive("use strict") && this.operator == "=" && this.left instanceof AST_SymbolRef) {
          return false;
        }
        return this.left.may_throw(compressor);
      });
      def(AST_Binary, function(compressor) {
        return this.left.may_throw(compressor) || this.right.may_throw(compressor) || this.operator == "in" && !is_object(this.right);
      });
      def(AST_Block, function(compressor) {
        return any(this.body, compressor);
      });
      def(AST_Call, function(compressor) {
        if (any(this.args, compressor))
          return true;
        if (this.is_expr_pure(compressor))
          return false;
        this.may_throw = return_true;
        var ret = call_may_throw(this.expression, compressor);
        delete this.may_throw;
        return ret;
      });
      def(AST_Case, function(compressor) {
        return this.expression.may_throw(compressor) || any(this.body, compressor);
      });
      def(AST_Conditional, function(compressor) {
        return this.condition.may_throw(compressor) || this.consequent.may_throw(compressor) || this.alternative.may_throw(compressor);
      });
      def(AST_DefaultValue, function(compressor) {
        return this.name.may_throw(compressor) || this.value && this.value.may_throw(compressor);
      });
      def(AST_Definitions, function(compressor) {
        return any(this.definitions, compressor);
      });
      def(AST_Dot, function(compressor) {
        return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor);
      });
      def(AST_If, function(compressor) {
        return this.condition.may_throw(compressor) || this.body && this.body.may_throw(compressor) || this.alternative && this.alternative.may_throw(compressor);
      });
      def(AST_LabeledStatement, function(compressor) {
        return this.body.may_throw(compressor);
      });
      def(AST_Object, function(compressor) {
        return any(this.properties, compressor);
      });
      def(AST_ObjectProperty, function(compressor) {
        return this.value.may_throw(compressor) || this.key instanceof AST_Node && this.key.may_throw(compressor);
      });
      def(AST_Return, function(compressor) {
        return this.value && this.value.may_throw(compressor);
      });
      def(AST_Sequence, function(compressor) {
        return any(this.expressions, compressor);
      });
      def(AST_SimpleStatement, function(compressor) {
        return this.body.may_throw(compressor);
      });
      def(AST_Sub, function(compressor) {
        return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor) || this.property.may_throw(compressor);
      });
      def(AST_Switch, function(compressor) {
        return this.expression.may_throw(compressor) || any(this.body, compressor);
      });
      def(AST_SymbolRef, function(compressor) {
        return !this.is_declared(compressor) || !can_drop_symbol(this, compressor);
      });
      def(AST_Template, function(compressor) {
        if (any(this.expressions, compressor))
          return true;
        if (this.is_expr_pure(compressor))
          return false;
        if (!this.tag)
          return false;
        this.may_throw = return_true;
        var ret = call_may_throw(this.tag, compressor);
        delete this.may_throw;
        return ret;
      });
      def(AST_Try, function(compressor) {
        return (this.bcatch ? this.bcatch.may_throw(compressor) : any(this.body, compressor)) || this.bfinally && this.bfinally.may_throw(compressor);
      });
      def(AST_Unary, function(compressor) {
        return this.expression.may_throw(compressor) && !(this.operator == "typeof" && this.expression instanceof AST_SymbolRef);
      });
      def(AST_VarDef, function(compressor) {
        return this.name.may_throw(compressor) || this.value && this.value.may_throw(compressor);
      });
    })(function(node, func) {
      node.DEFMETHOD("may_throw", func);
    });
    (function(def) {
      function all_constant(list, scope) {
        for (var i = list.length;--i >= 0; )
          if (!list[i].is_constant_expression(scope))
            return false;
        return true;
      }
      def(AST_Node, return_false);
      def(AST_Array, function(scope) {
        return all_constant(this.elements, scope);
      });
      def(AST_Binary, function(scope) {
        return this.left.is_constant_expression(scope) && this.right.is_constant_expression(scope) && (this.operator != "in" || is_object(this.right));
      });
      def(AST_Class, function(scope) {
        var base = this.extends;
        if (base && !safe_for_extends(base))
          return false;
        return all_constant(this.properties, scope);
      });
      def(AST_ClassProperty, function(scope) {
        return typeof this.key == "string" && (!this.value || this.value.is_constant_expression(scope));
      });
      def(AST_Constant, return_true);
      def(AST_Lambda, function(scope) {
        var self = this;
        var result = true;
        var scopes = [];
        self.walk(new TreeWalker(function(node, descend) {
          if (!result)
            return true;
          if (node instanceof AST_BlockScope) {
            if (node === self)
              return;
            scopes.push(node);
            descend();
            scopes.pop();
            return true;
          }
          if (node instanceof AST_SymbolRef) {
            if (self.inlined || node.redef) {
              result = false;
              return true;
            }
            if (self.variables.has(node.name))
              return true;
            var def2 = node.definition();
            if (member(def2.scope, scopes))
              return true;
            if (scope && !def2.redefined()) {
              var scope_def = scope.find_variable(node.name);
              if (scope_def ? scope_def === def2 : def2.undeclared) {
                result = "f";
                return true;
              }
            }
            result = false;
            return true;
          }
          if (node instanceof AST_ObjectIdentity) {
            if (is_arrow(self) && all(scopes, function(s2) {
              return !(s2 instanceof AST_Scope) || is_arrow(s2);
            }))
              result = false;
            return true;
          }
        }));
        return result;
      });
      def(AST_Object, function(scope) {
        return all_constant(this.properties, scope);
      });
      def(AST_ObjectProperty, function(scope) {
        return typeof this.key == "string" && this.value.is_constant_expression(scope);
      });
      def(AST_Unary, function(scope) {
        return this.expression.is_constant_expression(scope);
      });
    })(function(node, func) {
      node.DEFMETHOD("is_constant_expression", func);
    });
    function aborts(thing) {
      return thing && thing.aborts();
    }
    (function(def) {
      def(AST_Statement, return_null);
      def(AST_Jump, return_this);
      function block_aborts() {
        var n = this.body.length;
        return n > 0 && aborts(this.body[n - 1]);
      }
      def(AST_BlockStatement, block_aborts);
      def(AST_SwitchBranch, block_aborts);
      def(AST_If, function() {
        return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
      });
    })(function(node, func) {
      node.DEFMETHOD("aborts", func);
    });
    var directives = makePredicate(["use asm", "use strict"]);
    OPT(AST_Directive, function(self, compressor) {
      if (compressor.option("directives") && (!directives[self.value] || compressor.has_directive(self.value) !== self)) {
        return make_node(AST_EmptyStatement, self);
      }
      return self;
    });
    OPT(AST_Debugger, function(self, compressor) {
      if (compressor.option("drop_debugger"))
        return make_node(AST_EmptyStatement, self);
      return self;
    });
    OPT(AST_LabeledStatement, function(self, compressor) {
      if (compressor.option("dead_code") && self.body instanceof AST_Break && compressor.loopcontrol_target(self.body) === self.body) {
        return make_node(AST_EmptyStatement, self);
      }
      return compressor.option("unused") && self.label.references.length == 0 ? self.body : self;
    });
    OPT(AST_Block, function(self, compressor) {
      self.body = tighten_body(self.body, compressor);
      return self;
    });
    function trim_block(node, parent, in_list) {
      switch (node.body.length) {
        case 0:
          return in_list ? List.skip : make_node(AST_EmptyStatement, node);
        case 1:
          var stat = node.body[0];
          if (!safe_to_trim(stat))
            return node;
          if (parent instanceof AST_IterationStatement && stat instanceof AST_LambdaDefinition)
            return node;
          return stat;
      }
      return node;
    }
    OPT(AST_BlockStatement, function(self, compressor) {
      self.body = tighten_body(self.body, compressor);
      return trim_block(self, compressor.parent());
    });
    function drop_rest_farg(fn, compressor) {
      if (!compressor.option("rests"))
        return;
      if (fn.uses_arguments)
        return;
      if (!(fn.rest instanceof AST_DestructuredArray))
        return;
      if (!compressor.drop_fargs(fn, compressor.parent()))
        return;
      fn.argnames = fn.argnames.concat(fn.rest.elements);
      fn.rest = fn.rest.rest;
    }
    OPT(AST_Lambda, function(self, compressor) {
      drop_rest_farg(self, compressor);
      self.body = tighten_body(self.body, compressor);
      return self;
    });
    function opt_arrow(self, compressor) {
      if (!compressor.option("arrows"))
        return self;
      drop_rest_farg(self, compressor);
      var body = tighten_body(self.value ? [self.first_statement()] : self.body, compressor);
      switch (body.length) {
        case 1:
          var stat = body[0];
          if (stat instanceof AST_Return) {
            self.body.length = 0;
            self.value = stat.value;
            break;
          }
        default:
          self.body = body;
          self.value = null;
          break;
      }
      return self;
    }
    OPT(AST_Arrow, opt_arrow);
    OPT(AST_AsyncArrow, opt_arrow);
    OPT(AST_Function, function(self, compressor) {
      drop_rest_farg(self, compressor);
      self.body = tighten_body(self.body, compressor);
      var parent = compressor.parent();
      if (compressor.option("inline"))
        for (var i = 0;i < self.body.length; i++) {
          var stat = self.body[i];
          if (stat instanceof AST_Directive)
            continue;
          if (stat instanceof AST_Return) {
            if (i != self.body.length - 1)
              break;
            var call = stat.value;
            if (!call || call.TYPE != "Call")
              break;
            if (call.is_expr_pure(compressor))
              break;
            var fn = call.expression;
            if (fn instanceof AST_SymbolRef) {
              if (self.name && self.name.definition() === fn.definition())
                break;
              fn = fn.fixed_value();
            }
            if (!(fn instanceof AST_Defun || fn instanceof AST_Function))
              break;
            if (fn.uses_arguments)
              break;
            if (fn === call.expression) {
              if (fn.parent_scope !== self)
                break;
              if (!all(fn.enclosed, function(def) {
                return def.scope !== self;
              }))
                break;
            }
            if (fn.name && (parent instanceof AST_ClassMethod || parent instanceof AST_ObjectMethod) && parent.value === compressor.self())
              break;
            if (fn.contains_this())
              break;
            var len = fn.argnames.length;
            if (len > 0 && compressor.option("inline") < 2)
              break;
            if (len > self.argnames.length)
              break;
            if (!all(self.argnames, function(argname) {
              return argname instanceof AST_SymbolFunarg;
            }))
              break;
            if (!all(call.args, function(arg2) {
              return !(arg2 instanceof AST_Spread);
            }))
              break;
            for (var j2 = 0;j2 < len; j2++) {
              var arg = call.args[j2];
              if (!(arg instanceof AST_SymbolRef))
                break;
              if (arg.definition() !== self.argnames[j2].definition())
                break;
            }
            if (j2 < len)
              break;
            for (;j2 < call.args.length; j2++) {
              if (call.args[j2].has_side_effects(compressor))
                break;
            }
            if (j2 < call.args.length)
              break;
            if (len < self.argnames.length && !compressor.drop_fargs(self, parent)) {
              if (!compressor.drop_fargs(fn, call))
                break;
              do {
                fn.argnames.push(fn.make_var(AST_SymbolFunarg, fn, "argument_" + len));
              } while (++len < self.argnames.length);
            }
            return call.expression;
          }
          break;
        }
      return self;
    });
    var NO_MERGE = makePredicate("arguments await yield");
    AST_Scope.DEFMETHOD("merge_variables", function(compressor) {
      if (!compressor.option("merge_vars"))
        return;
      var in_try, root, segment = {}, self = this;
      var first = [], last = [], index = 0;
      var declarations = new Dictionary;
      var references = Object.create(null);
      var prev = Object.create(null);
      var tw = new TreeWalker(function(node, descend) {
        if (node instanceof AST_Assign) {
          var lhs = node.left;
          var rhs = node.right;
          if (lhs instanceof AST_Destructured) {
            rhs.walk(tw);
            var marker = new TreeWalker(function(node2) {
              if (node2 instanceof AST_Destructured)
                return;
              if (node2 instanceof AST_DefaultValue) {
                push();
                node2.value.walk(tw);
                pop();
                node2.name.walk(marker);
              } else if (node2 instanceof AST_DestructuredKeyVal) {
                if (node2.key instanceof AST_Node) {
                  push();
                  segment.block = node2;
                  node2.key.walk(tw);
                  node2.value.walk(marker);
                  pop();
                } else {
                  node2.value.walk(marker);
                }
              } else if (node2 instanceof AST_SymbolRef) {
                mark(node2);
              } else {
                node2.walk(tw);
              }
              return true;
            });
            lhs.walk(marker);
            return true;
          }
          if (lazy_op[node.operator.slice(0, -1)]) {
            lhs.walk(tw);
            push();
            rhs.walk(tw);
            if (lhs instanceof AST_SymbolRef)
              mark(lhs);
            pop();
            return true;
          }
          if (lhs instanceof AST_SymbolRef) {
            if (node.operator != "=")
              mark(lhs, true);
            rhs.walk(tw);
            mark(lhs);
            return true;
          }
          return;
        }
        if (node instanceof AST_Binary) {
          if (!lazy_op[node.operator])
            return;
          node.left.walk(tw);
          push();
          node.right.walk(tw);
          pop();
          return true;
        }
        if (node instanceof AST_Break) {
          var target = tw.loopcontrol_target(node);
          if (!(target instanceof AST_IterationStatement))
            insert(target);
          return true;
        }
        if (node instanceof AST_Call) {
          var exp = node.expression;
          var tail2 = exp.tail_node();
          if (!(tail2 instanceof AST_LambdaExpression)) {
            descend();
            return mark_expression(exp);
          }
          if (exp !== tail2)
            exp.expressions.slice(0, -1).forEach(function(node2) {
              node2.walk(tw);
            });
          node.args.forEach(function(arg) {
            arg.walk(tw);
          });
          tail2.walk(tw);
          return true;
        }
        if (node instanceof AST_Conditional) {
          node.condition.walk(tw);
          push();
          node.consequent.walk(tw);
          pop();
          push();
          node.alternative.walk(tw);
          pop();
          return true;
        }
        if (node instanceof AST_Continue) {
          var target = tw.loopcontrol_target(node);
          if (target instanceof AST_Do)
            insert(target);
          return true;
        }
        if (node instanceof AST_Do) {
          push();
          segment.block = node;
          segment.loop = true;
          var save = segment;
          node.body.walk(tw);
          if (segment.inserted === node)
            segment = save;
          node.condition.walk(tw);
          pop();
          return true;
        }
        if (node instanceof AST_For) {
          if (node.init)
            node.init.walk(tw);
          push();
          segment.block = node;
          segment.loop = true;
          if (node.condition)
            node.condition.walk(tw);
          node.body.walk(tw);
          if (node.step)
            node.step.walk(tw);
          pop();
          return true;
        }
        if (node instanceof AST_ForEnumeration) {
          node.object.walk(tw);
          push();
          segment.block = node;
          segment.loop = true;
          node.init.walk(tw);
          node.body.walk(tw);
          pop();
          return true;
        }
        if (node instanceof AST_If) {
          node.condition.walk(tw);
          push();
          node.body.walk(tw);
          pop();
          if (node.alternative) {
            push();
            node.alternative.walk(tw);
            pop();
          }
          return true;
        }
        if (node instanceof AST_LabeledStatement) {
          push();
          segment.block = node;
          var save = segment;
          node.body.walk(tw);
          if (segment.inserted === node)
            segment = save;
          pop();
          return true;
        }
        if (node instanceof AST_Scope) {
          push();
          segment.block = node;
          if (node === self)
            root = segment;
          if (node instanceof AST_Lambda) {
            if (node.name)
              references[node.name.definition().id] = false;
            var marker = node.uses_arguments && !tw.has_directive("use strict") ? function(node2) {
              if (node2 instanceof AST_SymbolFunarg)
                references[node2.definition().id] = false;
            } : function(node2) {
              if (node2 instanceof AST_SymbolFunarg)
                mark(node2);
            };
            var scanner = new TreeWalker(function(ref) {
              if (ref instanceof AST_SymbolDeclaration)
                references[ref.definition().id] = false;
              if (!(ref instanceof AST_SymbolRef))
                return;
              var def2 = ref.definition();
              var ldef = node.variables.get(ref.name);
              if (ldef && (ldef === def2 || def2.undeclared || node.parent_scope.find_variable(ref.name) === def2)) {
                references[def2.id] = false;
                references[ldef.id] = false;
              } else {
                var save2 = segment;
                pop();
                mark(ref, true);
                segment = save2;
              }
              return true;
            });
            node.argnames.forEach(function(argname) {
              argname.mark_symbol(marker, scanner);
            });
            if (node.rest)
              node.rest.mark_symbol(marker, scanner);
          }
          walk_lambda(node, tw);
          pop();
          return true;
        }
        if (node instanceof AST_Sub) {
          var exp = node.expression;
          if (node.optional) {
            exp.walk(tw);
            push();
            node.property.walk(tw);
            pop();
          } else {
            descend();
          }
          return mark_expression(exp);
        }
        if (node instanceof AST_Switch) {
          node.expression.walk(tw);
          var save = segment;
          node.body.forEach(function(branch) {
            if (branch instanceof AST_Default)
              return;
            branch.expression.walk(tw);
            if (save === segment)
              push();
          });
          segment = save;
          node.body.forEach(function(branch) {
            push();
            segment.block = node;
            var save2 = segment;
            walk_body(branch, tw);
            if (segment.inserted === node)
              segment = save2;
            pop();
          });
          return true;
        }
        if (node instanceof AST_SymbolConst || node instanceof AST_SymbolLet) {
          references[node.definition().id] = false;
          return true;
        }
        if (node instanceof AST_SymbolRef) {
          mark(node, true);
          return true;
        }
        if (node instanceof AST_Try) {
          var save_try = in_try;
          in_try = node;
          var save = segment;
          walk_body(node, tw);
          segment = save;
          if (node.bcatch) {
            if (node.bcatch.argname)
              node.bcatch.argname.mark_symbol(function(node2) {
                if (node2 instanceof AST_SymbolCatch) {
                  var def2 = node2.definition();
                  references[def2.id] = false;
                  if (def2 = def2.redefined())
                    references[def2.id] = false;
                }
              }, tw);
            if (node.bfinally || (in_try = save_try)) {
              walk_body(node.bcatch, tw);
            } else {
              push();
              walk_body(node.bcatch, tw);
              pop();
            }
          }
          in_try = save_try;
          segment = save;
          if (node.bfinally)
            node.bfinally.walk(tw);
          return true;
        }
        if (node instanceof AST_Unary) {
          if (!UNARY_POSTFIX[node.operator])
            return;
          var sym = node.expression;
          if (!(sym instanceof AST_SymbolRef))
            return;
          mark(sym, true);
          return true;
        }
        if (node instanceof AST_VarDef) {
          var assigned = node.value;
          if (assigned) {
            assigned.walk(tw);
          } else {
            assigned = segment.block instanceof AST_ForEnumeration && segment.block.init === tw.parent();
          }
          node.name.mark_symbol(assigned ? function(node2) {
            if (!(node2 instanceof AST_SymbolDeclaration))
              return;
            if (node2 instanceof AST_SymbolVar) {
              mark(node2);
            } else {
              references[node2.definition().id] = false;
            }
            return true;
          } : function(node2) {
            if (!(node2 instanceof AST_SymbolDeclaration))
              return;
            var id2 = node2.definition().id;
            if (!(node2 instanceof AST_SymbolVar)) {
              references[id2] = false;
            } else if (!(id2 in references)) {
              declarations.add(id2, node2);
            } else if (references[id2]) {
              references[id2].push(node2);
            }
            return true;
          }, tw);
          return true;
        }
        if (node instanceof AST_While) {
          push();
          segment.block = node;
          segment.loop = true;
          descend();
          pop();
          return true;
        }
        function mark_expression(exp2) {
          if (compressor.option("ie")) {
            var sym2 = root_expr(exp2);
            if (sym2 instanceof AST_SymbolRef)
              sym2.walk(tw);
          }
          return true;
        }
      });
      tw.directives = Object.create(compressor.directives);
      self.walk(tw);
      var merged = Object.create(null);
      while (first.length && last.length) {
        var head = first.pop();
        var def = head.definition;
        if (!(def.id in prev))
          continue;
        if (!references[def.id])
          continue;
        var head_refs = {
          start: references[def.id].start
        };
        while (def.id in merged)
          def = merged[def.id];
        head_refs.end = references[def.id].end;
        var skipped = [];
        do {
          var tail = last.pop();
          if (!tail)
            continue;
          if (tail.index > head.index)
            continue;
          var id = tail.definition.id;
          var tail_refs = references[id];
          if (!tail_refs)
            continue;
          if (head_refs.start.block !== tail_refs.start.block || !mergeable(head_refs, tail_refs) || (head_refs.start.loop || !same_scope(def)) && !mergeable(tail_refs, head_refs) || compressor.option("webkit") && is_funarg(def) !== is_funarg(tail.definition) || !all(tail_refs, function(sym) {
            return sym.scope.find_variable(def.name) === def;
          })) {
            skipped.unshift(tail);
            continue;
          }
          var orig = [], refs = [];
          tail_refs.forEach(function(sym) {
            sym.thedef = def;
            sym.name = def.name;
            if (sym instanceof AST_SymbolRef) {
              refs.push(sym);
            } else {
              orig.push(sym);
            }
          });
          def.orig = orig.concat(def.orig);
          def.references = refs.concat(def.references);
          def.fixed = tail.definition.fixed && def.fixed;
          merged[id] = def;
          break;
        } while (last.length);
        if (skipped.length)
          last = last.concat(skipped);
      }
      function push() {
        segment = Object.create(segment);
      }
      function pop() {
        segment = Object.getPrototypeOf(segment);
      }
      function mark(sym, read) {
        var def2 = sym.definition(), ldef, seg = segment;
        if (in_try) {
          push();
          seg = segment;
          pop();
        }
        if (def2.id in references) {
          var refs2 = references[def2.id];
          if (!refs2)
            return;
          if (refs2.start.block !== seg.block)
            return references[def2.id] = false;
          refs2.push(sym);
          refs2.end = seg;
          if (def2.id in prev) {
            last[prev[def2.id]] = null;
          } else if (!read) {
            return;
          }
        } else if ((ldef = self.variables.get(def2.name)) !== def2) {
          if (ldef && root === seg)
            references[ldef.id] = false;
          return references[def2.id] = false;
        } else if (compressor.exposed(def2) || NO_MERGE[sym.name]) {
          return references[def2.id] = false;
        } else {
          var refs2 = declarations.get(def2.id) || [];
          refs2.push(sym);
          references[def2.id] = refs2;
          if (!read) {
            refs2.start = seg;
            return first.push({
              index: index++,
              definition: def2
            });
          }
          if (seg.block !== self)
            return references[def2.id] = false;
          refs2.start = root;
        }
        prev[def2.id] = last.length;
        last.push({
          index: index++,
          definition: def2
        });
      }
      function insert(target) {
        var stack = [];
        while (true) {
          if (HOP(segment, "block")) {
            var block = segment.block;
            if (block instanceof AST_LabeledStatement)
              block = block.body;
            if (block === target)
              break;
          }
          stack.push(segment);
          pop();
        }
        segment.inserted = segment.block;
        push();
        while (stack.length) {
          var seg = stack.pop();
          push();
          if (HOP(seg, "block"))
            segment.block = seg.block;
          if (HOP(seg, "loop"))
            segment.loop = seg.loop;
        }
      }
      function must_visit(base, segment2) {
        return base === segment2 || base.isPrototypeOf(segment2);
      }
      function mergeable(head2, tail2) {
        return must_visit(head2.start, head2.end) || must_visit(head2.start, tail2.start);
      }
    });
    function fill_holes(orig, elements) {
      for (var i = elements.length;--i >= 0; ) {
        if (!elements[i])
          elements[i] = make_node(AST_Hole, orig);
      }
    }
    function to_class_expr(defcl, drop_name) {
      var cl = make_node(AST_ClassExpression, defcl, defcl);
      cl.name = drop_name ? null : make_node(AST_SymbolClass, defcl.name, defcl.name);
      return cl;
    }
    function to_func_expr(defun, drop_name) {
      var ctor;
      switch (defun.CTOR) {
        case AST_AsyncDefun:
          ctor = AST_AsyncFunction;
          break;
        case AST_AsyncGeneratorDefun:
          ctor = AST_AsyncGeneratorFunction;
          break;
        case AST_Defun:
          ctor = AST_Function;
          break;
        case AST_GeneratorDefun:
          ctor = AST_GeneratorFunction;
          break;
      }
      var fn = make_node(ctor, defun, defun);
      fn.name = drop_name ? null : make_node(AST_SymbolLambda, defun.name, defun.name);
      return fn;
    }
    AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
      if (!compressor.option("unused"))
        return;
      var self = this;
      var drop_funcs = !(self instanceof AST_Toplevel) || compressor.toplevel.funcs;
      var drop_vars = !(self instanceof AST_Toplevel) || compressor.toplevel.vars;
      var assign_as_unused = /keep_assign/.test(compressor.option("unused")) ? return_false : function(node, props) {
        var sym, nested = false;
        if (node instanceof AST_Assign) {
          if (node.write_only || node.operator == "=")
            sym = extract_reference(node.left, props);
        } else if (node instanceof AST_Unary) {
          if (node.write_only)
            sym = extract_reference(node.expression, props);
        }
        if (!(sym instanceof AST_SymbolRef))
          return;
        var def = sym.definition();
        if (export_defaults[def.id])
          return;
        if (compressor.exposed(def))
          return;
        if (!can_drop_symbol(sym, compressor, nested))
          return;
        return sym;
        function extract_reference(node2, props2) {
          if (node2 instanceof AST_PropAccess) {
            var expr = node2.expression;
            if (!expr.may_throw_on_access(compressor, true)) {
              nested = true;
              if (props2 && node2 instanceof AST_Sub)
                props2.unshift(node2.property);
              return extract_reference(expr, props2);
            }
          } else if (node2 instanceof AST_Assign && node2.operator == "=") {
            node2.write_only = "p";
            var ref = extract_reference(node2.right);
            if (!props2)
              return ref;
            props2.assign = node2;
            return ref instanceof AST_SymbolRef ? ref : node2.left;
          }
          return node2;
        }
      };
      var assign_in_use = Object.create(null);
      var export_defaults = Object.create(null);
      var find_variable = function(name) {
        find_variable = compose(self, 0, noop);
        return find_variable(name);
        function compose(child, level, find) {
          var parent = compressor.parent(level);
          if (!parent)
            return find;
          var in_arg = parent instanceof AST_Lambda && member(child, parent.argnames);
          return compose(parent, level + 1, in_arg ? function(name2) {
            var def = find(name2);
            if (def)
              return def;
            def = parent.variables.get(name2);
            if (def) {
              var sym = def.orig[0];
              if (sym instanceof AST_SymbolFunarg || sym instanceof AST_SymbolLambda)
                return def;
            }
          } : parent.variables ? function(name2) {
            return find(name2) || parent.variables.get(name2);
          } : find);
        }
      };
      var for_ins = Object.create(null);
      var in_use = [];
      var in_use_ids = Object.create(null);
      var value_read = Object.create(null);
      var value_modified = Object.create(null);
      var var_defs = Object.create(null);
      if (self instanceof AST_Toplevel && compressor.top_retain) {
        self.variables.each(function(def) {
          if (compressor.top_retain(def) && !(def.id in in_use_ids)) {
            in_use_ids[def.id] = true;
            in_use.push(def);
          }
        });
      }
      var assignments = new Dictionary;
      var initializations = new Dictionary;
      var scope = this;
      var tw = new TreeWalker(function(node, descend) {
        if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive("use strict")) {
          node.each_argname(function(argname) {
            var def2 = argname.definition();
            if (!(def2.id in in_use_ids)) {
              in_use_ids[def2.id] = true;
              in_use.push(def2);
            }
          });
        }
        if (node === self)
          return;
        if (scope === self) {
          if (node instanceof AST_DefClass) {
            var def = node.name.definition();
            if ((!drop_funcs || def.exported) && !(def.id in in_use_ids)) {
              in_use_ids[def.id] = true;
              in_use.push(def);
            }
            if (node.extends)
              node.extends.walk(tw);
            var is_export = false;
            if (tw.parent() instanceof AST_ExportDefault) {
              is_export = true;
              export_defaults[def.id] = true;
            }
            node.properties.forEach(function(prop) {
              if (prop.key instanceof AST_Node)
                prop.key.walk(tw);
              if (!prop.value)
                return;
              if (is_export || prop instanceof AST_ClassField && prop.static) {
                var save_scope = scope;
                scope = node;
                prop.value.walk(tw);
                scope = save_scope;
              } else {
                initializations.add(def.id, prop.value);
              }
            });
            return true;
          }
          if (node instanceof AST_LambdaDefinition) {
            var def = node.name.definition();
            if ((!drop_funcs || def.exported) && !(def.id in in_use_ids)) {
              in_use_ids[def.id] = true;
              in_use.push(def);
            }
            initializations.add(def.id, node);
            if (tw.parent() instanceof AST_ExportDefault) {
              export_defaults[def.id] = true;
            } else {
              return true;
            }
          }
          if (node instanceof AST_Definitions) {
            node.definitions.forEach(function(defn) {
              var value = defn.value;
              var side_effects = value && (defn.name instanceof AST_Destructured || value.has_side_effects(compressor));
              var shared = side_effects && value.tail_node().operator == "=";
              defn.name.mark_symbol(function(name) {
                if (!(name instanceof AST_SymbolDeclaration))
                  return;
                var def2 = name.definition();
                var_defs[def2.id] = (var_defs[def2.id] || 0) + 1;
                if (node instanceof AST_Var && def2.orig[0] instanceof AST_SymbolCatch) {
                  var redef = def2.redefined();
                  if (redef)
                    var_defs[redef.id] = (var_defs[redef.id] || 0) + 1;
                }
                if (!(def2.id in in_use_ids) && (!drop_vars || def2.exported || (node instanceof AST_Const ? def2.redefined() : def2.const_redefs) || !(node instanceof AST_Var || is_safe_lexical(def2)))) {
                  in_use_ids[def2.id] = true;
                  in_use.push(def2);
                }
                if (value) {
                  if (!side_effects) {
                    initializations.add(def2.id, value);
                  } else if (shared) {
                    verify_safe_usage(def2, name, value_modified[def2.id]);
                  }
                  assignments.add(def2.id, defn);
                }
                return true;
              }, tw);
              if (side_effects)
                value.walk(tw);
            });
            return true;
          }
          if (node instanceof AST_SymbolFunarg) {
            var def = node.definition();
            var_defs[def.id] = (var_defs[def.id] || 0) + 1;
            assignments.add(def.id, node);
            return true;
          }
          if (node instanceof AST_SymbolImport) {
            var def = node.definition();
            if (!(def.id in in_use_ids) && (!drop_vars || !is_safe_lexical(def))) {
              in_use_ids[def.id] = true;
              in_use.push(def);
            }
            return true;
          }
        }
        return scan_ref_scoped(node, descend, true);
      });
      tw.directives = Object.create(compressor.directives);
      self.walk(tw);
      var drop_fn_name = compressor.option("keep_fnames") ? return_false : compressor.option("ie") ? function(def) {
        return !compressor.exposed(def) && def.references.length == def.replaced;
      } : function(def) {
        if (!(def.id in in_use_ids))
          return true;
        if (def.orig.length - def.eliminated < 2)
          return false;
        if (def.orig[1] instanceof AST_SymbolFunarg)
          return true;
        return all(def.references, function(ref) {
          return !ref.in_arg;
        });
      };
      if (compressor.option("ie"))
        initializations.each(function(init2, id) {
          if (id in in_use_ids)
            return;
          init2.forEach(function(init3) {
            init3.walk(new TreeWalker(function(node) {
              if (node instanceof AST_Function && node.name && !drop_fn_name(node.name.definition())) {
                node.walk(tw);
                return true;
              }
              if (node instanceof AST_Scope)
                return true;
            }));
          });
        });
      tw = new TreeWalker(scan_ref_scoped);
      for (var i = 0;i < in_use.length; i++) {
        var init = initializations.get(in_use[i].id);
        if (init)
          init.forEach(function(init2) {
            init2.walk(tw);
          });
      }
      Object.keys(assign_in_use).forEach(function(id) {
        var assigns = assign_in_use[id];
        if (!assigns) {
          delete assign_in_use[id];
          return;
        }
        assigns = assigns.reduce(function(in_use3, assigns2) {
          assigns2.forEach(function(assign) {
            push_uniq(in_use3, assign);
          });
          return in_use3;
        }, []);
        var in_use2 = (assignments.get(id) || []).filter(function(node) {
          return find_if(node instanceof AST_Unary ? function(assign) {
            return assign === node;
          } : function(assign) {
            if (assign === node)
              return true;
            if (assign instanceof AST_Unary)
              return false;
            return get_rvalue(assign) === get_rvalue(node);
          }, assigns);
        });
        if (assigns.length == in_use2.length) {
          assign_in_use[id] = in_use2;
        } else {
          delete assign_in_use[id];
        }
      });
      var trim_defns = [];
      var unused_fn_names = [];
      var calls_to_drop_args = [];
      var fns_with_marked_args = [];
      var trimmer = new TreeTransformer(function(node) {
        if (node instanceof AST_DefaultValue)
          return trim_default(trimmer, node);
        if (node instanceof AST_Destructured && node.rest)
          node.rest = node.rest.transform(trimmer);
        if (node instanceof AST_DestructuredArray) {
          var trim = !node.rest;
          for (var i2 = node.elements.length;--i2 >= 0; ) {
            var element = node.elements[i2].transform(trimmer);
            if (element) {
              node.elements[i2] = element;
              trim = false;
            } else if (trim) {
              node.elements.pop();
            } else {
              node.elements[i2] = make_node(AST_Hole, node.elements[i2]);
            }
          }
          return node;
        }
        if (node instanceof AST_DestructuredObject) {
          var properties = [];
          node.properties.forEach(function(prop) {
            var retain = false;
            if (prop.key instanceof AST_Node) {
              prop.key = prop.key.transform(tt2);
              retain = prop.key.has_side_effects(compressor);
            }
            if ((retain || node.rest) && is_decl(prop.value)) {
              prop.value = prop.value.transform(tt2);
              properties.push(prop);
            } else {
              var value = prop.value.transform(trimmer);
              if (!value && node.rest) {
                if (prop.value instanceof AST_DestructuredArray) {
                  value = make_node(AST_DestructuredArray, prop.value, { elements: [] });
                } else {
                  value = make_node(AST_DestructuredObject, prop.value, { properties: [] });
                }
              }
              if (value) {
                prop.value = value;
                properties.push(prop);
              }
            }
          });
          node.properties = properties;
          return node;
        }
        if (node instanceof AST_SymbolDeclaration)
          return node.definition().id in in_use_ids ? node : null;
      });
      var tt2 = new TreeTransformer(function(node, descend, in_list) {
        var parent = tt2.parent();
        if (drop_vars) {
          var props = [], sym = assign_as_unused(node, props);
          if (sym) {
            var value;
            if (can_drop_lhs(sym, node)) {
              if (node instanceof AST_Assign) {
                value = get_rhs(node);
                if (node.write_only === true)
                  value = value.drop_side_effect_free(compressor);
              }
              if (!value)
                value = make_node(AST_Number, node, { value: 0 });
            }
            if (value) {
              if (props.assign) {
                var assign = props.assign.drop_side_effect_free(compressor);
                if (assign) {
                  assign.write_only = true;
                  props.unshift(assign);
                }
              }
              if (!(parent instanceof AST_Sequence) || parent.tail_node() === node || value.has_side_effects(compressor)) {
                props.push(value);
              }
              switch (props.length) {
                case 0:
                  return List.skip;
                case 1:
                  return maintain_this_binding(compressor, parent, node, props[0].transform(tt2));
                default:
                  return make_sequence(node, props.map(function(prop) {
                    return prop.transform(tt2);
                  }));
              }
            }
          } else if (node instanceof AST_UnaryPostfix && node.expression instanceof AST_SymbolRef && indexOf_assign(node.expression.definition(), node) < 0) {
            return make_node(AST_UnaryPrefix, node, {
              operator: "+",
              expression: node.expression
            });
          }
        }
        if (node instanceof AST_Call)
          calls_to_drop_args.push(node);
        if (scope !== self)
          return;
        if (drop_funcs && node !== self && node instanceof AST_DefClass) {
          var def = node.name.definition();
          if (!(def.id in in_use_ids)) {
            log(node.name, "Dropping unused class {name}");
            def.eliminated++;
            descend(node, tt2);
            if (parent instanceof AST_ExportDefault)
              return to_class_expr(node, true);
            var trimmed = node.drop_side_effect_free(compressor, true);
            if (trimmed === node)
              trimmed = to_class_expr(node, true);
            if (trimmed)
              return make_node(AST_SimpleStatement, node, { body: trimmed });
            return in_list ? List.skip : make_node(AST_EmptyStatement, node);
          }
        }
        if (node instanceof AST_ClassExpression && node.name && drop_fn_name(node.name.definition())) {
          unused_fn_names.push(node);
        }
        if (node instanceof AST_Lambda) {
          if (drop_funcs && node !== self && node instanceof AST_LambdaDefinition) {
            var def = node.name.definition();
            if (!(def.id in in_use_ids)) {
              log(node.name, "Dropping unused function {name}");
              def.eliminated++;
              if (parent instanceof AST_ExportDefault) {
                descend_scope();
                return to_func_expr(node, true);
              }
              return in_list ? List.skip : make_node(AST_EmptyStatement, node);
            }
          }
          if (node instanceof AST_LambdaExpression && node.name && drop_fn_name(node.name.definition())) {
            unused_fn_names.push(node);
          }
          if (!(node instanceof AST_Accessor)) {
            if (node.rest) {
              var rest = node.rest.transform(trimmer);
              if (rest instanceof AST_Destructured && !rest.rest && (!node.uses_arguments || tt2.has_directive("use strict"))) {
                if (rest instanceof AST_DestructuredArray) {
                  if (rest.elements.length == 0)
                    rest = null;
                } else if (rest.properties.length == 0) {
                  rest = null;
                }
              }
              node.rest = rest;
            }
            var argnames = node.argnames;
            var trim = compressor.drop_fargs(node, parent) && !node.rest;
            var default_length = trim ? -1 : node.length();
            for (var i2 = argnames.length;--i2 >= 0; ) {
              var sym = argnames[i2];
              if (!(sym instanceof AST_SymbolFunarg)) {
                var arg = sym.transform(trimmer);
                if (arg) {
                  trim = false;
                } else if (trim) {
                  log(sym.name, "Dropping unused default argument {name}");
                  argnames.pop();
                } else if (i2 > default_length) {
                  log(sym.name, "Dropping unused default argument assignment {name}");
                  sym.name.__unused = true;
                  argnames[i2] = sym.name;
                } else {
                  log(sym.name, "Dropping unused default argument value {name}");
                  sym.value = make_node(AST_Number, sym, { value: 0 });
                }
                continue;
              }
              var def = sym.definition();
              if (def.id in in_use_ids) {
                trim = false;
                if (indexOf_assign(def, sym) < 0)
                  sym.__unused = null;
              } else if (trim) {
                log(sym, "Dropping unused function argument {name}");
                argnames.pop();
              } else {
                sym.__unused = true;
              }
            }
            fns_with_marked_args.push(node);
          }
        }
        if (node instanceof AST_Catch && node.argname instanceof AST_Destructured) {
          node.argname.transform(trimmer);
        }
        if (node instanceof AST_Definitions && !(parent instanceof AST_ForEnumeration && parent.init === node)) {
          var body = [], head = [], tail = [];
          var side_effects = [];
          var duplicated = 0;
          var is_var = node instanceof AST_Var;
          node.definitions.forEach(function(def2) {
            if (def2.value)
              def2.value = def2.value.transform(tt2);
            var value2 = def2.value;
            if (def2.name instanceof AST_Destructured) {
              var trimmed2 = trim_destructured(def2.name, value2, function(node2) {
                if (!drop_vars)
                  return node2;
                if (node2.definition().id in in_use_ids)
                  return node2;
                if (is_catch(node2))
                  return node2;
                if (is_var && !can_drop_symbol(node2))
                  return node2;
                return null;
              }, true);
              if (trimmed2.name) {
                def2 = make_node(AST_VarDef, def2, {
                  name: trimmed2.name,
                  value: value2 = trimmed2.value
                });
                flush();
              } else if (trimmed2.value) {
                side_effects.push(trimmed2.value);
              }
              return;
            }
            var sym2 = def2.name.definition();
            var drop_sym = is_var ? can_drop_symbol(def2.name) : is_safe_lexical(sym2);
            if (!drop_sym || !drop_vars || sym2.id in in_use_ids) {
              if (value2 && indexOf_assign(sym2, def2) < 0) {
                value2 = value2.drop_side_effect_free(compressor);
                if (value2) {
                  AST_Node.warn("Side effects in last use of variable {name} [{file}:{line},{col}]", template(def2.name));
                  side_effects.push(value2);
                }
                value2 = null;
                trim_defns.push(def2);
              }
              var old_def;
              if (!value2 && !(node instanceof AST_Let)) {
                if (parent instanceof AST_ExportDeclaration) {
                  flush();
                } else if (drop_sym && var_defs[sym2.id] > 1) {
                  AST_Node.info("Dropping declaration of variable {name} [{file}:{line},{col}]", template(def2.name));
                  var_defs[sym2.id]--;
                  sym2.eliminated++;
                } else {
                  head.push(def2);
                }
              } else if (compressor.option("functions") && !compressor.option("ie") && drop_sym && var_defs[sym2.id] == 1 && sym2.assignments == 0 && value2 instanceof AST_LambdaExpression && !is_arguments(sym2) && !is_arrow(value2) && assigned_once(value2, sym2.references) && can_declare_defun(value2) && (old_def = rename_def(value2, def2.name.name)) !== false) {
                AST_Node.warn("Declaring {name} as function [{file}:{line},{col}]", template(def2.name));
                var ctor;
                switch (value2.CTOR) {
                  case AST_AsyncFunction:
                    ctor = AST_AsyncDefun;
                    break;
                  case AST_AsyncGeneratorFunction:
                    ctor = AST_AsyncGeneratorDefun;
                    break;
                  case AST_Function:
                    ctor = AST_Defun;
                    break;
                  case AST_GeneratorFunction:
                    ctor = AST_GeneratorDefun;
                    break;
                }
                var defun = make_node(ctor, def2, value2);
                defun.name = make_node(AST_SymbolDefun, def2.name, def2.name);
                var name_def = def2.name.scope.resolve().def_function(defun.name);
                if (old_def)
                  old_def.forEach(function(node2) {
                    node2.name = name_def.name;
                    node2.thedef = name_def;
                    node2.reference();
                  });
                body.push(defun);
              } else {
                if (drop_sym && var_defs[sym2.id] > 1 && !(parent instanceof AST_ExportDeclaration) && sym2.orig.indexOf(def2.name) > sym2.eliminated) {
                  var_defs[sym2.id]--;
                  duplicated++;
                }
                flush();
              }
            } else if (is_catch(def2.name)) {
              value2 = value2 && value2.drop_side_effect_free(compressor);
              if (value2)
                side_effects.push(value2);
              if (var_defs[sym2.id] > 1) {
                AST_Node.warn("Dropping duplicated declaration of variable {name} [{file}:{line},{col}]", template(def2.name));
                var_defs[sym2.id]--;
                sym2.eliminated++;
              } else {
                def2.value = null;
                head.push(def2);
              }
            } else {
              value2 = value2 && !value2.single_use && value2.drop_side_effect_free(compressor);
              if (value2) {
                AST_Node.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", template(def2.name));
                side_effects.push(value2);
              } else {
                log(def2.name, "Dropping unused variable {name}");
              }
              sym2.eliminated++;
            }
            function assigned_once(fn, refs) {
              if (refs.length == 0)
                return fn === def2.name.fixed_value();
              return all(refs, function(ref) {
                return fn === ref.fixed_value();
              });
            }
            function can_declare_defun(fn) {
              if (!is_var || compressor.has_directive("use strict") || !(fn instanceof AST_Function)) {
                return parent instanceof AST_Scope;
              }
              return parent instanceof AST_Block || parent instanceof AST_For && parent.init === node || parent instanceof AST_If;
            }
            function rename_def(fn, name) {
              if (!fn.name)
                return null;
              var def3 = fn.name.definition();
              if (def3.orig.length > 1)
                return null;
              if (def3.assignments > 0)
                return false;
              if (def3.name == name)
                return def3;
              var forbidden;
              switch (name) {
                case "await":
                  forbidden = is_async;
                  break;
                case "yield":
                  forbidden = is_generator;
                  break;
              }
              return all(def3.references, function(ref) {
                var scope2 = ref.scope;
                if (scope2.find_variable(name) !== sym2)
                  return false;
                if (forbidden)
                  do {
                    scope2 = scope2.resolve();
                    if (forbidden(scope2))
                      return false;
                  } while (scope2 !== fn && (scope2 = scope2.parent_scope));
                return true;
              }) && def3;
            }
            function is_catch(node2) {
              var sym3 = node2.definition();
              return sym3.orig[0] instanceof AST_SymbolCatch && sym3.scope.resolve() === node2.scope.resolve();
            }
            function flush() {
              if (side_effects.length > 0) {
                if (tail.length == 0) {
                  body.push(make_node(AST_SimpleStatement, node, {
                    body: make_sequence(node, side_effects)
                  }));
                } else if (value2) {
                  side_effects.push(value2);
                  def2.value = make_sequence(value2, side_effects);
                } else {
                  def2.value = make_node(AST_UnaryPrefix, def2, {
                    operator: "void",
                    expression: make_sequence(def2, side_effects)
                  });
                }
                side_effects = [];
              }
              tail.push(def2);
            }
          });
          switch (head.length) {
            case 0:
              if (tail.length == 0)
                break;
              if (tail.length == duplicated) {
                [].unshift.apply(side_effects, tail.map(function(def2) {
                  AST_Node.info("Dropping duplicated definition of variable {name} [{file}:{line},{col}]", template(def2.name));
                  var sym2 = def2.name.definition();
                  var ref = make_node(AST_SymbolRef, def2.name, def2.name);
                  sym2.references.push(ref);
                  var assign2 = make_node(AST_Assign, def2, {
                    operator: "=",
                    left: ref,
                    right: def2.value
                  });
                  var index = indexOf_assign(sym2, def2);
                  if (index >= 0)
                    assign_in_use[sym2.id][index] = assign2;
                  sym2.eliminated++;
                  return assign2;
                }));
                break;
              }
            case 1:
              if (tail.length == 0) {
                var id = head[0].name.definition().id;
                if (id in for_ins) {
                  node.definitions = head;
                  for_ins[id].init = node;
                  break;
                }
              }
            default:
              node.definitions = head.concat(tail);
              body.push(node);
          }
          if (side_effects.length > 0) {
            body.push(make_node(AST_SimpleStatement, node, {
              body: make_sequence(node, side_effects)
            }));
          }
          return insert_statements(body, node, in_list);
        }
        if (node instanceof AST_Assign) {
          descend(node, tt2);
          if (!(node.left instanceof AST_Destructured))
            return node;
          var trimmed = trim_destructured(node.left, node.right, function(node2) {
            return node2;
          }, node.write_only === true);
          if (trimmed.name)
            return make_node(AST_Assign, node, {
              operator: node.operator,
              left: trimmed.name,
              right: trimmed.value
            });
          if (trimmed.value)
            return trimmed.value;
          if (parent instanceof AST_Sequence && parent.tail_node() !== node)
            return List.skip;
          return make_node(AST_Number, node, { value: 0 });
        }
        if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {
          descend(node, tt2);
          if (node.body instanceof AST_BlockStatement) {
            var block = node.body;
            node.body = block.body.pop();
            block.body.push(node);
            return in_list ? List.splice(block.body) : block;
          }
          return node;
        }
        if (node instanceof AST_Scope) {
          descend_scope();
          return node;
        }
        if (node instanceof AST_SymbolImport) {
          if (!compressor.option("imports") || node.definition().id in in_use_ids)
            return node;
          return in_list ? List.skip : null;
        }
        function descend_scope() {
          var save_scope = scope;
          scope = node;
          descend(node, tt2);
          scope = save_scope;
        }
      }, function(node, in_list) {
        if (node instanceof AST_BlockStatement)
          return trim_block(node, tt2.parent(), in_list);
        if (node instanceof AST_For) {
          var block;
          if (node.init instanceof AST_BlockStatement) {
            block = node.init;
            node.init = block.body.pop();
            block.body.push(node);
          }
          if (node.init instanceof AST_Defun) {
            if (!block) {
              block = make_node(AST_BlockStatement, node, {
                body: [node]
              });
            }
            block.body.splice(-1, 0, node.init);
            node.init = null;
          } else if (node.init instanceof AST_SimpleStatement) {
            node.init = node.init.body;
          } else if (is_empty(node.init)) {
            node.init = null;
          }
          return !block ? node : in_list ? List.splice(block.body) : block;
        }
        if (node instanceof AST_ForIn) {
          if (!drop_vars || !compressor.option("loops"))
            return;
          if (!is_empty(node.body))
            return;
          var sym = get_init_symbol(node);
          if (!sym)
            return;
          var def = sym.definition();
          if (def.id in in_use_ids)
            return;
          log(sym, "Dropping unused loop variable {name}");
          if (for_ins[def.id] === node)
            delete for_ins[def.id];
          var body = [];
          var value = node.object.drop_side_effect_free(compressor);
          if (value) {
            AST_Node.warn("Side effects in object of for-in loop [{file}:{line},{col}]", value.start);
            body.push(make_node(AST_SimpleStatement, node, {
              body: value
            }));
          }
          if (node.init instanceof AST_Definitions && def.orig[0] instanceof AST_SymbolCatch) {
            body.push(node.init);
          }
          return insert_statements(body, node, in_list);
        }
        if (node instanceof AST_Import) {
          if (node.properties && node.properties.length == 0)
            node.properties = null;
          return node;
        }
        if (node instanceof AST_Sequence) {
          if (node.expressions.length > 1)
            return;
          return maintain_this_binding(compressor, tt2.parent(), node, node.expressions[0]);
        }
      });
      tt2.push(compressor.parent());
      self.transform(tt2);
      if (self instanceof AST_Lambda && self.body.length == 1 && self.body[0] instanceof AST_Directive && self.body[0].value == "use strict") {
        self.body.length = 0;
      }
      trim_defns.forEach(function(def) {
        def.value = null;
      });
      unused_fn_names.forEach(function(fn) {
        fn.name = null;
      });
      calls_to_drop_args.forEach(function(call) {
        drop_unused_call_args(call, compressor, fns_with_marked_args);
      });
      function log(sym, text) {
        AST_Node[sym.definition().references.length > 0 ? "info" : "warn"](text + " [{file}:{line},{col}]", template(sym));
      }
      function template(sym) {
        return {
          name: sym.name,
          file: sym.start.file,
          line: sym.start.line,
          col: sym.start.col
        };
      }
      function get_rvalue(expr) {
        return expr[expr instanceof AST_Assign ? "right" : "value"];
      }
      function insert_statements(body, orig, in_list) {
        switch (body.length) {
          case 0:
            return in_list ? List.skip : make_node(AST_EmptyStatement, orig);
          case 1:
            return body[0];
          default:
            return in_list ? List.splice(body) : make_node(AST_BlockStatement, orig, {
              body
            });
        }
      }
      function track_assigns(def, node) {
        if (def.scope.resolve() !== self)
          return false;
        if (!def.fixed || !node.fixed)
          assign_in_use[def.id] = false;
        return assign_in_use[def.id] !== false;
      }
      function add_assigns(def, node) {
        if (!assign_in_use[def.id])
          assign_in_use[def.id] = [];
        if (node.fixed.assigns)
          push_uniq(assign_in_use[def.id], node.fixed.assigns);
      }
      function indexOf_assign(def, node) {
        var nodes = assign_in_use[def.id];
        return nodes && nodes.indexOf(node);
      }
      function verify_safe_usage(def, read, modified) {
        if (def.id in in_use_ids)
          return;
        if (read && modified) {
          in_use_ids[def.id] = read;
          in_use.push(def);
        } else {
          value_read[def.id] = read;
          value_modified[def.id] = modified;
        }
      }
      function can_drop_lhs(sym, node) {
        var def = sym.definition();
        var in_use2 = in_use_ids[def.id];
        if (!in_use2)
          return true;
        if (node[node instanceof AST_Assign ? "left" : "expression"] !== sym)
          return false;
        return in_use2 === sym && def.references.length - def.replaced == 1 || indexOf_assign(def, node) < 0;
      }
      function get_rhs(assign) {
        var rhs = assign.right;
        if (!assign.write_only)
          return rhs;
        if (!(rhs instanceof AST_Binary && lazy_op[rhs.operator]))
          return rhs;
        if (!(rhs.left instanceof AST_SymbolRef))
          return rhs;
        if (!(assign.left instanceof AST_SymbolRef))
          return rhs;
        var def = assign.left.definition();
        if (rhs.left.definition() !== def)
          return rhs;
        if (rhs.right.has_side_effects(compressor))
          return rhs;
        if (track_assigns(def, rhs.left))
          add_assigns(def, rhs.left);
        return rhs.right;
      }
      function get_init_symbol(for_in) {
        var init2 = for_in.init;
        if (init2 instanceof AST_Definitions) {
          init2 = init2.definitions[0].name;
          return init2 instanceof AST_SymbolDeclaration && init2;
        }
        while (init2 instanceof AST_PropAccess)
          init2 = init2.expression.tail_node();
        if (init2 instanceof AST_SymbolRef)
          return init2;
      }
      function scan_ref_scoped(node, descend, init2) {
        if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) {
          var def = node.left.definition();
          if (def.scope.resolve() === self)
            assignments.add(def.id, node);
        }
        if (node instanceof AST_Unary && node.expression instanceof AST_SymbolRef) {
          var def = node.expression.definition();
          if (def.scope.resolve() === self)
            assignments.add(def.id, node);
        }
        var node_def, props = [], sym = assign_as_unused(node, props);
        if (sym && ((node_def = sym.definition()).scope.resolve() === self || self.variables.get(sym.name) === node_def) && !(is_arguments(node_def) && !all(self.argnames, function(argname) {
          return !argname.match_symbol(function(node2) {
            if (node2 instanceof AST_SymbolFunarg) {
              var def2 = node2.definition();
              return def2.references.length > def2.replaced;
            }
          }, true);
        }))) {
          if (node.write_only === "p" && node.right.may_throw_on_access(compressor, true))
            return;
          var assign = props.assign;
          if (assign) {
            assign.write_only = true;
            assign.walk(tw);
          }
          props.forEach(function(prop) {
            prop.walk(tw);
          });
          if (node instanceof AST_Assign) {
            var right = get_rhs(node), shared = false;
            if (init2 && node.write_only === true && !right.has_side_effects(compressor)) {
              initializations.add(node_def.id, right);
            } else {
              right.walk(tw);
              shared = right.tail_node().operator == "=";
            }
            if (node.left === sym) {
              if (!node.write_only || shared) {
                verify_safe_usage(node_def, sym, value_modified[node_def.id]);
              }
            } else {
              var fixed = sym.fixed_value();
              if (!fixed || !fixed.is_constant()) {
                verify_safe_usage(node_def, value_read[node_def.id], true);
              }
            }
          }
          if (track_assigns(node_def, sym) && is_lhs(sym, node) !== sym)
            add_assigns(node_def, sym);
          return true;
        }
        if (node instanceof AST_ForIn) {
          if (node.init instanceof AST_SymbolRef && scope === self) {
            var id = node.init.definition().id;
            if (!(id in for_ins))
              for_ins[id] = node;
          }
          if (!drop_vars || !compressor.option("loops"))
            return;
          if (!is_empty(node.body))
            return;
          if (node.init.has_side_effects(compressor))
            return;
          var sym = get_init_symbol(node);
          if (!sym)
            return;
          var def = sym.definition();
          if (def.scope.resolve() !== self) {
            var d2 = find_variable(sym.name);
            if (d2 === def || d2 && d2.redefined() === def)
              return;
          }
          node.object.walk(tw);
          return true;
        }
        if (node instanceof AST_SymbolRef) {
          node_def = node.definition();
          if (!(node_def.id in in_use_ids)) {
            in_use_ids[node_def.id] = true;
            in_use.push(node_def);
          }
          if (cross_scope(node_def.scope, node.scope)) {
            var redef = node_def.redefined();
            if (redef && !(redef.id in in_use_ids)) {
              in_use_ids[redef.id] = true;
              in_use.push(redef);
            }
          }
          if (track_assigns(node_def, node))
            add_assigns(node_def, node);
          return true;
        }
        if (node instanceof AST_Scope) {
          var save_scope = scope;
          scope = node;
          descend();
          scope = save_scope;
          return true;
        }
      }
      function is_decl(node) {
        return (node instanceof AST_DefaultValue ? node.name : node) instanceof AST_SymbolDeclaration;
      }
      function trim_default(trimmer2, node) {
        node.value = node.value.transform(tt2);
        var name = node.name.transform(trimmer2);
        if (!name) {
          if (node.name instanceof AST_Destructured)
            return null;
          var value = node.value.drop_side_effect_free(compressor);
          if (!value)
            return null;
          log(node.name, "Side effects in default value of unused variable {name}");
          node.name.__unused = null;
          node.value = value;
        }
        return node;
      }
      function trim_destructured(node, value, process2, drop) {
        var trimmer2 = new TreeTransformer(function(node2) {
          if (node2 instanceof AST_DefaultValue) {
            if (compressor.option("default_values") && value && value.is_defined(compressor)) {
              node2 = node2.name;
            } else {
              var save_drop = drop;
              drop = false;
              var trimmed = trim_default(trimmer2, node2);
              drop = save_drop;
              if (!trimmed && drop && value)
                value = value.drop_side_effect_free(compressor);
              return trimmed;
            }
          }
          if (node2 instanceof AST_DestructuredArray) {
            var save_drop = drop;
            var save_value = value;
            if (value instanceof AST_SymbolRef) {
              drop = false;
              value = value.fixed_value();
            }
            var values = value instanceof AST_Array && value.elements;
            var elements = [], newValues = drop && [], pos = 0;
            node2.elements.forEach(function(element, index) {
              value = values && values[index];
              if (value instanceof AST_Hole) {
                value = null;
              } else if (value instanceof AST_Spread) {
                if (drop) {
                  newValues.length = pos;
                  fill_holes(save_value, newValues);
                  [].push.apply(newValues, values.slice(index));
                  save_value.elements = newValues;
                }
                value = values = false;
              }
              element = element.transform(trimmer2);
              if (element)
                elements[pos] = element;
              if (drop && value)
                newValues[pos] = value;
              if (element || value || !drop || !values)
                pos++;
            });
            value = values && make_node(AST_Array, save_value, {
              elements: values.slice(node2.elements.length)
            });
            if (node2.rest) {
              var was_drop = drop;
              drop = false;
              node2.rest = node2.rest.transform(compressor.option("rests") ? trimmer2 : tt2);
              drop = was_drop;
              if (node2.rest)
                elements.length = pos;
            }
            if (drop) {
              if (value && !node2.rest)
                value = value.drop_side_effect_free(compressor);
              if (value instanceof AST_Array) {
                value = value.elements;
              } else if (value instanceof AST_Sequence) {
                value = value.expressions;
              } else if (value) {
                value = [value];
              }
              if (value && value.length) {
                newValues.length = pos;
                [].push.apply(newValues, value);
              }
            }
            value = save_value;
            drop = save_drop;
            if (values && newValues) {
              fill_holes(value, newValues);
              value.elements = newValues;
            }
            if (!node2.rest && (value instanceof AST_Array || value && value.is_string(compressor)))
              switch (elements.length) {
                case 0:
                  if (drop)
                    value = value.drop_side_effect_free(compressor);
                  return null;
                case 1:
                  if (!drop)
                    break;
                  var sym = elements[0];
                  if (!(sym instanceof AST_Symbol))
                    break;
                  value = make_node(AST_Sub, node2, {
                    expression: value,
                    property: make_node(AST_Number, node2, { value: 0 })
                  });
                  return sym;
              }
            fill_holes(node2, elements);
            node2.elements = elements;
            return node2;
          }
          if (node2 instanceof AST_DestructuredObject) {
            var save_drop = drop;
            var save_value = value;
            if (value instanceof AST_SymbolRef) {
              drop = false;
              value = value.fixed_value();
            }
            var prop_keys, prop_map;
            if (value instanceof AST_Object) {
              prop_keys = [];
              prop_map = Object.create(null);
              value.properties.forEach(function(prop2, index) {
                if (prop2 instanceof AST_Spread)
                  return prop_map = false;
                var key = prop2.key;
                if (key instanceof AST_Node)
                  key = key.evaluate(compressor, true);
                if (key instanceof AST_Node) {
                  prop_map = false;
                } else if (prop_map && !(prop2 instanceof AST_ObjectSetter)) {
                  prop_map[key] = prop2;
                }
                prop_keys[index] = key;
              });
            }
            if (node2.rest) {
              value = false;
              node2.rest = node2.rest.transform(compressor.option("rests") ? trimmer2 : tt2);
            }
            var can_drop = Object.create(null);
            var drop_keys = drop && Object.create(null);
            var properties = [];
            node2.properties.map(function(prop2) {
              var key = prop2.key;
              if (key instanceof AST_Node) {
                prop2.key = key = key.transform(tt2);
                key = key.evaluate(compressor, true);
              }
              if (key instanceof AST_Node) {
                drop_keys = false;
              } else {
                can_drop[key] = !(key in can_drop);
              }
              return key;
            }).forEach(function(key, index) {
              var prop2 = node2.properties[index], trimmed2;
              if (key instanceof AST_Node) {
                drop = false;
                value = false;
                trimmed2 = prop2.value.transform(trimmer2) || retain_lhs(prop2.value);
              } else {
                drop = drop_keys && can_drop[key];
                var mapped = prop_map && prop_map[key];
                if (mapped) {
                  value = mapped.value;
                  if (value instanceof AST_Accessor)
                    value = false;
                } else {
                  value = false;
                }
                trimmed2 = prop2.value.transform(trimmer2);
                if (!trimmed2) {
                  if (node2.rest || retain_key(prop2))
                    trimmed2 = retain_lhs(prop2.value);
                  if (drop_keys && !(key in drop_keys)) {
                    if (mapped) {
                      drop_keys[key] = mapped;
                      if (value === null) {
                        prop_map[key] = retain_key(mapped) && make_node(AST_ObjectKeyVal, mapped, {
                          key: mapped.key,
                          value: make_node(AST_Number, mapped, { value: 0 })
                        });
                      }
                    } else {
                      drop_keys[key] = true;
                    }
                  }
                } else if (drop_keys) {
                  drop_keys[key] = false;
                }
                if (value)
                  mapped.value = value;
              }
              if (trimmed2) {
                prop2.value = trimmed2;
                properties.push(prop2);
              }
            });
            value = save_value;
            drop = save_drop;
            if (drop_keys && prop_keys)
              value.properties = List(value.properties, function(prop2, index) {
                if (prop2 instanceof AST_Spread)
                  return prop2;
                var key = prop_keys[index];
                if (key instanceof AST_Node)
                  return prop2;
                if (key in drop_keys) {
                  var mapped = drop_keys[key];
                  if (!mapped)
                    return prop2;
                  if (mapped === prop2)
                    return prop_map[key] || List.skip;
                } else if (node2.rest) {
                  return prop2;
                }
                var trimmed2 = prop2.value.drop_side_effect_free(compressor);
                if (trimmed2) {
                  prop2.value = trimmed2;
                  return prop2;
                }
                return retain_key(prop2) ? make_node(AST_ObjectKeyVal, prop2, {
                  key: prop2.key,
                  value: make_node(AST_Number, prop2, { value: 0 })
                }) : List.skip;
              });
            if (value && !node2.rest)
              switch (properties.length) {
                case 0:
                  if (value.may_throw_on_access(compressor, true))
                    break;
                  if (drop)
                    value = value.drop_side_effect_free(compressor);
                  return null;
                case 1:
                  if (!drop)
                    break;
                  var prop = properties[0];
                  if (prop.key instanceof AST_Node)
                    break;
                  if (!(prop.value instanceof AST_Symbol))
                    break;
                  value = make_node(AST_Sub, node2, {
                    expression: value,
                    property: make_node_from_constant(prop.key, prop)
                  });
                  return prop.value;
              }
            node2.properties = properties;
            return node2;
          }
          if (node2 instanceof AST_Hole) {
            node2 = null;
          } else {
            node2 = process2(node2);
          }
          if (!node2 && drop && value)
            value = value.drop_side_effect_free(compressor);
          return node2;
        });
        return {
          name: node.transform(trimmer2),
          value
        };
        function retain_key(prop) {
          return prop.key instanceof AST_Node && prop.key.has_side_effects(compressor);
        }
        function retain_lhs(node2) {
          if (node2 instanceof AST_DefaultValue)
            return retain_lhs(node2.name);
          if (node2 instanceof AST_Destructured) {
            if (value === null) {
              value = make_node(AST_Number, node2, { value: 0 });
            } else if (value && (value.tail_node().write_only === true || value.may_throw_on_access(compressor, true))) {
              value = make_node(AST_Array, node2, {
                elements: value instanceof AST_Sequence ? value.expressions : [value]
              });
            }
            return make_node(AST_DestructuredObject, node2, { properties: [] });
          }
          node2.__unused = null;
          return node2;
        }
      }
    });
    AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
      if (compressor.has_directive("use asm"))
        return;
      var hoist_funs = compressor.option("hoist_funs");
      var hoist_vars = compressor.option("hoist_vars");
      var self = this;
      if (hoist_vars) {
        var var_decl = 0;
        self.walk(new TreeWalker(function(node) {
          if (var_decl > 1)
            return true;
          if (node instanceof AST_ExportDeclaration)
            return true;
          if (node instanceof AST_Scope && node !== self)
            return true;
          if (node instanceof AST_Var) {
            var_decl++;
            return true;
          }
        }));
        if (var_decl <= 1)
          hoist_vars = false;
      }
      if (!hoist_funs && !hoist_vars)
        return;
      var consts = Object.create(null);
      var dirs = [];
      var hoisted = [];
      var vars = new Dictionary, vars_found = 0;
      var tt2 = new TreeTransformer(function(node, descend, in_list) {
        if (node === self)
          return;
        if (node instanceof AST_Directive) {
          dirs.push(node);
          return in_list ? List.skip : make_node(AST_EmptyStatement, node);
        }
        if (node instanceof AST_LambdaDefinition) {
          if (!hoist_funs)
            return node;
          var p2 = tt2.parent();
          if (p2 instanceof AST_ExportDeclaration)
            return node;
          if (p2 instanceof AST_ExportDefault)
            return node;
          if (p2 !== self && compressor.has_directive("use strict"))
            return node;
          hoisted.push(node);
          return in_list ? List.skip : make_node(AST_EmptyStatement, node);
        }
        if (node instanceof AST_Var) {
          if (!hoist_vars)
            return node;
          var p2 = tt2.parent();
          if (p2 instanceof AST_ExportDeclaration)
            return node;
          if (!all(node.definitions, function(defn) {
            var sym = defn.name;
            return sym instanceof AST_SymbolVar && !consts[sym.name] && self.find_variable(sym.name) === sym.definition();
          }))
            return node;
          node.definitions.forEach(function(def2) {
            vars.set(def2.name.name, def2);
            ++vars_found;
          });
          var seq = node.to_assignments();
          if (p2 instanceof AST_ForEnumeration && p2.init === node) {
            if (seq)
              return seq;
            var def = node.definitions[0].name;
            return make_node(AST_SymbolRef, def, def);
          }
          if (p2 instanceof AST_For && p2.init === node)
            return seq;
          if (!seq)
            return in_list ? List.skip : make_node(AST_EmptyStatement, node);
          return make_node(AST_SimpleStatement, node, { body: seq });
        }
        if (node instanceof AST_Scope)
          return node;
        if (node instanceof AST_SymbolConst) {
          consts[node.name] = true;
          return node;
        }
      });
      self.transform(tt2);
      if (vars_found > 0) {
        var defs = [];
        if (self instanceof AST_Lambda)
          self.each_argname(function(argname) {
            vars.del(argname.name);
          });
        vars.each(function(def, name) {
          def = def.clone();
          def.value = null;
          defs.push(def);
          vars.set(name, def);
        });
        if (defs.length > 0) {
          insert_vars(self.body);
          defs = make_node(AST_Var, self, { definitions: defs });
          hoisted.push(defs);
        }
      }
      self.body = dirs.concat(hoisted, self.body);
      function insert_vars(body) {
        while (body.length) {
          var stat = body[0];
          if (stat instanceof AST_SimpleStatement) {
            var expr = stat.body, sym, assign;
            if (expr instanceof AST_Assign && expr.operator == "=" && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {
              var def = vars.get(sym.name);
              if (def.value)
                break;
              var value = expr.right;
              if (value instanceof AST_Sequence)
                value = value.clone();
              def.value = value;
              remove(defs, def);
              defs.push(def);
              body.shift();
              continue;
            }
            if (expr instanceof AST_Sequence && (assign = expr.expressions[0]) instanceof AST_Assign && assign.operator == "=" && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {
              var def = vars.get(sym.name);
              if (def.value)
                break;
              def.value = assign.right;
              remove(defs, def);
              defs.push(def);
              stat.body = make_sequence(expr, expr.expressions.slice(1));
              continue;
            }
          }
          if (stat instanceof AST_EmptyStatement) {
            body.shift();
            continue;
          }
          if (stat instanceof AST_BlockStatement && !insert_vars(stat.body)) {
            body.shift();
            continue;
          }
          break;
        }
        return body.length;
      }
    });
    function scan_local_returns(fn, transform) {
      fn.walk(new TreeWalker(function(node) {
        if (node instanceof AST_Return) {
          transform(node);
          return true;
        }
        if (node instanceof AST_Scope && node !== fn)
          return true;
      }));
    }
    function map_bool_returns(fn) {
      var map = Object.create(null);
      scan_local_returns(fn, function(node) {
        var value = node.value;
        if (value)
          value = value.tail_node();
        if (value instanceof AST_SymbolRef) {
          var id = value.definition().id;
          map[id] = (map[id] || 0) + 1;
        }
      });
      return map;
    }
    function all_bool(def, bool_returns, compressor) {
      return def.bool_fn + (bool_returns[def.id] || 0) === def.references.length - def.replaced && !compressor.exposed(def);
    }
    function process_boolean_returns(fn, compressor) {
      scan_local_returns(fn, function(node) {
        node.in_bool = true;
        var value = node.value;
        if (value) {
          var ev = fuzzy_eval(compressor, value);
          if (!ev) {
            value = value.drop_side_effect_free(compressor);
            node.value = value ? make_sequence(node.value, [
              value,
              make_node(AST_Number, node.value, { value: 0 })
            ]) : null;
          } else if (!(ev instanceof AST_Node)) {
            value = value.drop_side_effect_free(compressor);
            node.value = value ? make_sequence(node.value, [
              value,
              make_node(AST_Number, node.value, { value: 1 })
            ]) : make_node(AST_Number, node.value, { value: 1 });
          }
        }
      });
    }
    AST_Scope.DEFMETHOD("process_boolean_returns", noop);
    AST_Defun.DEFMETHOD("process_boolean_returns", function(compressor) {
      if (!compressor.option("booleans"))
        return;
      var bool_returns = map_bool_returns(this);
      if (!all_bool(this.name.definition(), bool_returns, compressor))
        return;
      if (compressor.parent() instanceof AST_ExportDefault)
        return;
      process_boolean_returns(this, compressor);
    });
    AST_Function.DEFMETHOD("process_boolean_returns", function(compressor) {
      if (!compressor.option("booleans"))
        return;
      var bool_returns = map_bool_returns(this);
      if (this.name && !all_bool(this.name.definition(), bool_returns, compressor))
        return;
      var parent = compressor.parent();
      if (parent instanceof AST_Assign) {
        if (parent.operator != "=")
          return;
        var sym = parent.left;
        if (!(sym instanceof AST_SymbolRef))
          return;
        if (!all_bool(sym.definition(), bool_returns, compressor))
          return;
      } else if (parent instanceof AST_Call && parent.expression !== this) {
        var exp = parent.expression;
        if (exp instanceof AST_SymbolRef)
          exp = exp.fixed_value();
        if (!(exp instanceof AST_Lambda))
          return;
        if (exp.uses_arguments || exp.pinned())
          return;
        var sym = exp.argnames[parent.args.indexOf(this)];
        if (sym instanceof AST_DefaultValue)
          sym = sym.name;
        if (sym instanceof AST_SymbolFunarg && !all_bool(sym.definition(), bool_returns, compressor))
          return;
      } else if (parent.TYPE == "Call") {
        compressor.pop();
        var in_bool = compressor.in_boolean_context();
        compressor.push(this);
        if (!in_bool)
          return;
      } else
        return;
      process_boolean_returns(this, compressor);
    });
    AST_BlockScope.DEFMETHOD("var_names", function() {
      var var_names = this._var_names;
      if (!var_names) {
        this._var_names = var_names = Object.create(null);
        this.enclosed.forEach(function(def) {
          var_names[def.name] = true;
        });
        this.variables.each(function(def, name) {
          var_names[name] = true;
        });
      }
      return var_names;
    });
    AST_Scope.DEFMETHOD("make_var", function(type, orig, prefix) {
      var scopes = [this];
      if (orig instanceof AST_SymbolDeclaration)
        orig.definition().references.forEach(function(ref) {
          var s2 = ref.scope;
          if (member(s2, scopes))
            return;
          do {
            push_uniq(scopes, s2);
            s2 = s2.parent_scope;
          } while (s2 && s2 !== this);
        });
      prefix = prefix.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, "_");
      var name = prefix;
      for (var i = 0;!all(scopes, function(scope) {
        return !scope.var_names()[name];
      }); i++)
        name = prefix + "$" + i;
      var sym = make_node(type, orig, {
        name,
        scope: this
      });
      var def = this.def_variable(sym);
      scopes.forEach(function(scope) {
        scope.enclosed.push(def);
        scope.var_names()[name] = true;
      });
      return sym;
    });
    AST_Scope.DEFMETHOD("hoist_properties", function(compressor) {
      if (!compressor.option("hoist_props") || compressor.has_directive("use asm"))
        return;
      var self = this;
      var top_retain = self instanceof AST_Toplevel && compressor.top_retain || return_false;
      var defs_by_id = Object.create(null);
      self.transform(new TreeTransformer(function(node, descend) {
        if (node instanceof AST_Assign) {
          if (node.operator != "=")
            return;
          if (!node.write_only)
            return;
          if (!can_hoist(node.left, node.right, 1))
            return;
          descend(node, this);
          var defs = new Dictionary;
          var assignments = [];
          var decls = [];
          node.right.properties.forEach(function(prop) {
            var decl = make_sym(AST_SymbolVar, node.left, prop.key);
            decls.push(make_node(AST_VarDef, node, {
              name: decl,
              value: null
            }));
            var sym = make_node(AST_SymbolRef, node, {
              name: decl.name,
              scope: self,
              thedef: decl.definition()
            });
            sym.reference();
            assignments.push(make_node(AST_Assign, node, {
              operator: "=",
              left: sym,
              right: prop.value
            }));
          });
          defs_by_id[node.left.definition().id] = defs;
          self.body.splice(self.body.indexOf(this.stack[1]) + 1, 0, make_node(AST_Var, node, {
            definitions: decls
          }));
          return make_sequence(node, assignments);
        }
        if (node instanceof AST_Scope)
          return node === self ? undefined : node;
        if (node instanceof AST_VarDef) {
          if (!can_hoist(node.name, node.value, 0))
            return;
          descend(node, this);
          var defs = new Dictionary;
          var var_defs = [];
          node.value.properties.forEach(function(prop) {
            var_defs.push(make_node(AST_VarDef, node, {
              name: make_sym(node.name.CTOR, node.name, prop.key),
              value: prop.value
            }));
          });
          defs_by_id[node.name.definition().id] = defs;
          return List.splice(var_defs);
        }
        function make_sym(type, sym, key) {
          var new_var = self.make_var(type, sym, sym.name + "_" + key);
          defs.set(key, new_var.definition());
          return new_var;
        }
      }));
      self.transform(new TreeTransformer(function(node, descend) {
        if (node instanceof AST_PropAccess) {
          if (!(node.expression instanceof AST_SymbolRef))
            return;
          var defs = defs_by_id[node.expression.definition().id];
          if (!defs)
            return;
          var def = defs.get(node.get_property());
          var sym = make_node(AST_SymbolRef, node, {
            name: def.name,
            scope: node.expression.scope,
            thedef: def
          });
          sym.reference();
          return sym;
        }
        if (node instanceof AST_SymbolRef) {
          if (!(node.definition().id in defs_by_id))
            return;
          return make_node(AST_Object, node, { properties: [] });
        }
      }));
      function can_hoist(sym, right, count) {
        if (!(sym instanceof AST_Symbol))
          return;
        var def = sym.definition();
        if (def.assignments != count)
          return;
        if (def.direct_access)
          return;
        if (def.escaped.depth == 1)
          return;
        if (def.references.length - def.replaced == count)
          return;
        if (def.single_use)
          return;
        if (top_retain(def))
          return;
        if (sym.fixed_value() !== right)
          return;
        return right instanceof AST_Object && right.properties.length > 0 && all(right.properties, can_hoist_property) && all(def.references, function(ref) {
          return ref.fixed_value() === right;
        }) && can_drop_symbol(sym, compressor);
      }
    });
    function fn_name_unused(fn, compressor) {
      if (!fn.name || !compressor.option("ie"))
        return true;
      var def = fn.name.definition();
      if (compressor.exposed(def))
        return false;
      return all(def.references, function(sym) {
        return !(sym instanceof AST_SymbolRef);
      });
    }
    (function(def) {
      function trim(nodes, compressor, first_in_statement2, spread) {
        var len = nodes.length;
        var ret = [], changed = false;
        for (var i = 0;i < len; i++) {
          var node = nodes[i];
          var trimmed;
          if (spread && node instanceof AST_Spread) {
            trimmed = spread(node, compressor, first_in_statement2);
          } else {
            trimmed = node.drop_side_effect_free(compressor, first_in_statement2);
          }
          if (trimmed !== node)
            changed = true;
          if (trimmed) {
            ret.push(trimmed);
            first_in_statement2 = false;
          }
        }
        return ret.length ? changed ? ret : nodes : null;
      }
      function array_spread(node, compressor, first_in_statement2) {
        var exp = node.expression;
        if (!exp.is_string(compressor))
          return node;
        return exp.drop_side_effect_free(compressor, first_in_statement2);
      }
      function convert_spread(node) {
        return node instanceof AST_Spread ? make_node(AST_Array, node, {
          elements: [node]
        }) : node;
      }
      def(AST_Node, return_this);
      def(AST_Accessor, return_null);
      def(AST_Array, function(compressor, first_in_statement2) {
        var values = trim(this.elements, compressor, first_in_statement2, array_spread);
        if (!values)
          return null;
        if (values === this.elements && all(values, function(node) {
          return node instanceof AST_Spread;
        }))
          return this;
        return make_sequence(this, values.map(convert_spread));
      });
      def(AST_Assign, function(compressor) {
        var left = this.left;
        if (left instanceof AST_PropAccess) {
          var expr = left.expression;
          if (expr.may_throw_on_access(compressor, true))
            return this;
          if (compressor.has_directive("use strict") && expr.is_constant())
            return this;
        }
        if (left.has_side_effects(compressor))
          return this;
        var right = this.right;
        if (!lazy_op[this.operator.slice(0, -1)]) {
          this.write_only = true;
          if (root_expr(left).is_constant_expression(compressor.find_parent(AST_Scope))) {
            return right.drop_side_effect_free(compressor);
          }
        }
        return this;
      });
      def(AST_Await, function(compressor) {
        if (!compressor.option("awaits"))
          return this;
        var exp = this.expression;
        if (!is_primitive(compressor, exp))
          return this;
        var node = this.clone();
        node.expression = exp.drop_side_effect_free(compressor) || make_node(AST_Number, this, { value: 0 });
        return node;
      });
      def(AST_Binary, function(compressor, first_in_statement2) {
        var left = this.left;
        var right = this.right;
        var op = this.operator;
        if (op == "in" && !is_object(right)) {
          var lhs = left.drop_side_effect_free(compressor, first_in_statement2);
          if (lhs === left)
            return this;
          var node = this.clone();
          node.left = lhs || make_node(AST_Number, left, { value: 0 });
          return node;
        }
        var rhs = right.drop_side_effect_free(compressor, first_in_statement2);
        if (!rhs)
          return left.drop_side_effect_free(compressor, first_in_statement2);
        if (lazy_op[op] && rhs.has_side_effects(compressor)) {
          var node = this;
          if (rhs !== right) {
            node = node.clone();
            node.right = rhs.drop_side_effect_free(compressor);
          }
          if (op == "??")
            return node;
          var negated = make_node(AST_Binary, this, {
            operator: op == "&&" ? "||" : "&&",
            left: left.negate(compressor, first_in_statement2),
            right: node.right
          });
          return first_in_statement2 ? best_of_statement(node, negated) : best_of_expression(node, negated);
        }
        var lhs = left.drop_side_effect_free(compressor, first_in_statement2);
        if (!lhs)
          return rhs;
        rhs = rhs.drop_side_effect_free(compressor);
        if (!rhs)
          return lhs;
        return make_sequence(this, [lhs, rhs]);
      });
      function drop_returns(compressor, exp) {
        var arrow = is_arrow(exp);
        var async = is_async(exp);
        var drop_body = false;
        if (arrow && compressor.option("arrows")) {
          if (!exp.value) {
            drop_body = true;
          } else if (!async || is_primitive(compressor, exp.value)) {
            exp.value = exp.value.drop_side_effect_free(compressor);
          }
        } else if (exp instanceof AST_AsyncFunction || exp instanceof AST_Function) {
          if (exp.name) {
            var def2 = exp.name.definition();
            drop_body = def2.references.length == def2.replaced;
          } else {
            drop_body = true;
          }
        }
        if (drop_body) {
          exp.process_expression(false, function(node) {
            var value = node.value;
            if (value) {
              if (async && !is_primitive(compressor, value))
                return node;
              value = value.drop_side_effect_free(compressor, true);
            }
            if (!value)
              return make_node(AST_EmptyStatement, node);
            return make_node(AST_SimpleStatement, node, { body: value });
          });
          scan_local_returns(exp, function(node) {
            var value = node.value;
            if (value) {
              if (async && !is_primitive(compressor, value))
                return;
              node.value = value.drop_side_effect_free(compressor);
            }
          });
        }
        if (async && compressor.option("awaits")) {
          if (drop_body)
            exp.process_expression("awaits", function(node) {
              var body = node.body;
              if (body instanceof AST_Await) {
                if (is_primitive(compressor, body.expression)) {
                  body = body.expression.drop_side_effect_free(compressor, true);
                  if (!body)
                    return make_node(AST_EmptyStatement, node);
                  node.body = body;
                }
              } else if (body instanceof AST_Sequence) {
                var exprs = body.expressions;
                for (var i = exprs.length;--i >= 0; ) {
                  var tail = exprs[i];
                  if (!(tail instanceof AST_Await))
                    break;
                  if (!is_primitive(compressor, tail.expression))
                    break;
                  if (exprs[i] = tail.expression.drop_side_effect_free(compressor))
                    break;
                }
                switch (i) {
                  case -1:
                    return make_node(AST_EmptyStatement, node);
                  case 0:
                    node.body = exprs[0];
                    break;
                  default:
                    exprs.length = i + 1;
                    break;
                }
              }
              return node;
            });
          var abort = !drop_body && exp.name || arrow && exp.value && !is_primitive(compressor, exp.value);
          var tw = new TreeWalker(function(node) {
            if (abort)
              return true;
            if (tw.parent() === exp && node.may_throw(compressor))
              return abort = true;
            if (node instanceof AST_Await)
              return abort = true;
            if (node instanceof AST_ForAwaitOf)
              return abort = true;
            if (node instanceof AST_Return) {
              if (node.value && !is_primitive(compressor, node.value))
                return abort = true;
              return;
            }
            if (node instanceof AST_Scope && node !== exp)
              return true;
          });
          exp.walk(tw);
          if (!abort) {
            var ctor;
            switch (exp.CTOR) {
              case AST_AsyncArrow:
                ctor = AST_Arrow;
                break;
              case AST_AsyncFunction:
                ctor = AST_Function;
                break;
              case AST_AsyncGeneratorFunction:
                ctor = AST_GeneratorFunction;
                break;
            }
            return make_node(ctor, exp, exp);
          }
        }
        return drop_body && exp.clone();
      }
      def(AST_Call, function(compressor, first_in_statement2) {
        var self = this;
        if (self.is_expr_pure(compressor)) {
          if (self.pure)
            AST_Node.warn("Dropping __PURE__ call [{file}:{line},{col}]", self.start);
          var args = trim(self.args, compressor, first_in_statement2, array_spread);
          return args && make_sequence(self, args.map(convert_spread));
        }
        var exp = self.expression;
        if (self.is_call_pure(compressor)) {
          var exprs = self.args.slice();
          exprs.unshift(exp.expression);
          exprs = trim(exprs, compressor, first_in_statement2, array_spread);
          return exprs && make_sequence(self, exprs.map(convert_spread));
        }
        if (compressor.option("yields") && is_generator(exp)) {
          var call = self.clone();
          call.expression = make_node(AST_Function, exp, exp);
          call.expression.body = [];
          var opt = call.transform(compressor);
          if (opt !== call)
            return opt.drop_side_effect_free(compressor, first_in_statement2);
        }
        var dropped = drop_returns(compressor, exp);
        if (dropped) {
          self = self.clone();
          self.expression = dropped;
          if (exp._squeezed)
            self.expression._squeezed = true;
        }
        if (self instanceof AST_New) {
          var fn = exp;
          if (fn instanceof AST_SymbolRef)
            fn = fn.fixed_value();
          if (fn instanceof AST_Lambda) {
            if (assign_this_only(fn, compressor)) {
              var exprs = self.args.slice();
              exprs.unshift(exp);
              exprs = trim(exprs, compressor, first_in_statement2, array_spread);
              return exprs && make_sequence(self, exprs.map(convert_spread));
            }
            if (!fn.contains_this())
              self = make_node(AST_Call, self, self);
          }
        }
        self.call_only = true;
        return self;
      });
      function assign_this_only(fn, compressor) {
        fn.new = true;
        var result = all(fn.body, function(stat) {
          return !stat.has_side_effects(compressor);
        }) && all(fn.argnames, function(argname) {
          return !argname.match_symbol(return_false);
        }) && !(fn.rest && fn.rest.match_symbol(return_false));
        delete fn.new;
        return result;
      }
      function drop_class(self, compressor, first_in_statement2) {
        var exprs = [], values = [];
        var props = self.properties;
        for (var i = 0;i < props.length; i++) {
          var prop = props[i];
          if (prop.key instanceof AST_Node)
            exprs.push(prop.key);
          if (prop.static && prop.value && prop instanceof AST_ClassField && prop.value.has_side_effects(compressor)) {
            if (prop.value.contains_this())
              return self;
            values.push(prop.value);
          }
        }
        var base = self.extends;
        if (base) {
          if (base instanceof AST_SymbolRef)
            base = base.fixed_value();
          base = !safe_for_extends(base);
          if (!base)
            exprs.unshift(self.extends);
        }
        exprs = trim(exprs, compressor, first_in_statement2);
        if (exprs)
          first_in_statement2 = false;
        values = trim(values, compressor, first_in_statement2);
        if (!exprs) {
          if (!base && !values)
            return null;
          exprs = [];
        }
        if (base) {
          var node = to_class_expr(self, true);
          node.properties = [];
          if (exprs.length)
            node.properties.push(make_node(AST_ClassMethod, self, {
              key: make_sequence(self, exprs),
              value: make_node(AST_Function, self, {
                argnames: [],
                body: []
              }).init_vars(node)
            }));
          exprs = [node];
        }
        if (values)
          exprs.push(make_node(AST_Call, self, {
            expression: make_node(AST_Arrow, self, {
              argnames: [],
              body: [],
              value: make_sequence(self, values)
            }).init_vars(self.parent_scope),
            args: []
          }));
        return make_sequence(self, exprs);
      }
      def(AST_ClassExpression, function(compressor, first_in_statement2) {
        var self = this;
        var name = self.name;
        if (name && name.fixed_value() !== self && name.definition().references.length > 0)
          return self;
        return drop_class(self, compressor, first_in_statement2);
      });
      def(AST_Conditional, function(compressor) {
        var consequent = this.consequent.drop_side_effect_free(compressor);
        var alternative = this.alternative.drop_side_effect_free(compressor);
        if (consequent === this.consequent && alternative === this.alternative)
          return this;
        var exprs;
        if (compressor.option("ie")) {
          exprs = [];
          if (consequent instanceof AST_Function) {
            exprs.push(consequent);
            consequent = null;
          }
          if (alternative instanceof AST_Function) {
            exprs.push(alternative);
            alternative = null;
          }
        }
        var node;
        if (!consequent) {
          node = alternative ? make_node(AST_Binary, this, {
            operator: "||",
            left: this.condition,
            right: alternative
          }) : this.condition.drop_side_effect_free(compressor);
        } else if (!alternative) {
          node = make_node(AST_Binary, this, {
            operator: "&&",
            left: this.condition,
            right: consequent
          });
        } else {
          node = this.clone();
          node.consequent = consequent;
          node.alternative = alternative;
        }
        if (!compressor.option("ie"))
          return node;
        if (node)
          exprs.push(node);
        return exprs.length == 0 ? null : make_sequence(this, exprs);
      });
      def(AST_Constant, return_null);
      def(AST_DefClass, function(compressor, first_in_statement2) {
        return drop_class(this, compressor, first_in_statement2);
      });
      def(AST_Dot, function(compressor, first_in_statement2) {
        var expr = this.expression;
        if (!this.optional && expr.may_throw_on_access(compressor))
          return this;
        return expr.drop_side_effect_free(compressor, first_in_statement2);
      });
      def(AST_Function, function(compressor) {
        return fn_name_unused(this, compressor) ? null : this;
      });
      def(AST_LambdaExpression, return_null);
      def(AST_Object, function(compressor, first_in_statement2) {
        var exprs = [];
        this.properties.forEach(function(prop) {
          if (prop instanceof AST_Spread) {
            exprs.push(prop);
          } else {
            if (prop.key instanceof AST_Node)
              exprs.push(prop.key);
            exprs.push(prop.value);
          }
        });
        var values = trim(exprs, compressor, first_in_statement2, function(node, compressor2, first_in_statement3) {
          var exp = node.expression;
          return spread_side_effects(exp) ? node : exp.drop_side_effect_free(compressor2, first_in_statement3);
        });
        if (!values)
          return null;
        if (values === exprs && !all(values, function(node) {
          return !(node instanceof AST_Spread);
        }))
          return this;
        return make_sequence(this, values.map(function(node) {
          return node instanceof AST_Spread ? make_node(AST_Object, node, {
            properties: [node]
          }) : node;
        }));
      });
      def(AST_ObjectIdentity, return_null);
      def(AST_Sequence, function(compressor, first_in_statement2) {
        var expressions = trim(this.expressions, compressor, first_in_statement2);
        if (!expressions)
          return null;
        var end = expressions.length - 1;
        var last = expressions[end];
        if (compressor.option("awaits") && end > 0 && last instanceof AST_Await && last.expression.is_constant()) {
          expressions = expressions.slice(0, -1);
          end--;
          last.expression = expressions[end];
          expressions[end] = last;
        }
        var assign, cond, lhs;
        if (compressor.option("conditionals") && end > 0 && (assign = expressions[end - 1]) instanceof AST_Assign && assign.operator == "=" && (lhs = assign.left) instanceof AST_SymbolRef && (cond = to_conditional_assignment(compressor, lhs.definition(), assign.right, last))) {
          assign = assign.clone();
          assign.right = cond;
          expressions = expressions.slice(0, -2);
          expressions.push(assign.drop_side_effect_free(compressor, first_in_statement2));
        }
        return expressions === this.expressions ? this : make_sequence(this, expressions);
      });
      def(AST_Sub, function(compressor, first_in_statement2) {
        var expr = this.expression;
        var prop = this.property;
        if (expr.may_throw_on_access(compressor)) {
          if (!this.optional)
            return this;
          if (prop.has_side_effects(compressor)) {
            prop = prop.drop_side_effect_free(compressor);
            if (!prop)
              return expr.drop_side_effect_free(compressor, first_in_statement2);
            var node = this.clone();
            node.property = prop;
            return node;
          }
        }
        expr = expr.drop_side_effect_free(compressor, first_in_statement2);
        if (!expr)
          return prop.drop_side_effect_free(compressor, first_in_statement2);
        prop = prop.drop_side_effect_free(compressor);
        if (!prop)
          return expr;
        return make_sequence(this, [expr, prop]);
      });
      def(AST_SymbolRef, function(compressor) {
        return this.is_declared(compressor) && can_drop_symbol(this, compressor) ? null : this;
      });
      def(AST_Template, function(compressor, first_in_statement2) {
        var self = this;
        if (self.is_expr_pure(compressor)) {
          var expressions = self.expressions;
          if (expressions.length == 0)
            return null;
          return make_sequence(self, expressions).drop_side_effect_free(compressor, first_in_statement2);
        }
        var tag = self.tag;
        var dropped = drop_returns(compressor, tag);
        if (dropped) {
          self = self.clone();
          self.tag = dropped;
          if (tag._squeezed)
            self.tag._squeezed = true;
        }
        return self;
      });
      def(AST_Unary, function(compressor, first_in_statement2) {
        var exp = this.expression;
        if (unary_side_effects[this.operator]) {
          this.write_only = !exp.has_side_effects(compressor);
          return this;
        }
        if (this.operator == "typeof" && exp instanceof AST_SymbolRef && can_drop_symbol(exp, compressor)) {
          return null;
        }
        var node = exp.drop_side_effect_free(compressor, first_in_statement2);
        if (first_in_statement2 && node && is_iife_call(node)) {
          if (node === exp && this.operator == "!")
            return this;
          return node.negate(compressor, first_in_statement2);
        }
        return node;
      });
    })(function(node, func) {
      node.DEFMETHOD("drop_side_effect_free", func);
    });
    OPT(AST_SimpleStatement, function(self, compressor) {
      if (compressor.option("side_effects")) {
        var body = self.body;
        var node = body.drop_side_effect_free(compressor, true);
        if (!node) {
          AST_Node.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
          return make_node(AST_EmptyStatement, self);
        }
        if (node !== body) {
          return make_node(AST_SimpleStatement, self, { body: node });
        }
      }
      return self;
    });
    OPT(AST_While, function(self, compressor) {
      return compressor.option("loops") ? make_node(AST_For, self, self).optimize(compressor) : self;
    });
    function has_loop_control(loop, parent, type) {
      if (!type)
        type = AST_LoopControl;
      var found = false;
      var tw = new TreeWalker(function(node) {
        if (found || node instanceof AST_Scope)
          return true;
        if (node instanceof type && tw.loopcontrol_target(node) === loop) {
          return found = true;
        }
      });
      if (parent instanceof AST_LabeledStatement)
        tw.push(parent);
      tw.push(loop);
      loop.body.walk(tw);
      return found;
    }
    OPT(AST_Do, function(self, compressor) {
      if (!compressor.option("loops"))
        return self;
      var cond = fuzzy_eval(compressor, self.condition);
      if (!(cond instanceof AST_Node)) {
        if (cond && !has_loop_control(self, compressor.parent(), AST_Continue))
          return make_node(AST_For, self, {
            body: make_node(AST_BlockStatement, self.body, {
              body: [
                self.body,
                make_node(AST_SimpleStatement, self.condition, {
                  body: self.condition
                })
              ]
            })
          }).optimize(compressor);
        if (!has_loop_control(self, compressor.parent()))
          return make_node(AST_BlockStatement, self.body, {
            body: [
              self.body,
              make_node(AST_SimpleStatement, self.condition, {
                body: self.condition
              })
            ]
          }).optimize(compressor);
      }
      if (self.body instanceof AST_BlockStatement && !has_loop_control(self, compressor.parent(), AST_Continue)) {
        var body = self.body.body;
        for (var i = body.length;--i >= 0; ) {
          var stat = body[i];
          if (stat instanceof AST_If && !stat.alternative && stat.body instanceof AST_Break && compressor.loopcontrol_target(stat.body) === self) {
            if (has_block_scope_refs(stat.condition))
              break;
            self.condition = make_node(AST_Binary, self, {
              operator: "&&",
              left: stat.condition.negate(compressor),
              right: self.condition
            });
            body.splice(i, 1);
          } else if (stat instanceof AST_SimpleStatement) {
            if (has_block_scope_refs(stat.body))
              break;
            self.condition = make_sequence(self, [
              stat.body,
              self.condition
            ]);
            body.splice(i, 1);
          } else if (!is_declaration(stat, true)) {
            break;
          }
        }
        self.body = trim_block(self.body, compressor.parent());
      }
      if (self.body instanceof AST_EmptyStatement)
        return make_node(AST_For, self, self).optimize(compressor);
      if (self.body instanceof AST_SimpleStatement)
        return make_node(AST_For, self, {
          condition: make_sequence(self.condition, [
            self.body.body,
            self.condition
          ]),
          body: make_node(AST_EmptyStatement, self)
        }).optimize(compressor);
      return self;
      function has_block_scope_refs(node) {
        var found = false;
        node.walk(new TreeWalker(function(node2) {
          if (found)
            return true;
          if (node2 instanceof AST_SymbolRef) {
            if (!member(node2.definition(), self.enclosed))
              found = true;
            return true;
          }
        }));
        return found;
      }
    });
    function if_break_in_loop(self, compressor) {
      var first = first_statement(self.body);
      if (compressor.option("dead_code") && (first instanceof AST_Break || first instanceof AST_Continue && external_target(first) || first instanceof AST_Exit)) {
        var body = [];
        if (is_statement(self.init)) {
          body.push(self.init);
        } else if (self.init) {
          body.push(make_node(AST_SimpleStatement, self.init, {
            body: self.init
          }));
        }
        var retain = external_target(first) || first instanceof AST_Exit;
        if (self.condition && retain) {
          body.push(make_node(AST_If, self, {
            condition: self.condition,
            body: first,
            alternative: null
          }));
        } else if (self.condition) {
          body.push(make_node(AST_SimpleStatement, self.condition, {
            body: self.condition
          }));
        } else if (retain) {
          body.push(first);
        }
        extract_declarations_from_unreachable_code(compressor, self.body, body);
        return make_node(AST_BlockStatement, self, {
          body
        });
      }
      if (first instanceof AST_If) {
        var ab = first_statement(first.body);
        if (ab instanceof AST_Break && !external_target(ab)) {
          if (self.condition) {
            self.condition = make_node(AST_Binary, self.condition, {
              left: self.condition,
              operator: "&&",
              right: first.condition.negate(compressor)
            });
          } else {
            self.condition = first.condition.negate(compressor);
          }
          var body = as_statement_array(first.alternative);
          extract_declarations_from_unreachable_code(compressor, first.body, body);
          return drop_it(body);
        }
        ab = first_statement(first.alternative);
        if (ab instanceof AST_Break && !external_target(ab)) {
          if (self.condition) {
            self.condition = make_node(AST_Binary, self.condition, {
              left: self.condition,
              operator: "&&",
              right: first.condition
            });
          } else {
            self.condition = first.condition;
          }
          var body = as_statement_array(first.body);
          extract_declarations_from_unreachable_code(compressor, first.alternative, body);
          return drop_it(body);
        }
      }
      return self;
      function first_statement(body2) {
        return body2 instanceof AST_BlockStatement ? body2.body[0] : body2;
      }
      function external_target(node) {
        return compressor.loopcontrol_target(node) !== compressor.self();
      }
      function drop_it(rest) {
        if (self.body instanceof AST_BlockStatement) {
          self.body = self.body.clone();
          self.body.body = rest.concat(self.body.body.slice(1));
          self.body = self.body.transform(compressor);
        } else {
          self.body = make_node(AST_BlockStatement, self.body, {
            body: rest
          }).transform(compressor);
        }
        return if_break_in_loop(self, compressor);
      }
    }
    OPT(AST_For, function(self, compressor) {
      if (!compressor.option("loops"))
        return self;
      if (compressor.option("side_effects")) {
        if (self.init)
          self.init = self.init.drop_side_effect_free(compressor);
        if (self.step)
          self.step = self.step.drop_side_effect_free(compressor);
      }
      if (self.condition) {
        var cond = fuzzy_eval(compressor, self.condition);
        if (!cond) {
          if (compressor.option("dead_code")) {
            var body = [];
            if (is_statement(self.init)) {
              body.push(self.init);
            } else if (self.init) {
              body.push(make_node(AST_SimpleStatement, self.init, { body: self.init }));
            }
            body.push(make_node(AST_SimpleStatement, self.condition, { body: self.condition }));
            extract_declarations_from_unreachable_code(compressor, self.body, body);
            return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
          }
        } else if (!(cond instanceof AST_Node)) {
          self.body = make_node(AST_BlockStatement, self.body, {
            body: [
              make_node(AST_SimpleStatement, self.condition, { body: self.condition }),
              self.body
            ]
          });
          self.condition = null;
        }
      }
      return if_break_in_loop(self, compressor);
    });
    OPT(AST_ForEnumeration, function(self, compressor) {
      if (compressor.option("varify") && is_lexical_definition(self.init)) {
        var name = self.init.definitions[0].name;
        if ((name instanceof AST_Destructured || name instanceof AST_SymbolLet) && !name.match_symbol(function(node) {
          if (node instanceof AST_SymbolDeclaration) {
            var def = node.definition();
            return !same_scope(def) || may_overlap(compressor, def);
          }
        }, true)) {
          self.init = to_var(self.init);
        }
      }
      return self;
    });
    function mark_locally_defined(condition, consequent, alternative) {
      if (!(condition instanceof AST_Binary))
        return;
      if (!(condition.left instanceof AST_String)) {
        switch (condition.operator) {
          case "&&":
            mark_locally_defined(condition.left, consequent);
            mark_locally_defined(condition.right, consequent);
            break;
          case "||":
            mark_locally_defined(negate(condition.left), alternative);
            mark_locally_defined(negate(condition.right), alternative);
            break;
        }
        return;
      }
      if (!(condition.right instanceof AST_UnaryPrefix))
        return;
      if (condition.right.operator != "typeof")
        return;
      var sym = condition.right.expression;
      if (!is_undeclared_ref(sym))
        return;
      var body;
      var undef = condition.left.value == "undefined";
      switch (condition.operator) {
        case "==":
          body = undef ? alternative : consequent;
          break;
        case "!=":
          body = undef ? consequent : alternative;
          break;
        default:
          return;
      }
      if (!body)
        return;
      var def = sym.definition();
      var tw = new TreeWalker(function(node) {
        if (node instanceof AST_Scope) {
          var parent = tw.parent();
          if (parent instanceof AST_Call && parent.expression === node)
            return;
          return true;
        }
        if (node instanceof AST_SymbolRef && node.definition() === def)
          node.defined = true;
      });
      body.walk(tw);
      function negate(node) {
        if (!(node instanceof AST_Binary))
          return;
        switch (node.operator) {
          case "==":
            node = node.clone();
            node.operator = "!=";
            return node;
          case "!=":
            node = node.clone();
            node.operator = "==";
            return node;
        }
      }
    }
    function fuzzy_eval(compressor, node, nullish) {
      if (node.truthy)
        return true;
      if (node.falsy && !nullish)
        return false;
      if (node.is_truthy())
        return true;
      return node.evaluate(compressor, true);
    }
    function mark_duplicate_condition(compressor, node) {
      var child;
      var level = 0;
      var negated = false;
      var parent = compressor.self();
      if (!is_statement(parent))
        while (true) {
          child = parent;
          parent = compressor.parent(level++);
          if (parent instanceof AST_Binary) {
            var op = parent.operator;
            if (!lazy_op[op])
              return;
            var left = parent.left;
            if (left === child)
              continue;
            if (match(left))
              switch (op) {
                case "&&":
                  node[negated ? "falsy" : "truthy"] = true;
                  break;
                case "||":
                case "??":
                  node[negated ? "truthy" : "falsy"] = true;
                  break;
              }
          } else if (parent instanceof AST_Conditional) {
            var cond = parent.condition;
            if (cond === child)
              continue;
            if (match(cond))
              switch (child) {
                case parent.consequent:
                  node[negated ? "falsy" : "truthy"] = true;
                  break;
                case parent.alternative:
                  node[negated ? "truthy" : "falsy"] = true;
                  break;
              }
          } else if (parent instanceof AST_Exit) {
            break;
          } else if (parent instanceof AST_If) {
            break;
          } else if (parent instanceof AST_Sequence) {
            if (parent.expressions[0] === child)
              continue;
          } else if (parent instanceof AST_SimpleStatement) {
            break;
          }
          return;
        }
      while (true) {
        child = parent;
        parent = compressor.parent(level++);
        if (parent instanceof AST_BlockStatement) {
          if (parent.body[0] === child)
            continue;
        } else if (parent instanceof AST_If) {
          if (match(parent.condition))
            switch (child) {
              case parent.body:
                node[negated ? "falsy" : "truthy"] = true;
                break;
              case parent.alternative:
                node[negated ? "truthy" : "falsy"] = true;
                break;
            }
        }
        return;
      }
      function match(cond2) {
        if (node.equivalent_to(cond2))
          return true;
        if (!(cond2 instanceof AST_UnaryPrefix))
          return false;
        if (cond2.operator != "!")
          return false;
        if (!node.equivalent_to(cond2.expression))
          return false;
        negated = true;
        return true;
      }
    }
    OPT(AST_If, function(self, compressor) {
      if (is_empty(self.alternative))
        self.alternative = null;
      if (!compressor.option("conditionals"))
        return self;
      if (compressor.option("booleans") && !self.condition.has_side_effects(compressor)) {
        mark_duplicate_condition(compressor, self.condition);
      }
      if (compressor.option("dead_code")) {
        var cond = fuzzy_eval(compressor, self.condition);
        if (!cond) {
          AST_Node.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
          var body = [make_node(AST_SimpleStatement, self.condition, { body: self.condition })];
          extract_declarations_from_unreachable_code(compressor, self.body, body);
          if (self.alternative)
            body.push(self.alternative);
          return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
        } else if (!(cond instanceof AST_Node)) {
          AST_Node.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
          var body = [
            make_node(AST_SimpleStatement, self.condition, { body: self.condition }),
            self.body
          ];
          if (self.alternative)
            extract_declarations_from_unreachable_code(compressor, self.alternative, body);
          return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
        }
      }
      var negated = self.condition.negate(compressor);
      var self_condition_length = self.condition.print_to_string().length;
      var negated_length = negated.print_to_string().length;
      var negated_is_best = negated_length < self_condition_length;
      if (self.alternative && negated_is_best) {
        negated_is_best = false;
        self.condition = negated;
        var tmp = self.body;
        self.body = self.alternative || make_node(AST_EmptyStatement, self);
        self.alternative = tmp;
      }
      var body = [], var_defs = [], refs = [];
      var body_exprs = sequencesize(self.body, body, var_defs, refs);
      var alt_exprs = sequencesize(self.alternative, body, var_defs, refs);
      if (body_exprs && alt_exprs) {
        if (var_defs.length > 0)
          body.push(make_node(AST_Var, self, { definitions: var_defs }));
        if (body_exprs.length == 0) {
          body.push(make_node(AST_SimpleStatement, self.condition, {
            body: alt_exprs.length > 0 ? make_node(AST_Binary, self, {
              operator: "||",
              left: self.condition,
              right: make_sequence(self.alternative, alt_exprs)
            }).transform(compressor) : self.condition.clone()
          }).optimize(compressor));
        } else if (alt_exprs.length == 0) {
          if (self_condition_length === negated_length && !negated_is_best && self.condition instanceof AST_Binary && self.condition.operator == "||") {
            negated_is_best = true;
          }
          body.push(make_node(AST_SimpleStatement, self, {
            body: make_node(AST_Binary, self, {
              operator: negated_is_best ? "||" : "&&",
              left: negated_is_best ? negated : self.condition,
              right: make_sequence(self.body, body_exprs)
            }).transform(compressor)
          }).optimize(compressor));
        } else {
          body.push(make_node(AST_SimpleStatement, self, {
            body: make_node(AST_Conditional, self, {
              condition: self.condition,
              consequent: make_sequence(self.body, body_exprs),
              alternative: make_sequence(self.alternative, alt_exprs)
            })
          }).optimize(compressor));
        }
        refs.forEach(function(ref) {
          ref.definition().references.push(ref);
        });
        return make_node(AST_BlockStatement, self, {
          body
        }).optimize(compressor);
      }
      if (is_empty(self.body)) {
        self = make_node(AST_If, self, {
          condition: negated,
          body: self.alternative,
          alternative: null
        });
      }
      if (self.body instanceof AST_Exit && self.alternative instanceof AST_Exit && self.body.TYPE == self.alternative.TYPE) {
        var exit = make_node(self.body.CTOR, self, {
          value: make_node(AST_Conditional, self, {
            condition: self.condition,
            consequent: self.body.value || make_node(AST_Undefined, self.body).transform(compressor),
            alternative: self.alternative.value || make_node(AST_Undefined, self.alternative).transform(compressor)
          })
        });
        if (exit instanceof AST_Return) {
          exit.in_bool = self.body.in_bool || self.alternative.in_bool;
        }
        return exit;
      }
      if (self.body instanceof AST_If && !self.body.alternative && !self.alternative) {
        self = make_node(AST_If, self, {
          condition: make_node(AST_Binary, self.condition, {
            operator: "&&",
            left: self.condition,
            right: self.body.condition
          }),
          body: self.body.body,
          alternative: null
        });
      }
      if (aborts(self.body)) {
        if (self.alternative) {
          var alt = self.alternative;
          self.alternative = null;
          return make_node(AST_BlockStatement, self, {
            body: [self, alt]
          }).optimize(compressor);
        }
      }
      if (aborts(self.alternative)) {
        var body = self.body;
        self.body = self.alternative;
        self.condition = negated_is_best ? negated : self.condition.negate(compressor);
        self.alternative = null;
        return make_node(AST_BlockStatement, self, {
          body: [self, body]
        }).optimize(compressor);
      }
      if (compressor.option("typeofs"))
        mark_locally_defined(self.condition, self.body, self.alternative);
      return self;
      function sequencesize(stat, defuns, var_defs2, refs2) {
        if (stat == null)
          return [];
        if (stat instanceof AST_BlockStatement) {
          var exprs = [];
          for (var i = 0;i < stat.body.length; i++) {
            var line = stat.body[i];
            if (line instanceof AST_LambdaDefinition) {
              defuns.push(line);
            } else if (line instanceof AST_EmptyStatement) {
              continue;
            } else if (line instanceof AST_SimpleStatement) {
              if (!compressor.option("sequences") && exprs.length > 0)
                return;
              exprs.push(line.body);
            } else if (line instanceof AST_Var) {
              if (!compressor.option("sequences") && exprs.length > 0)
                return;
              line.remove_initializers(compressor, var_defs2);
              line.definitions.forEach(process_var_def);
            } else {
              return;
            }
          }
          return exprs;
        }
        if (stat instanceof AST_LambdaDefinition) {
          defuns.push(stat);
          return [];
        }
        if (stat instanceof AST_EmptyStatement)
          return [];
        if (stat instanceof AST_SimpleStatement)
          return [stat.body];
        if (stat instanceof AST_Var) {
          var exprs = [];
          stat.remove_initializers(compressor, var_defs2);
          stat.definitions.forEach(process_var_def);
          return exprs;
        }
        function process_var_def(var_def) {
          if (!var_def.value)
            return;
          exprs.push(make_node(AST_Assign, var_def, {
            operator: "=",
            left: var_def.name.convert_symbol(AST_SymbolRef, function(ref) {
              refs2.push(ref);
            }),
            right: var_def.value
          }));
        }
      }
    });
    OPT(AST_Switch, function(self, compressor) {
      if (!compressor.option("switches"))
        return self;
      if (!compressor.option("dead_code"))
        return self;
      var body = [];
      var branch;
      var decl = [];
      var default_branch;
      var exact_match;
      var side_effects = [];
      for (var i = 0, len = self.body.length;i < len; i++) {
        branch = self.body[i];
        if (branch instanceof AST_Default) {
          var prev = body[body.length - 1];
          if (default_branch || is_break(branch.body[0], compressor) && (!prev || aborts(prev))) {
            eliminate_branch(branch, prev);
            continue;
          } else {
            default_branch = branch;
          }
        } else {
          var exp = branch.expression;
          var equals = make_node(AST_Binary, self, {
            operator: "===",
            left: self.expression,
            right: exp
          }).evaluate(compressor, true);
          if (!equals) {
            if (exp.has_side_effects(compressor))
              side_effects.push(exp);
            eliminate_branch(branch, body[body.length - 1]);
            continue;
          }
          if (!(equals instanceof AST_Node)) {
            if (default_branch) {
              var default_index = body.indexOf(default_branch);
              body.splice(default_index, 1);
              eliminate_branch(default_branch, body[default_index - 1]);
              default_branch = null;
            }
            if (exp.has_side_effects(compressor)) {
              exact_match = branch;
            } else {
              default_branch = branch = make_node(AST_Default, branch, branch);
            }
            while (++i < len)
              eliminate_branch(self.body[i], branch);
          }
        }
        if (i + 1 >= len || aborts(branch)) {
          var prev = body[body.length - 1];
          var statements = branch.body;
          if (aborts(prev))
            switch (prev.body.length - statements.length) {
              case 1:
                var stat = prev.body[prev.body.length - 1];
                if (!is_break(stat, compressor))
                  break;
                statements = statements.concat(stat);
              case 0:
                var prev_block = make_node(AST_BlockStatement, prev, prev);
                var next_block = make_node(AST_BlockStatement, branch, { body: statements });
                if (prev_block.equivalent_to(next_block))
                  prev.body = [];
            }
        }
        if (side_effects.length) {
          if (branch instanceof AST_Default) {
            body.push(make_node(AST_Case, self, { expression: make_sequence(self, side_effects), body: [] }));
          } else {
            side_effects.push(branch.expression);
            branch.expression = make_sequence(self, side_effects);
          }
          side_effects = [];
        }
        body.push(branch);
      }
      if (side_effects.length && !exact_match) {
        body.push(make_node(AST_Case, self, { expression: make_sequence(self, side_effects), body: [] }));
      }
      while (branch = body[body.length - 1]) {
        var stat = branch.body[branch.body.length - 1];
        if (is_break(stat, compressor))
          branch.body.pop();
        if (branch === default_branch) {
          if (!has_declarations_only(branch))
            break;
        } else if (branch.expression.has_side_effects(compressor)) {
          break;
        } else if (default_branch) {
          if (!has_declarations_only(default_branch))
            break;
          if (body[body.length - 2] !== default_branch)
            break;
          default_branch.body = default_branch.body.concat(branch.body);
          branch.body = [];
        } else if (!has_declarations_only(branch))
          break;
        eliminate_branch(branch);
        if (body.pop() === default_branch)
          default_branch = null;
      }
      if (!branch) {
        decl.push(make_node(AST_SimpleStatement, self.expression, { body: self.expression }));
        if (side_effects.length)
          decl.push(make_node(AST_SimpleStatement, self, {
            body: make_sequence(self, side_effects)
          }));
        return make_node(AST_BlockStatement, self, { body: decl }).optimize(compressor);
      }
      if (branch === default_branch)
        while (branch = body[body.length - 2]) {
          if (branch instanceof AST_Default)
            break;
          if (!has_declarations_only(branch))
            break;
          var exp = branch.expression;
          if (exp.has_side_effects(compressor)) {
            var prev = body[body.length - 3];
            if (prev && !aborts(prev))
              break;
            default_branch.body.unshift(make_node(AST_SimpleStatement, self, { body: exp }));
          }
          eliminate_branch(branch);
          body.splice(-2, 1);
        }
      body[0].body = decl.concat(body[0].body);
      self.body = body;
      if (compressor.option("conditionals"))
        switch (body.length) {
          case 1:
            if (!no_break(body[0]))
              break;
            var exp = body[0].expression;
            var statements = body[0].body.slice();
            if (body[0] !== default_branch && body[0] !== exact_match)
              return make_node(AST_If, self, {
                condition: make_node(AST_Binary, self, {
                  operator: "===",
                  left: self.expression,
                  right: exp
                }),
                body: make_node(AST_BlockStatement, self, {
                  body: statements
                }),
                alternative: null
              }).optimize(compressor);
            if (exp)
              statements.unshift(make_node(AST_SimpleStatement, exp, {
                body: exp
              }));
            statements.unshift(make_node(AST_SimpleStatement, self.expression, {
              body: self.expression
            }));
            return make_node(AST_BlockStatement, self, {
              body: statements
            }).optimize(compressor);
          case 2:
            if (!member(default_branch, body) || !no_break(body[1]))
              break;
            var statements = body[0].body.slice();
            var exclusive = statements.length && is_break(statements[statements.length - 1], compressor);
            if (exclusive)
              statements.pop();
            if (!all(statements, no_break))
              break;
            var alternative = body[1].body.length && make_node(AST_BlockStatement, body[1], body[1]);
            var node = make_node(AST_If, self, {
              condition: make_node(AST_Binary, self, body[0] === default_branch ? {
                operator: "!==",
                left: self.expression,
                right: body[1].expression
              } : {
                operator: "===",
                left: self.expression,
                right: body[0].expression
              }),
              body: make_node(AST_BlockStatement, body[0], {
                body: statements
              }),
              alternative: exclusive && alternative || null
            });
            if (!exclusive && alternative)
              node = make_node(AST_BlockStatement, self, {
                body: [node, alternative]
              });
            return node.optimize(compressor);
        }
      return self;
      function is_break(node2, tw) {
        return node2 instanceof AST_Break && tw.loopcontrol_target(node2) === self;
      }
      function no_break(node2) {
        var found = false;
        var tw = new TreeWalker(function(node3) {
          if (found || node3 instanceof AST_Lambda || node3 instanceof AST_SimpleStatement)
            return true;
          if (is_break(node3, tw))
            found = true;
        });
        tw.push(self);
        node2.walk(tw);
        return !found;
      }
      function eliminate_branch(branch2, prev2) {
        if (prev2 && !aborts(prev2)) {
          prev2.body = prev2.body.concat(branch2.body);
        } else {
          extract_declarations_from_unreachable_code(compressor, branch2, decl);
        }
      }
    });
    OPT(AST_Try, function(self, compressor) {
      self.body = tighten_body(self.body, compressor);
      if (compressor.option("dead_code")) {
        if (has_declarations_only(self) && !(self.bcatch && self.bcatch.argname && self.bcatch.argname.match_symbol(function(node) {
          return node instanceof AST_SymbolCatch && !can_drop_symbol(node);
        }, true))) {
          var body = [];
          if (self.bcatch) {
            extract_declarations_from_unreachable_code(compressor, self.bcatch, body);
            body.forEach(function(stat) {
              if (!(stat instanceof AST_Var))
                return;
              stat.definitions.forEach(function(var_def) {
                var def = var_def.name.definition().redefined();
                if (!def)
                  return;
                var_def.name = var_def.name.clone();
                var_def.name.thedef = def;
              });
            });
          }
          body.unshift(make_node(AST_BlockStatement, self, self).optimize(compressor));
          if (self.bfinally) {
            body.push(make_node(AST_BlockStatement, self.bfinally, self.bfinally).optimize(compressor));
          }
          return make_node(AST_BlockStatement, self, {
            body
          }).optimize(compressor);
        }
        if (self.bfinally && has_declarations_only(self.bfinally)) {
          var body = make_node(AST_BlockStatement, self.bfinally, self.bfinally).optimize(compressor);
          body = self.body.concat(body);
          if (!self.bcatch)
            return make_node(AST_BlockStatement, self, {
              body
            }).optimize(compressor);
          self.body = body;
          self.bfinally = null;
        }
      }
      return self;
    });
    function remove_initializers(make_value) {
      return function(compressor, defns) {
        var dropped = false;
        this.definitions.forEach(function(defn) {
          if (defn.value)
            dropped = true;
          defn.name.match_symbol(function(node) {
            if (node instanceof AST_SymbolDeclaration)
              defns.push(make_node(AST_VarDef, node, {
                name: node,
                value: make_value(compressor, node)
              }));
          }, true);
        });
        return dropped;
      };
    }
    AST_Const.DEFMETHOD("remove_initializers", remove_initializers(function(compressor, node) {
      return make_node(AST_Undefined, node).optimize(compressor);
    }));
    AST_Let.DEFMETHOD("remove_initializers", remove_initializers(return_null));
    AST_Var.DEFMETHOD("remove_initializers", remove_initializers(return_null));
    AST_Definitions.DEFMETHOD("to_assignments", function() {
      var assignments = this.definitions.reduce(function(a2, defn) {
        var def = defn.name.definition();
        var value = defn.value;
        if (value) {
          if (value instanceof AST_Sequence)
            value = value.clone();
          var name = make_node(AST_SymbolRef, defn.name, defn.name);
          var assign = make_node(AST_Assign, defn, {
            operator: "=",
            left: name,
            right: value
          });
          a2.push(assign);
          name.fixed = function() {
            return assign.right;
          };
          name.fixed.assigns = [assign];
          def.references.forEach(function(ref) {
            var assigns = ref.fixed && ref.fixed.assigns;
            if (assigns && assigns[0] === defn)
              assigns[0] = assign;
          });
          def.references.push(name);
        }
        def.eliminated++;
        def.single_use = false;
        return a2;
      }, []);
      if (assignments.length == 0)
        return null;
      return make_sequence(this, assignments);
    });
    function is_safe_lexical(def) {
      return def.name != "arguments" && def.orig.length < (def.orig[0] instanceof AST_SymbolLambda ? 3 : 2);
    }
    function may_overlap(compressor, def) {
      if (compressor.exposed(def))
        return true;
      var scope = def.scope.resolve();
      for (var s2 = def.scope;s2 !== scope; ) {
        s2 = s2.parent_scope;
        if (s2.var_names()[def.name])
          return true;
      }
    }
    function to_var(stat) {
      return make_node(AST_Var, stat, {
        definitions: stat.definitions.map(function(defn) {
          return make_node(AST_VarDef, defn, {
            name: defn.name.convert_symbol(AST_SymbolVar, function(name, node) {
              var def = name.definition();
              def.orig[def.orig.indexOf(node)] = name;
              var scope = def.scope.resolve();
              if (def.scope === scope)
                return;
              def.scope = scope;
              scope.variables.set(def.name, def);
              scope.enclosed.push(def);
              scope.var_names()[def.name] = true;
            }),
            value: defn.value
          });
        })
      });
    }
    function can_varify(compressor, sym) {
      if (!sym.fixed_value())
        return false;
      var def = sym.definition();
      return is_safe_lexical(def) && same_scope(def) && !may_overlap(compressor, def);
    }
    function varify(self, compressor) {
      return compressor.option("varify") && all(self.definitions, function(defn) {
        return !defn.name.match_symbol(function(node) {
          if (node instanceof AST_SymbolDeclaration)
            return !can_varify(compressor, node);
        }, true);
      }) ? to_var(self) : self;
    }
    OPT(AST_Const, varify);
    OPT(AST_Let, varify);
    function trim_optional_chain(node, compressor) {
      if (!compressor.option("optional_chains"))
        return;
      if (node.terminal)
        do {
          var expr = node.expression;
          if (node.optional) {
            var ev = fuzzy_eval(compressor, expr, true);
            if (ev == null)
              return make_node(AST_UnaryPrefix, node, {
                operator: "void",
                expression: expr
              }).optimize(compressor);
            if (!(ev instanceof AST_Node))
              node.optional = false;
          }
          node = expr;
        } while ((node.TYPE == "Call" || node instanceof AST_PropAccess) && !node.terminal);
    }
    function lift_sequence_in_expression(node, compressor) {
      var exp = node.expression;
      if (!(exp instanceof AST_Sequence))
        return node;
      var x2 = exp.expressions.slice();
      var e = node.clone();
      e.expression = x2.pop();
      x2.push(e);
      return make_sequence(node, x2);
    }
    function drop_unused_call_args(call, compressor, fns_with_marked_args) {
      var exp = call.expression;
      var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;
      if (!(fn instanceof AST_Lambda))
        return;
      if (fn.uses_arguments)
        return;
      if (fn.pinned())
        return;
      if (fns_with_marked_args && fns_with_marked_args.indexOf(fn) < 0)
        return;
      var args = call.args;
      if (!all(args, function(arg2) {
        return !(arg2 instanceof AST_Spread);
      }))
        return;
      var argnames = fn.argnames;
      var is_iife = fn === exp && !fn.name;
      if (fn.rest) {
        if (!(is_iife && compressor.option("rests")))
          return;
        var insert = argnames.length;
        args = args.slice(0, insert);
        while (args.length < insert)
          args.push(make_node(AST_Undefined, call).optimize(compressor));
        args.push(make_node(AST_Array, call, { elements: call.args.slice(insert) }));
        argnames = argnames.concat(fn.rest);
        fn.rest = null;
      } else {
        args = args.slice();
        argnames = argnames.slice();
      }
      var pos = 0, last = 0;
      var drop_defaults = is_iife && compressor.option("default_values");
      var drop_fargs = is_iife && compressor.drop_fargs(fn, call) ? function(argname2, arg2) {
        if (!argname2)
          return true;
        if (argname2 instanceof AST_DestructuredArray) {
          return argname2.elements.length == 0 && !argname2.rest && arg2 instanceof AST_Array;
        }
        if (argname2 instanceof AST_DestructuredObject) {
          return argname2.properties.length == 0 && !argname2.rest && arg2 && !arg2.may_throw_on_access(compressor);
        }
        return argname2.__unused;
      } : return_false;
      var side_effects = [];
      for (var i = 0;i < args.length; i++) {
        var argname = argnames[i];
        if (drop_defaults && argname instanceof AST_DefaultValue && args[i].is_defined(compressor)) {
          argnames[i] = argname = argname.name;
        }
        if (!argname || "__unused" in argname) {
          var node = args[i].drop_side_effect_free(compressor);
          if (drop_fargs(argname)) {
            if (argname)
              argnames.splice(i, 1);
            args.splice(i, 1);
            if (node)
              side_effects.push(node);
            i--;
            continue;
          } else if (node) {
            side_effects.push(node);
            args[pos++] = make_sequence(call, side_effects);
            side_effects = [];
          } else if (argname) {
            if (side_effects.length) {
              args[pos++] = make_sequence(call, side_effects);
              side_effects = [];
            } else {
              args[pos++] = make_node(AST_Number, args[i], {
                value: 0
              });
              continue;
            }
          }
        } else if (drop_fargs(argname, args[i])) {
          var node = args[i].drop_side_effect_free(compressor);
          argnames.splice(i, 1);
          args.splice(i, 1);
          if (node)
            side_effects.push(node);
          i--;
          continue;
        } else {
          side_effects.push(args[i]);
          args[pos++] = make_sequence(call, side_effects);
          side_effects = [];
        }
        last = pos;
      }
      for (;i < argnames.length; i++) {
        if (drop_fargs(argnames[i]))
          argnames.splice(i--, 1);
      }
      fn.argnames = argnames;
      args.length = last;
      call.args = args;
      if (!side_effects.length)
        return;
      var arg = make_sequence(call, side_effects);
      args.push(args.length < argnames.length ? make_node(AST_UnaryPrefix, call, {
        operator: "void",
        expression: arg
      }) : arg);
    }
    OPT(AST_Call, function(self, compressor) {
      var exp = self.expression;
      var terminated = trim_optional_chain(self, compressor);
      if (terminated)
        return terminated;
      if (compressor.option("sequences")) {
        if (exp instanceof AST_PropAccess) {
          var seq = lift_sequence_in_expression(exp, compressor);
          if (seq !== exp) {
            var call = self.clone();
            call.expression = seq.expressions.pop();
            seq.expressions.push(call);
            return seq.optimize(compressor);
          }
        } else if (!needs_unbinding(compressor, exp.tail_node())) {
          var seq = lift_sequence_in_expression(self, compressor);
          if (seq !== self)
            return seq.optimize(compressor);
        }
      }
      if (compressor.option("unused"))
        drop_unused_call_args(self, compressor);
      if (compressor.option("unsafe")) {
        if (is_undeclared_ref(exp))
          switch (exp.name) {
            case "Array":
              if (self.args.length == 1) {
                var first = self.args[0];
                if (first instanceof AST_Number)
                  try {
                    var length = first.value;
                    if (length > 6)
                      break;
                    var elements = Array(length);
                    for (var i = 0;i < length; i++)
                      elements[i] = make_node(AST_Hole, self);
                    return make_node(AST_Array, self, { elements });
                  } catch (ex) {
                    AST_Node.warn("Invalid array length: {length} [{file}:{line},{col}]", {
                      length,
                      file: self.start.file,
                      line: self.start.line,
                      col: self.start.col
                    });
                    break;
                  }
                if (!first.is_boolean(compressor) && !first.is_string(compressor))
                  break;
              }
              return make_node(AST_Array, self, { elements: self.args });
            case "Object":
              if (self.args.length == 0)
                return make_node(AST_Object, self, { properties: [] });
              break;
            case "String":
              if (self.args.length == 0)
                return make_node(AST_String, self, { value: "" });
              if (self.args.length == 1)
                return make_node(AST_Binary, self, {
                  operator: "+",
                  left: make_node(AST_String, self, { value: "" }),
                  right: self.args[0]
                }).optimize(compressor);
              break;
            case "Number":
              if (self.args.length == 0)
                return make_node(AST_Number, self, { value: 0 });
              if (self.args.length == 1)
                return make_node(AST_UnaryPrefix, self, {
                  operator: "+",
                  expression: make_node(AST_Binary, self, {
                    operator: "+",
                    left: make_node(AST_String, self, { value: "" }),
                    right: self.args[0]
                  })
                }).optimize(compressor);
              break;
            case "Boolean":
              if (self.args.length == 0)
                return make_node(AST_False, self).optimize(compressor);
              if (self.args.length == 1)
                return make_node(AST_UnaryPrefix, self, {
                  operator: "!",
                  expression: make_node(AST_UnaryPrefix, self, {
                    operator: "!",
                    expression: self.args[0]
                  })
                }).optimize(compressor);
              break;
            case "RegExp":
              var params = [];
              if (all(self.args, function(arg) {
                var value2 = arg.evaluate(compressor);
                params.unshift(value2);
                return arg !== value2;
              }))
                try {
                  return best_of(compressor, self, make_node(AST_RegExp, self, {
                    value: RegExp.apply(RegExp, params)
                  }));
                } catch (ex) {
                  AST_Node.warn("Error converting {expr} [{file}:{line},{col}]", {
                    expr: self,
                    file: self.start.file,
                    line: self.start.line,
                    col: self.start.col
                  });
                }
              break;
          }
        else if (exp instanceof AST_Dot)
          switch (exp.property) {
            case "toString":
              var expr = exp.expression;
              if (self.args.length == 0 && !(expr.may_throw_on_access(compressor) || expr instanceof AST_Super)) {
                return make_node(AST_Binary, self, {
                  operator: "+",
                  left: make_node(AST_String, self, { value: "" }),
                  right: expr
                }).optimize(compressor);
              }
              break;
            case "join":
              if (exp.expression instanceof AST_Array && self.args.length < 2)
                EXIT: {
                  var separator = self.args[0];
                  if (exp.expression.elements.length == 0 && !(separator instanceof AST_Spread)) {
                    return separator ? make_sequence(self, [
                      separator,
                      make_node(AST_String, self, { value: "" })
                    ]).optimize(compressor) : make_node(AST_String, self, { value: "" });
                  }
                  if (separator) {
                    separator = separator.evaluate(compressor);
                    if (separator instanceof AST_Node)
                      break EXIT;
                  }
                  var elements = [];
                  var consts = [];
                  for (var i = 0;i < exp.expression.elements.length; i++) {
                    var el = exp.expression.elements[i];
                    var value = el.evaluate(compressor);
                    if (value !== el) {
                      consts.push(value);
                    } else if (el instanceof AST_Spread) {
                      break EXIT;
                    } else {
                      if (consts.length > 0) {
                        elements.push(make_node(AST_String, self, {
                          value: consts.join(separator)
                        }));
                        consts.length = 0;
                      }
                      elements.push(el);
                    }
                  }
                  if (consts.length > 0)
                    elements.push(make_node(AST_String, self, {
                      value: consts.join(separator)
                    }));
                  if (elements.length == 1) {
                    if (elements[0].is_string(compressor))
                      return elements[0];
                    return make_node(AST_Binary, elements[0], {
                      operator: "+",
                      left: make_node(AST_String, self, { value: "" }),
                      right: elements[0]
                    });
                  }
                  if (separator == "") {
                    var first;
                    if (elements[0].is_string(compressor) || elements[1].is_string(compressor)) {
                      first = elements.shift();
                    } else {
                      first = make_node(AST_String, self, { value: "" });
                    }
                    return elements.reduce(function(prev, el2) {
                      return make_node(AST_Binary, el2, {
                        operator: "+",
                        left: prev,
                        right: el2
                      });
                    }, first).optimize(compressor);
                  }
                  var node = self.clone();
                  node.expression = node.expression.clone();
                  node.expression.expression = node.expression.expression.clone();
                  node.expression.expression.elements = elements;
                  return best_of(compressor, self, node);
                }
              break;
            case "charAt":
              if (self.args.length < 2) {
                var node = make_node(AST_Binary, self, {
                  operator: "||",
                  left: make_node(AST_Sub, self, {
                    expression: exp.expression,
                    property: self.args.length ? make_node(AST_Binary, self.args[0], {
                      operator: "|",
                      left: make_node(AST_Number, self, { value: 0 }),
                      right: self.args[0]
                    }) : make_node(AST_Number, self, { value: 0 })
                  }).optimize(compressor),
                  right: make_node(AST_String, self, { value: "" })
                });
                node.is_string = return_true;
                return node.optimize(compressor);
              }
              break;
            case "apply":
              if (self.args.length == 2 && self.args[1] instanceof AST_Array) {
                var args = self.args[1].elements.slice();
                args.unshift(self.args[0]);
                return make_node(AST_Call, self, {
                  expression: make_node(AST_Dot, exp, {
                    expression: exp.expression,
                    property: "call"
                  }),
                  args
                }).optimize(compressor);
              }
              break;
            case "call":
              var func = exp.expression;
              if (func instanceof AST_SymbolRef) {
                func = func.fixed_value();
              }
              if (func instanceof AST_Lambda && !func.contains_this()) {
                return (self.args.length ? make_sequence(this, [
                  self.args[0],
                  make_node(AST_Call, self, {
                    expression: exp.expression,
                    args: self.args.slice(1)
                  })
                ]) : make_node(AST_Call, self, {
                  expression: exp.expression,
                  args: []
                })).optimize(compressor);
              }
              break;
          }
      }
      if (compressor.option("unsafe_Function") && is_undeclared_ref(exp) && exp.name == "Function") {
        if (self.args.length == 0)
          return make_node(AST_Function, self, {
            argnames: [],
            body: []
          }).init_vars(exp.scope);
        if (all(self.args, function(x2) {
          return x2 instanceof AST_String;
        })) {
          try {
            var code = "n(function(" + self.args.slice(0, -1).map(function(arg) {
              return arg.value;
            }).join() + "){" + self.args[self.args.length - 1].value + "})";
            var ast = parse(code);
            var mangle = { ie: compressor.option("ie") };
            ast.figure_out_scope(mangle);
            var comp = new Compressor2(compressor.options);
            ast = ast.transform(comp);
            ast.figure_out_scope(mangle);
            ast.compute_char_frequency(mangle);
            ast.mangle_names(mangle);
            var fun;
            ast.walk(new TreeWalker(function(node2) {
              if (fun)
                return true;
              if (node2 instanceof AST_Lambda) {
                fun = node2;
                return true;
              }
            }));
            var code = OutputStream();
            AST_BlockStatement.prototype._codegen.call(fun, code);
            self.args = [
              make_node(AST_String, self, {
                value: fun.argnames.map(function(arg) {
                  return arg.print_to_string();
                }).join()
              }),
              make_node(AST_String, self.args[self.args.length - 1], {
                value: code.get().replace(/^\{|\}$/g, "")
              })
            ];
            return self;
          } catch (ex) {
            if (ex instanceof JS_Parse_Error) {
              AST_Node.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
              AST_Node.warn(ex.toString());
            } else {
              throw ex;
            }
          }
        }
      }
      var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;
      var parent = compressor.parent(), current = compressor.self();
      var is_func = fn instanceof AST_Lambda && (!is_async(fn) || compressor.option("awaits") && parent instanceof AST_Await) && (!is_generator(fn) || compressor.option("yields") && current instanceof AST_Yield && current.nested);
      var stat = is_func && fn.first_statement();
      var has_default = 0, has_destructured = false;
      var has_spread = !all(self.args, function(arg) {
        return !(arg instanceof AST_Spread);
      });
      var can_drop = is_func && all(fn.argnames, function(argname, index) {
        if (has_default == 1 && self.args[index] instanceof AST_Spread)
          has_default = 2;
        if (argname instanceof AST_DefaultValue) {
          if (!has_default)
            has_default = 1;
          var arg = has_default == 1 && self.args[index];
          if (arg && !is_undefined(arg))
            has_default = 2;
          if (has_arg_refs(argname.value))
            return false;
          argname = argname.name;
        }
        if (argname instanceof AST_Destructured) {
          has_destructured = true;
          if (has_arg_refs(argname))
            return false;
        }
        return true;
      }) && !(fn.rest instanceof AST_Destructured && has_arg_refs(fn.rest));
      var can_inline = can_drop && compressor.option("inline") && !self.is_expr_pure(compressor);
      if (can_inline && stat instanceof AST_Return) {
        var value = stat.value;
        if (exp === fn && !fn.name && (!value || value.is_constant_expression()) && safe_from_await_yield(fn)) {
          return make_sequence(self, convert_args(value)).optimize(compressor);
        }
      }
      if (is_func) {
        var def, value, var_assigned = false;
        if (can_inline && !fn.uses_arguments && !fn.pinned() && !(fn.name && fn instanceof AST_LambdaExpression) && (exp === fn || !recursive_ref(compressor, def = exp.definition(), fn) && fn.is_constant_expression(find_scope(compressor))) && !has_spread && (value = can_flatten_body(stat)) && !fn.contains_this()) {
          var replacing = exp === fn || def.single_use && def.references.length - def.replaced == 1;
          if (can_substitute_directly()) {
            var args = self.args.slice();
            var refs = [];
            args.push(value.clone(true).transform(new TreeTransformer(function(node2) {
              if (node2 instanceof AST_SymbolRef) {
                var def2 = node2.definition();
                if (fn.variables.get(node2.name) !== def2) {
                  refs.push(node2);
                  return node2;
                }
                var index = resolve_index(def2);
                var arg = args[index];
                if (!arg)
                  return make_node(AST_Undefined, self);
                args[index] = null;
                var parent2 = this.parent();
                return parent2 ? maintain_this_binding(compressor, parent2, node2, arg) : arg;
              }
            })));
            var save_inlined = fn.inlined;
            if (exp !== fn)
              fn.inlined = true;
            var node = make_sequence(self, args.filter(function(arg) {
              return arg;
            })).optimize(compressor);
            fn.inlined = save_inlined;
            node = maintain_this_binding(compressor, parent, current, node);
            if (replacing || best_of_expression(node, self) === node) {
              refs.forEach(function(ref) {
                ref.scope = exp === fn ? fn.parent_scope : exp.scope;
                ref.reference();
                var def2 = ref.definition();
                if (replacing)
                  def2.replaced++;
                def2.single_use = false;
              });
              return node;
            } else if (!node.has_side_effects(compressor)) {
              self.drop_side_effect_free = return_null;
            }
          }
          var arg_used, insert, in_loop, scope;
          if (replacing && can_inject_symbols()) {
            fn._squeezed = true;
            if (exp !== fn)
              fn.parent_scope = exp.scope;
            var node = make_sequence(self, flatten_fn()).optimize(compressor);
            return maintain_this_binding(compressor, parent, current, node);
          }
        }
        if (compressor.option("side_effects") && can_drop && all(fn.body, is_empty) && (fn === exp ? fn_name_unused(fn, compressor) : !has_default && !has_destructured && !fn.rest) && !(is_arrow(fn) && fn.value) && safe_from_await_yield(fn)) {
          return make_sequence(self, convert_args()).optimize(compressor);
        }
      }
      if (compressor.option("drop_console")) {
        if (exp instanceof AST_PropAccess) {
          var name = exp.expression;
          while (name.expression) {
            name = name.expression;
          }
          if (is_undeclared_ref(name) && name.name == "console") {
            return make_node(AST_Undefined, self).optimize(compressor);
          }
        }
      }
      if (compressor.option("negate_iife") && parent instanceof AST_SimpleStatement && is_iife_call(current)) {
        return self.negate(compressor, true);
      }
      return try_evaluate(compressor, self);
      function has_arg_refs(node2) {
        var found = false;
        node2.walk(new TreeWalker(function(node3) {
          if (found)
            return true;
          if (node3 instanceof AST_SymbolRef && fn.variables.get(node3.name) === node3.definition()) {
            return found = true;
          }
        }));
        return found;
      }
      function make_void_lhs(orig) {
        return make_node(AST_Dot, orig, {
          expression: make_node(AST_Array, orig, { elements: [] }),
          property: "e"
        });
      }
      function convert_args(value2) {
        var args2 = self.args.slice();
        var destructured = has_default > 1 || has_destructured || fn.rest;
        if (destructured || has_spread)
          args2 = [make_node(AST_Array, self, { elements: args2 })];
        if (destructured) {
          var tt2 = new TreeTransformer(function(node2, descend) {
            if (node2 instanceof AST_DefaultValue)
              return make_node(AST_DefaultValue, node2, {
                name: node2.name.transform(tt2) || make_void_lhs(node2),
                value: node2.value
              });
            if (node2 instanceof AST_DestructuredArray) {
              var elements2 = [];
              node2.elements.forEach(function(node3, index) {
                node3 = node3.transform(tt2);
                if (node3)
                  elements2[index] = node3;
              });
              fill_holes(node2, elements2);
              return make_node(AST_DestructuredArray, node2, { elements: elements2 });
            }
            if (node2 instanceof AST_DestructuredObject) {
              var properties = [], side_effects = [];
              node2.properties.forEach(function(prop) {
                var key = prop.key;
                var value3 = prop.value.transform(tt2);
                if (value3) {
                  if (side_effects.length) {
                    if (!(key instanceof AST_Node))
                      key = make_node_from_constant(key, prop);
                    side_effects.push(key);
                    key = make_sequence(node2, side_effects);
                    side_effects = [];
                  }
                  properties.push(make_node(AST_DestructuredKeyVal, prop, {
                    key,
                    value: value3
                  }));
                } else if (key instanceof AST_Node) {
                  side_effects.push(key);
                }
              });
              if (side_effects.length)
                properties.push(make_node(AST_DestructuredKeyVal, node2, {
                  key: make_sequence(node2, side_effects),
                  value: make_void_lhs(node2)
                }));
              return make_node(AST_DestructuredObject, node2, { properties });
            }
            if (node2 instanceof AST_SymbolFunarg)
              return null;
          });
          var lhs = [];
          fn.argnames.forEach(function(argname, index) {
            argname = argname.transform(tt2);
            if (argname)
              lhs[index] = argname;
          });
          var rest = fn.rest && fn.rest.transform(tt2);
          if (rest)
            lhs.length = fn.argnames.length;
          fill_holes(fn, lhs);
          args2[0] = make_node(AST_Assign, self, {
            operator: "=",
            left: make_node(AST_DestructuredArray, fn, {
              elements: lhs,
              rest
            }),
            right: args2[0]
          });
        } else
          fn.argnames.forEach(function(argname) {
            if (argname instanceof AST_DefaultValue)
              args2.push(argname.value);
          });
        args2.push(value2 || make_node(AST_Undefined, self));
        return args2;
      }
      function avoid_await_yield() {
        var avoid = [];
        var parent_scope = scope || compressor.find_parent(AST_Scope);
        if (is_async(parent_scope))
          avoid.push("await");
        if (is_generator(parent_scope))
          avoid.push("yield");
        return avoid.length && makePredicate(avoid);
      }
      function safe_from_await_yield(node2) {
        var avoid = avoid_await_yield();
        if (!avoid)
          return true;
        var safe = true;
        var tw = new TreeWalker(function(node3) {
          if (!safe)
            return true;
          if (node3 instanceof AST_Scope) {
            if (node3 === fn)
              return;
            if (is_arrow(node3)) {
              for (var i2 = 0;safe && i2 < node3.argnames.length; i2++)
                node3.argnames[i2].walk(tw);
            } else if (node3 instanceof AST_LambdaDefinition && avoid[node3.name.name]) {
              safe = false;
            }
            return true;
          }
          if (node3 instanceof AST_Symbol && avoid[node3.name] && node3 !== fn.name)
            safe = false;
        });
        node2.walk(tw);
        return safe;
      }
      function noop_value() {
        return self.call_only ? make_node(AST_Number, self, { value: 0 }) : make_node(AST_Undefined, self);
      }
      function return_value(stat2) {
        if (!stat2)
          return noop_value();
        if (stat2 instanceof AST_Return)
          return stat2.value || noop_value();
        if (stat2 instanceof AST_SimpleStatement) {
          return self.call_only ? stat2.body : make_node(AST_UnaryPrefix, stat2, {
            operator: "void",
            expression: stat2.body
          });
        }
      }
      function can_flatten_body(stat2) {
        var len = fn.body.length;
        if (len < 2) {
          stat2 = return_value(stat2);
          if (stat2)
            return stat2;
        }
        if (compressor.option("inline") < 3)
          return false;
        stat2 = null;
        for (var i2 = 0;i2 < len; i2++) {
          var line = fn.body[i2];
          if (line instanceof AST_Var) {
            var assigned = var_assigned || !declarations_only(line);
            if (assigned) {
              var_assigned = true;
              if (stat2)
                return false;
            }
          } else if (line instanceof AST_AsyncDefun || line instanceof AST_Defun || line instanceof AST_EmptyStatement) {
            continue;
          } else if (stat2) {
            return false;
          } else {
            stat2 = line;
          }
        }
        return return_value(stat2);
      }
      function resolve_index(def2) {
        for (var i2 = fn.argnames.length;--i2 >= 0; ) {
          if (fn.argnames[i2].definition() === def2)
            return i2;
        }
      }
      function can_substitute_directly() {
        if (has_default || has_destructured || var_assigned || fn.rest)
          return;
        if (compressor.option("inline") < 2 && fn.argnames.length)
          return;
        if (!fn.variables.all(function(def2) {
          return def2.references.length - def2.replaced < 2 && def2.orig[0] instanceof AST_SymbolFunarg;
        }))
          return;
        var abort = false;
        var avoid = avoid_await_yield();
        var begin;
        var in_order = [];
        var side_effects = false;
        value.walk(new TreeWalker(function(node2, descend) {
          if (abort)
            return true;
          if (node2 instanceof AST_Binary && lazy_op[node2.operator] || node2 instanceof AST_Conditional) {
            in_order = null;
            return;
          }
          if (node2 instanceof AST_Scope)
            return abort = true;
          if (avoid && node2 instanceof AST_Symbol && avoid[node2.name])
            return abort = true;
          if (node2 instanceof AST_SymbolRef) {
            var def2 = node2.definition();
            if (fn.variables.get(node2.name) !== def2) {
              in_order = null;
              return;
            }
            if (def2.init instanceof AST_LambdaDefinition)
              return abort = true;
            if (is_lhs(node2, this.parent()))
              return abort = true;
            var index = resolve_index(def2);
            if (!(begin < index))
              begin = index;
            if (!in_order)
              return;
            if (side_effects) {
              in_order = null;
            } else {
              in_order.push(fn.argnames[index]);
            }
            return;
          }
          if (node2.has_side_effects(compressor)) {
            descend();
            side_effects = true;
            return true;
          }
        }));
        if (abort)
          return;
        var end = self.args.length;
        if (in_order && fn.argnames.length >= end) {
          end = fn.argnames.length;
          while (end-- > begin && fn.argnames[end] === in_order.pop())
            ;
          end++;
        }
        var scope2 = side_effects && !in_order && compressor.find_parent(AST_Scope);
        return end <= begin || all(self.args.slice(begin, end), scope2 ? function(funarg) {
          return funarg.is_constant_expression(scope2);
        } : function(funarg) {
          return !funarg.has_side_effects(compressor);
        });
      }
      function var_exists(defined, name2) {
        return defined[name2] || identifier_atom[name2] || scope.var_names()[name2];
      }
      function can_inject_args(defined, used, safe_to_inject) {
        var abort = false;
        fn.each_argname(function(arg) {
          if (abort)
            return;
          if (arg.__unused)
            return;
          if (!safe_to_inject || var_exists(defined, arg.name))
            return abort = true;
          used[arg.name] = true;
          if (in_loop)
            in_loop.push(arg.definition());
        });
        return !abort;
      }
      function can_inject_vars(defined, used, safe_to_inject) {
        for (var i2 = 0;i2 < fn.body.length; i2++) {
          var stat2 = fn.body[i2];
          if (stat2 instanceof AST_LambdaDefinition) {
            if (!safe_to_inject || var_exists(used, stat2.name.name))
              return false;
            if (!all(stat2.enclosed, function(def2) {
              return def2.scope === stat2 || !defined[def2.name];
            }))
              return false;
            if (in_loop)
              in_loop.push(stat2.name.definition());
            continue;
          }
          if (!(stat2 instanceof AST_Var))
            continue;
          if (!safe_to_inject)
            return false;
          for (var j2 = stat2.definitions.length;--j2 >= 0; ) {
            var name2 = stat2.definitions[j2].name;
            if (var_exists(defined, name2.name))
              return false;
            if (in_loop)
              in_loop.push(name2.definition());
          }
        }
        return true;
      }
      function can_inject_symbols() {
        var defined = Object.create(null);
        var level = 0, child;
        scope = current;
        do {
          if (scope.variables)
            scope.variables.each(function(def2) {
              defined[def2.name] = true;
            });
          child = scope;
          scope = compressor.parent(level++);
          if (scope instanceof AST_DWLoop) {
            in_loop = [];
          } else if (scope instanceof AST_For) {
            if (scope.init === child)
              continue;
            in_loop = [];
          } else if (scope instanceof AST_ForEnumeration) {
            if (scope.init === child)
              continue;
            if (scope.object === child)
              continue;
            in_loop = [];
          } else if (scope instanceof AST_SymbolRef) {
            if (scope.fixed_value() instanceof AST_Scope)
              return false;
          }
        } while (!(scope instanceof AST_Scope));
        insert = scope.body.indexOf(child) + 1;
        if (!insert)
          return false;
        if (!safe_from_await_yield(fn))
          return false;
        var safe_to_inject = exp !== fn || fn.parent_scope.resolve() === scope;
        if (scope instanceof AST_Toplevel) {
          if (compressor.toplevel.vars) {
            defined["arguments"] = true;
          } else {
            safe_to_inject = false;
          }
        }
        var inline = compressor.option("inline");
        arg_used = Object.create(defined);
        if (!can_inject_args(defined, arg_used, inline >= 2 && safe_to_inject))
          return false;
        var used = Object.create(arg_used);
        if (!can_inject_vars(defined, used, inline >= 3 && safe_to_inject))
          return false;
        return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);
      }
      function append_var(decls, expressions, name2, value2) {
        var def2 = name2.definition();
        if (!scope.var_names()[name2.name]) {
          scope.var_names()[name2.name] = true;
          decls.push(make_node(AST_VarDef, name2, {
            name: name2,
            value: null
          }));
        }
        scope.variables.set(name2.name, def2);
        scope.enclosed.push(def2);
        if (!value2)
          return;
        var sym = make_node(AST_SymbolRef, name2, name2);
        def2.references.push(sym);
        expressions.push(make_node(AST_Assign, self, {
          operator: "=",
          left: sym,
          right: value2
        }));
      }
      function flatten_args(decls, expressions) {
        var len = fn.argnames.length;
        for (var i2 = self.args.length;--i2 >= len; ) {
          expressions.push(self.args[i2]);
        }
        var default_args = [];
        for (i2 = len;--i2 >= 0; ) {
          var argname = fn.argnames[i2];
          var name2;
          if (argname instanceof AST_DefaultValue) {
            default_args.push(argname);
            name2 = argname.name;
          } else {
            name2 = argname;
          }
          var value2 = self.args[i2];
          if (name2.__unused || scope.var_names()[name2.name]) {
            if (value2)
              expressions.push(value2);
          } else {
            var symbol = make_node(AST_SymbolVar, name2, name2);
            name2.definition().orig.push(symbol);
            if ("__unused" in name2) {
              append_var(decls, expressions, symbol);
              if (value2)
                expressions.push(value2);
            } else {
              if (!value2 && in_loop && argname === name2)
                value2 = make_node(AST_Undefined, self);
              append_var(decls, expressions, symbol, value2);
            }
          }
        }
        decls.reverse();
        expressions.reverse();
        for (i2 = default_args.length;--i2 >= 0; ) {
          var node2 = default_args[i2];
          if ("__unused" in node2.name) {
            expressions.push(node2.value);
          } else {
            var sym = make_node(AST_SymbolRef, node2.name, node2.name);
            node2.name.definition().references.push(sym);
            expressions.push(make_node(AST_Assign, node2, {
              operator: "=",
              left: sym,
              right: node2.value
            }));
          }
        }
      }
      function flatten_destructured(decls, expressions) {
        expressions.push(make_node(AST_Assign, self, {
          operator: "=",
          left: make_node(AST_DestructuredArray, self, {
            elements: fn.argnames.map(function(argname) {
              if (argname.__unused)
                return make_node(AST_Hole, argname);
              return argname.convert_symbol(AST_SymbolRef, process2);
            }),
            rest: fn.rest && fn.rest.convert_symbol(AST_SymbolRef, process2)
          }),
          right: make_node(AST_Array, self, { elements: self.args.slice() })
        }));
        function process2(ref, name2) {
          var def2 = name2.definition();
          def2.references.push(ref);
          var symbol = make_node(AST_SymbolVar, name2, name2);
          def2.orig.push(symbol);
          append_var(decls, expressions, symbol);
        }
      }
      function flatten_var(name2) {
        var redef = name2.definition().redefined();
        if (redef) {
          name2 = name2.clone();
          name2.thedef = redef;
        }
        return name2;
      }
      function flatten_vars(decls, expressions) {
        var args2 = [insert, 0];
        var decl_var = [], expr_var = [], expr_loop = [];
        for (var i2 = 0;i2 < fn.body.length; i2++) {
          var stat2 = fn.body[i2];
          if (stat2 instanceof AST_LambdaDefinition) {
            if (in_loop) {
              var name2 = make_node(AST_SymbolVar, stat2.name, flatten_var(stat2.name));
              name2.definition().orig.push(name2);
              append_var(decls, expressions, name2, to_func_expr(stat2, true));
            } else {
              var def2 = stat2.name.definition();
              scope.functions.set(def2.name, def2);
              scope.variables.set(def2.name, def2);
              scope.enclosed.push(def2);
              scope.var_names()[def2.name] = true;
              args2.push(stat2);
            }
            continue;
          }
          if (!(stat2 instanceof AST_Var))
            continue;
          for (var j2 = 0;j2 < stat2.definitions.length; j2++) {
            var var_def = stat2.definitions[j2];
            var name2 = flatten_var(var_def.name);
            append_var(decl_var, expr_var, name2, var_def.value);
            if (in_loop && !HOP(arg_used, name2.name)) {
              var def2 = fn.variables.get(name2.name);
              var sym = make_node(AST_SymbolRef, name2, name2);
              def2.references.push(sym);
              expr_loop.push(make_node(AST_Assign, var_def, {
                operator: "=",
                left: sym,
                right: make_node(AST_Undefined, name2)
              }));
            }
          }
        }
        [].push.apply(decls, decl_var);
        [].push.apply(expressions, expr_loop);
        [].push.apply(expressions, expr_var);
        return args2;
      }
      function flatten_fn() {
        var decls = [];
        var expressions = [];
        if (has_default > 1 || has_destructured || fn.rest) {
          flatten_destructured(decls, expressions);
        } else {
          flatten_args(decls, expressions);
        }
        var args2 = flatten_vars(decls, expressions);
        expressions.push(value);
        if (decls.length)
          args2.push(make_node(AST_Var, fn, {
            definitions: decls
          }));
        [].splice.apply(scope.body, args2);
        fn.enclosed.forEach(function(def2) {
          if (scope.var_names()[def2.name])
            return;
          scope.enclosed.push(def2);
          scope.var_names()[def2.name] = true;
        });
        return expressions;
      }
    });
    OPT(AST_New, function(self, compressor) {
      if (compressor.option("sequences")) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("unused"))
        drop_unused_call_args(self, compressor);
      if (compressor.option("unsafe")) {
        var exp = self.expression;
        if (is_undeclared_ref(exp)) {
          switch (exp.name) {
            case "Object":
            case "RegExp":
            case "Function":
            case "Error":
            case "Array":
              return make_node(AST_Call, self, self).transform(compressor);
          }
        }
      }
      return self;
    });
    function to_conditional_assignment(compressor, def, value, node) {
      if (!(node instanceof AST_Binary))
        return;
      if (!(node.operator == "&&" || node.operator == "||"))
        return;
      if (!(node.right instanceof AST_Assign))
        return;
      if (node.right.operator != "=")
        return;
      if (!(node.right.left instanceof AST_SymbolRef))
        return;
      if (node.right.left.definition() !== def)
        return;
      if (value.has_side_effects(compressor))
        return;
      if (!safe_from_assignment(node.left))
        return;
      if (!safe_from_assignment(node.right.right))
        return;
      def.replaced++;
      return node.operator == "&&" ? make_node(AST_Conditional, node, {
        condition: node.left,
        consequent: node.right.right,
        alternative: value
      }) : make_node(AST_Conditional, node, {
        condition: node.left,
        consequent: value,
        alternative: node.right.right
      });
      function safe_from_assignment(node2) {
        if (node2.has_side_effects(compressor))
          return;
        var hit = false;
        node2.walk(new TreeWalker(function(node3) {
          if (hit)
            return true;
          if (node3 instanceof AST_SymbolRef && node3.definition() === def)
            return hit = true;
        }));
        return !hit;
      }
    }
    OPT(AST_Sequence, function(self, compressor) {
      var expressions = filter_for_side_effects();
      var end = expressions.length - 1;
      merge_assignments();
      trim_right_for_undefined();
      if (end == 0) {
        self = maintain_this_binding(compressor, compressor.parent(), compressor.self(), expressions[0]);
        if (!(self instanceof AST_Sequence))
          self = self.optimize(compressor);
        return self;
      }
      self.expressions = expressions;
      return self;
      function filter_for_side_effects() {
        if (!compressor.option("side_effects"))
          return self.expressions;
        var expressions2 = [];
        var first = first_in_statement(compressor);
        var last = self.expressions.length - 1;
        self.expressions.forEach(function(expr, index) {
          if (index < last)
            expr = expr.drop_side_effect_free(compressor, first);
          if (expr) {
            merge_sequence(expressions2, expr);
            first = false;
          }
        });
        return expressions2;
      }
      function trim_right_for_undefined() {
        if (!compressor.option("side_effects"))
          return;
        while (end > 0 && is_undefined(expressions[end], compressor))
          end--;
        if (end < expressions.length - 1) {
          expressions[end] = make_node(AST_UnaryPrefix, self, {
            operator: "void",
            expression: expressions[end]
          });
          expressions.length = end + 1;
        }
      }
      function is_simple_assign(node) {
        return node instanceof AST_Assign && node.operator == "=" && node.left instanceof AST_SymbolRef && node.left.definition();
      }
      function merge_assignments() {
        for (var i = 1;i < end; i++) {
          var prev = expressions[i - 1];
          var def = is_simple_assign(prev);
          if (!def)
            continue;
          var expr = expressions[i];
          if (compressor.option("conditionals")) {
            var cond = to_conditional_assignment(compressor, def, prev.right, expr);
            if (cond) {
              prev.right = cond;
              expressions.splice(i--, 1);
              end--;
              continue;
            }
          }
          if (compressor.option("dead_code") && is_simple_assign(expr) === def && expr.right.is_constant_expression(def.scope.resolve())) {
            expressions[--i] = prev.right;
          }
        }
      }
    });
    OPT(AST_UnaryPostfix, function(self, compressor) {
      if (compressor.option("sequences")) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      return try_evaluate(compressor, self);
    });
    var SIGN_OPS = makePredicate("+ -");
    var MULTIPLICATIVE_OPS = makePredicate("* / %");
    OPT(AST_UnaryPrefix, function(self, compressor) {
      var op = self.operator;
      var exp = self.expression;
      if (compressor.option("evaluate") && op == "delete" && !may_not_delete(exp)) {
        return make_sequence(self, [exp, make_node(AST_True, self)]).optimize(compressor);
      }
      if (compressor.option("sequences") && can_lift()) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("side_effects") && op == "void") {
        exp = exp.drop_side_effect_free(compressor);
        if (!exp)
          return make_node(AST_Undefined, self).optimize(compressor);
        self.expression = exp;
        return self;
      }
      if (compressor.option("booleans")) {
        if (op == "!" && exp.is_truthy()) {
          return make_sequence(self, [exp, make_node(AST_False, self)]).optimize(compressor);
        } else if (compressor.in_boolean_context())
          switch (op) {
            case "!":
              if (exp instanceof AST_UnaryPrefix && exp.operator == "!") {
                return exp.expression;
              }
              if (exp instanceof AST_Binary) {
                self = best_of(compressor, self, exp.negate(compressor, first_in_statement(compressor)));
              }
              break;
            case "typeof":
              AST_Node.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
              var exprs = [make_node(AST_True, self)];
              if (!(exp instanceof AST_SymbolRef && can_drop_symbol(exp, compressor)))
                exprs.unshift(exp);
              return make_sequence(self, exprs).optimize(compressor);
          }
      }
      if (op == "-" && exp instanceof AST_Infinity)
        exp = exp.transform(compressor);
      if (compressor.option("evaluate") && exp instanceof AST_Binary && SIGN_OPS[op] && MULTIPLICATIVE_OPS[exp.operator] && (exp.left.is_constant() || !exp.right.has_side_effects(compressor))) {
        return make_node(AST_Binary, self, {
          operator: exp.operator,
          left: make_node(AST_UnaryPrefix, exp.left, {
            operator: op,
            expression: exp.left
          }),
          right: exp.right
        });
      }
      return op == "-" && (exp instanceof AST_Number || exp instanceof AST_Infinity) ? self : try_evaluate(compressor, self);
      function may_not_delete(node) {
        return node instanceof AST_Infinity || node instanceof AST_NaN || node instanceof AST_NewTarget || node instanceof AST_PropAccess || node instanceof AST_SymbolRef || node instanceof AST_Undefined;
      }
      function can_lift() {
        switch (op) {
          case "delete":
            return !may_not_delete(exp.tail_node());
          case "typeof":
            return !is_undeclared_ref(exp.tail_node());
          default:
            return true;
        }
      }
    });
    OPT(AST_Await, function(self, compressor) {
      if (!compressor.option("awaits"))
        return self;
      if (compressor.option("sequences")) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("side_effects")) {
        var exp = self.expression;
        if (exp instanceof AST_Await)
          return exp.optimize(compressor);
        if (exp instanceof AST_UnaryPrefix) {
          if (exp.expression instanceof AST_Await)
            return exp.optimize(compressor);
          if (exp.operator == "void")
            return make_node(AST_UnaryPrefix, self, {
              operator: "void",
              expression: make_node(AST_Await, self, { expression: exp.expression })
            }).optimize(compressor);
        }
        for (var level = 0, node = self, parent;parent = compressor.parent(level++); node = parent) {
          if (is_arrow(parent)) {
            if (parent.value === node)
              return exp.optimize(compressor);
          } else if (parent instanceof AST_Return) {
            var drop = true;
            do {
              node = parent;
              parent = compressor.parent(level++);
              if (parent instanceof AST_Try && parent.bfinally && parent.bfinally !== node) {
                drop = false;
                break;
              }
            } while (parent && !(parent instanceof AST_Scope));
            if (drop)
              return exp.optimize(compressor);
          } else if (parent instanceof AST_Sequence) {
            if (parent.tail_node() === node)
              continue;
          }
          break;
        }
      }
      return self;
    });
    OPT(AST_Yield, function(self, compressor) {
      if (!compressor.option("yields"))
        return self;
      if (compressor.option("sequences")) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      var exp = self.expression;
      if (self.nested && exp.TYPE == "Call") {
        var inlined = exp.clone().optimize(compressor);
        if (inlined.TYPE != "Call")
          return inlined;
      }
      return self;
    });
    AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
      if (this.left instanceof AST_PropAccess) {
        if (!(this.left.expression instanceof AST_Sequence))
          return this;
        var x2 = this.left.expression.expressions.slice();
        var e = this.clone();
        e.left = e.left.clone();
        e.left.expression = x2.pop();
        x2.push(e);
        return make_sequence(this, x2);
      }
      if (this.left instanceof AST_Sequence) {
        var x2 = this.left.expressions.slice();
        var e = this.clone();
        e.left = x2.pop();
        x2.push(e);
        return make_sequence(this, x2);
      }
      if (this.right instanceof AST_Sequence) {
        if (this.left.has_side_effects(compressor))
          return this;
        var assign = this.operator == "=" && this.left instanceof AST_SymbolRef;
        var x2 = this.right.expressions;
        var last = x2.length - 1;
        for (var i = 0;i < last; i++) {
          if (!assign && x2[i].has_side_effects(compressor))
            break;
        }
        if (i == last) {
          x2 = x2.slice();
          var e = this.clone();
          e.right = x2.pop();
          x2.push(e);
          return make_sequence(this, x2);
        }
        if (i > 0) {
          var e = this.clone();
          e.right = make_sequence(this.right, x2.slice(i));
          x2 = x2.slice(0, i);
          x2.push(e);
          return make_sequence(this, x2);
        }
      }
      return this;
    });
    var indexFns = makePredicate("indexOf lastIndexOf");
    var commutativeOperators = makePredicate("== === != !== * & | ^");
    function is_object(node) {
      if (node instanceof AST_Assign)
        return node.operator == "=" && is_object(node.right);
      if (node instanceof AST_Sequence)
        return is_object(node.tail_node());
      if (node instanceof AST_SymbolRef)
        return is_object(node.fixed_value());
      return node instanceof AST_Array || node instanceof AST_Class || node instanceof AST_Lambda || node instanceof AST_New || node instanceof AST_Object;
    }
    function is_primitive(compressor, node) {
      if (node.is_constant())
        return true;
      if (node instanceof AST_Assign)
        return node.operator != "=" || is_primitive(compressor, node.right);
      if (node instanceof AST_Binary) {
        return !lazy_op[node.operator] || is_primitive(compressor, node.left) && is_primitive(compressor, node.right);
      }
      if (node instanceof AST_Conditional) {
        return is_primitive(compressor, node.consequent) && is_primitive(compressor, node.alternative);
      }
      if (node instanceof AST_Sequence)
        return is_primitive(compressor, node.tail_node());
      if (node instanceof AST_SymbolRef) {
        var fixed = node.fixed_value();
        return fixed && is_primitive(compressor, fixed);
      }
      if (node instanceof AST_Template)
        return !node.tag || is_raw_tag(compressor, node.tag);
      if (node instanceof AST_Unary)
        return true;
    }
    function repeatable(compressor, node) {
      if (node instanceof AST_Dot)
        return repeatable(compressor, node.expression);
      if (node instanceof AST_Sub) {
        return repeatable(compressor, node.expression) && repeatable(compressor, node.property);
      }
      if (node instanceof AST_Symbol)
        return true;
      return !node.has_side_effects(compressor);
    }
    OPT(AST_Binary, function(self, compressor) {
      function reversible() {
        return self.left.is_constant() || self.right.is_constant() || !self.left.has_side_effects(compressor) && !self.right.has_side_effects(compressor);
      }
      function reverse(op2) {
        if (reversible()) {
          if (op2)
            self.operator = op2;
          var tmp = self.left;
          self.left = self.right;
          self.right = tmp;
        }
      }
      function swap_chain() {
        var rhs2 = self.right;
        self.left = make_node(AST_Binary, self, {
          operator: self.operator,
          left: self.left,
          right: rhs2.left,
          start: self.left.start,
          end: rhs2.left.end
        });
        self.right = rhs2.right;
        self.left = self.left.transform(compressor);
      }
      if (commutativeOperators[self.operator] && self.right.is_constant() && !self.left.is_constant() && !(self.left instanceof AST_Binary && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
        reverse();
      }
      if (compressor.option("sequences")) {
        var seq = self.lift_sequences(compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("assignments") && lazy_op[self.operator]) {
        var assign = self.right;
        if (self.left instanceof AST_SymbolRef && assign instanceof AST_Assign && assign.operator == "=" && self.left.equivalent_to(assign.left)) {
          self.right = assign.right;
          assign.right = self;
          return assign;
        }
      }
      if (compressor.option("comparisons"))
        switch (self.operator) {
          case "===":
          case "!==":
            if (is_undefined(self.left, compressor) && self.right.is_defined(compressor)) {
              AST_Node.warn("Expression always defined [{file}:{line},{col}]", self.start);
              return make_sequence(self, [
                self.right,
                make_node(self.operator == "===" ? AST_False : AST_True, self)
              ]).optimize(compressor);
            }
            var is_strict_comparison = true;
            if (self.left.is_string(compressor) && self.right.is_string(compressor) || self.left.is_number(compressor) && self.right.is_number(compressor) || self.left.is_boolean(compressor) && self.right.is_boolean(compressor) || repeatable(compressor, self.left) && self.left.equivalent_to(self.right)) {
              self.operator = self.operator.slice(0, 2);
            }
          case "==":
          case "!=":
            if (!is_strict_comparison && is_undefined(self.left, compressor)) {
              self.left = make_node(AST_Null, self.left);
            } else if (compressor.option("typeofs") && self.left instanceof AST_String && self.left.value == "undefined" && self.right instanceof AST_UnaryPrefix && self.right.operator == "typeof") {
              var expr = self.right.expression;
              if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor) : !(expr instanceof AST_PropAccess && compressor.option("ie"))) {
                self.right = expr;
                self.left = make_node(AST_Undefined, self.left).optimize(compressor);
                if (self.operator.length == 2)
                  self.operator += "=";
              }
            } else if (self.left instanceof AST_SymbolRef && self.right instanceof AST_SymbolRef && self.left.definition() === self.right.definition() && is_object(self.left)) {
              return make_node(self.operator[0] == "=" ? AST_True : AST_False, self).optimize(compressor);
            }
            break;
          case "&&":
          case "||":
            var lhs = self.left;
            if (lhs.operator == self.operator) {
              lhs = lhs.right;
            }
            if (lhs instanceof AST_Binary && lhs.operator == (self.operator == "&&" ? "!==" : "===") && self.right instanceof AST_Binary && lhs.operator == self.right.operator && (is_undefined(lhs.left, compressor) && self.right.left instanceof AST_Null || lhs.left instanceof AST_Null && is_undefined(self.right.left, compressor)) && !lhs.right.has_side_effects(compressor) && lhs.right.equivalent_to(self.right.right)) {
              var combined = make_node(AST_Binary, self, {
                operator: lhs.operator.slice(0, -1),
                left: make_node(AST_Null, self),
                right: lhs.right
              });
              if (lhs !== self.left) {
                combined = make_node(AST_Binary, self, {
                  operator: self.operator,
                  left: self.left.left,
                  right: combined
                });
              }
              return combined;
            }
            break;
        }
      var in_bool = false;
      var parent = compressor.parent();
      if (compressor.option("booleans")) {
        var lhs = self.left;
        if (lazy_op[self.operator] && !lhs.has_side_effects(compressor)) {
          if (lhs.equivalent_to(self.right)) {
            return maintain_this_binding(compressor, parent, compressor.self(), lhs).optimize(compressor);
          }
          mark_duplicate_condition(compressor, lhs);
        }
        in_bool = compressor.in_boolean_context();
      }
      if (in_bool)
        switch (self.operator) {
          case "+":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if (ll && typeof ll == "string") {
              AST_Node.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
              return make_sequence(self, [
                self.right,
                make_node(AST_True, self)
              ]).optimize(compressor);
            }
            if (rr && typeof rr == "string") {
              AST_Node.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
              return make_sequence(self, [
                self.left,
                make_node(AST_True, self)
              ]).optimize(compressor);
            }
            break;
          case "==":
            if (self.left instanceof AST_String && self.left.value == "" && self.right.is_string(compressor)) {
              return make_node(AST_UnaryPrefix, self, {
                operator: "!",
                expression: self.right
              }).optimize(compressor);
            }
            break;
          case "!=":
            if (self.left instanceof AST_String && self.left.value == "" && self.right.is_string(compressor)) {
              return self.right.optimize(compressor);
            }
            break;
        }
      if (compressor.option("comparisons") && self.is_boolean(compressor)) {
        if (!(parent instanceof AST_Binary) || parent instanceof AST_Assign) {
          var negated = best_of(compressor, self, make_node(AST_UnaryPrefix, self, {
            operator: "!",
            expression: self.negate(compressor, first_in_statement(compressor))
          }));
          if (negated !== self)
            return negated;
        }
        switch (self.operator) {
          case ">":
            reverse("<");
            break;
          case ">=":
            reverse("<=");
            break;
        }
      }
      if (compressor.option("conditionals") && lazy_op[self.operator] && self.right instanceof AST_Binary && self.operator == self.right.operator) {
        swap_chain();
      }
      if (compressor.option("strings") && self.operator == "+") {
        if (self.right instanceof AST_String && self.right.value == "" && self.left.is_string(compressor)) {
          return self.left.optimize(compressor);
        }
        if (self.left instanceof AST_String && self.left.value == "" && self.right.is_string(compressor)) {
          return self.right.optimize(compressor);
        }
        if (self.left instanceof AST_Binary && self.left.operator == "+" && self.left.left instanceof AST_String && self.left.left.value == "" && self.right.is_string(compressor)) {
          self.left = self.left.right;
          return self.optimize(compressor);
        }
        if (self.right instanceof AST_Binary && self.operator == self.right.operator && (self.left.is_string(compressor) && self.right.is_string(compressor) || self.right.left.is_string(compressor) && (self.left.is_constant() || !self.right.right.has_side_effects(compressor)))) {
          swap_chain();
        }
      }
      if (compressor.option("evaluate")) {
        var associative = true;
        switch (self.operator) {
          case "&&":
            var ll = fuzzy_eval(compressor, self.left);
            if (!ll) {
              AST_Node.warn("Condition left of && always false [{file}:{line},{col}]", self.start);
              return maintain_this_binding(compressor, parent, compressor.self(), self.left).optimize(compressor);
            } else if (!(ll instanceof AST_Node)) {
              AST_Node.warn("Condition left of && always true [{file}:{line},{col}]", self.start);
              return make_sequence(self, [self.left, self.right]).optimize(compressor);
            }
            var rr = self.right.evaluate(compressor);
            if (!rr) {
              if (in_bool) {
                AST_Node.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                return make_sequence(self, [
                  self.left,
                  make_node(AST_False, self)
                ]).optimize(compressor);
              } else
                self.falsy = true;
            } else if (!(rr instanceof AST_Node)) {
              if (in_bool || parent.operator == "&&" && parent.left === compressor.self()) {
                AST_Node.warn("Dropping side-effect-free && [{file}:{line},{col}]", self.start);
                return self.left.optimize(compressor);
              }
            }
            if (self.left.operator == "||") {
              var lr = fuzzy_eval(compressor, self.left.right);
              if (!lr)
                return make_node(AST_Conditional, self, {
                  condition: self.left.left,
                  consequent: self.right,
                  alternative: self.left.right
                }).optimize(compressor);
            }
            break;
          case "??":
            var nullish = true;
          case "||":
            var ll = fuzzy_eval(compressor, self.left, nullish);
            if (nullish ? ll == null : !ll) {
              AST_Node.warn("Condition left of {operator} always {value} [{file}:{line},{col}]", {
                operator: self.operator,
                value: nullish ? "nulish" : "false",
                file: self.start.file,
                line: self.start.line,
                col: self.start.col
              });
              return make_sequence(self, [self.left, self.right]).optimize(compressor);
            } else if (!(ll instanceof AST_Node)) {
              AST_Node.warn("Condition left of {operator} always {value} [{file}:{line},{col}]", {
                operator: self.operator,
                value: nullish ? "defined" : "true",
                file: self.start.file,
                line: self.start.line,
                col: self.start.col
              });
              return maintain_this_binding(compressor, parent, compressor.self(), self.left).optimize(compressor);
            }
            var rr = self.right.evaluate(compressor);
            if (!rr) {
              if (in_bool || parent.operator == "||" && parent.left === compressor.self()) {
                AST_Node.warn("Dropping side-effect-free {operator} [{file}:{line},{col}]", {
                  operator: self.operator,
                  file: self.start.file,
                  line: self.start.line,
                  col: self.start.col
                });
                return self.left.optimize(compressor);
              }
            } else if (!nullish && !(rr instanceof AST_Node)) {
              if (in_bool) {
                AST_Node.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                return make_sequence(self, [
                  self.left,
                  make_node(AST_True, self)
                ]).optimize(compressor);
              } else
                self.truthy = true;
            }
            if (!nullish && self.left.operator == "&&") {
              var lr = fuzzy_eval(compressor, self.left.right);
              if (lr && !(lr instanceof AST_Node))
                return make_node(AST_Conditional, self, {
                  condition: self.left.left,
                  consequent: self.left.right,
                  alternative: self.right
                }).optimize(compressor);
            }
            break;
          case "+":
            if (self.left instanceof AST_Constant && self.right instanceof AST_Binary && self.right.operator == "+" && self.right.left instanceof AST_Constant && self.right.is_string(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "+",
                left: make_node(AST_String, self.left, {
                  value: "" + self.left.value + self.right.left.value,
                  start: self.left.start,
                  end: self.right.left.end
                }),
                right: self.right.right
              });
            }
            if (self.right instanceof AST_Constant && self.left instanceof AST_Binary && self.left.operator == "+" && self.left.right instanceof AST_Constant && self.left.is_string(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "+",
                left: self.left.left,
                right: make_node(AST_String, self.right, {
                  value: "" + self.left.right.value + self.right.value,
                  start: self.left.right.start,
                  end: self.right.end
                })
              });
            }
            if (self.right instanceof AST_UnaryPrefix && self.right.operator == "-" && self.left.is_number(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "-",
                left: self.left,
                right: self.right.expression
              });
              break;
            }
            if (self.left instanceof AST_UnaryPrefix && self.left.operator == "-" && reversible() && self.right.is_number(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "-",
                left: self.right,
                right: self.left.expression
              });
              break;
            }
            if (compressor.option("unsafe_math") && self.left instanceof AST_Binary && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator] && self.right.is_constant() && (self.right.is_boolean(compressor) || self.right.is_number(compressor)) && self.left.is_number(compressor) && !self.left.right.is_constant() && (self.left.left.is_boolean(compressor) || self.left.left.is_number(compressor))) {
              self = make_node(AST_Binary, self, {
                operator: self.left.operator,
                left: make_node(AST_Binary, self, {
                  operator: self.operator,
                  left: self.right,
                  right: self.left.left
                }),
                right: self.left.right
              });
              break;
            }
          case "-":
            if (self.right instanceof AST_UnaryPrefix && self.right.operator == "-" && self.left.is_number(compressor) && self.right.expression.is_number(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "+",
                left: self.left,
                right: self.right.expression
              });
              break;
            }
          case "*":
          case "/":
            associative = compressor.option("unsafe_math");
            if (self.operator != "+")
              ["left", "right"].forEach(function(operand) {
                var node2 = self[operand];
                if (node2 instanceof AST_UnaryPrefix && node2.operator == "+") {
                  var exp = node2.expression;
                  if (exp.is_boolean(compressor) || exp.is_number(compressor) || exp.is_string(compressor)) {
                    self[operand] = exp;
                  }
                }
              });
          case "&":
          case "|":
          case "^":
            if (self.operator != "-" && self.operator != "/" && (self.left.is_boolean(compressor) || self.left.is_number(compressor)) && (self.right.is_boolean(compressor) || self.right.is_number(compressor)) && reversible() && !(self.left instanceof AST_Binary && self.left.operator != self.operator && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
              var reversed = make_node(AST_Binary, self, {
                operator: self.operator,
                left: self.right,
                right: self.left
              });
              if (self.right instanceof AST_Constant && !(self.left instanceof AST_Constant)) {
                self = best_of(compressor, reversed, self);
              } else {
                self = best_of(compressor, self, reversed);
              }
            }
            if (!associative || !self.is_number(compressor))
              break;
            if (self.right instanceof AST_Binary && self.right.operator != "%" && PRECEDENCE[self.right.operator] == PRECEDENCE[self.operator] && self.right.is_number(compressor) && (self.operator != "+" || self.right.left.is_boolean(compressor) || self.right.left.is_number(compressor)) && (self.operator != "-" || !self.left.is_negative_zero()) && (self.right.left.is_constant_expression() || !self.right.right.has_side_effects(compressor)) && !is_modify_array(self.right.right)) {
              self = make_node(AST_Binary, self, {
                operator: align(self.operator, self.right.operator),
                left: make_node(AST_Binary, self.left, {
                  operator: self.operator,
                  left: self.left,
                  right: self.right.left,
                  start: self.left.start,
                  end: self.right.left.end
                }),
                right: self.right.right
              });
              if (self.operator == "+" && !self.right.is_boolean(compressor) && !self.right.is_number(compressor)) {
                self.right = make_node(AST_UnaryPrefix, self.right, {
                  operator: "+",
                  expression: self.right
                });
              }
            }
            if (self.right instanceof AST_Constant && self.left instanceof AST_Binary && self.left.operator != "%" && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator] && self.left.is_number(compressor)) {
              if (self.left.left instanceof AST_Constant) {
                var lhs = make_binary(self.left, self.operator, self.left.left, self.right, self.left.left.start, self.right.end);
                self = make_binary(self, self.left.operator, try_evaluate(compressor, lhs), self.left.right);
              } else if (self.left.right instanceof AST_Constant) {
                var op = align(self.left.operator, self.operator);
                var rhs = try_evaluate(compressor, make_binary(self.left, op, self.left.right, self.right));
                if (rhs.is_constant() && !(self.left.operator == "-" && self.right.value != 0 && +rhs.value == 0 && self.left.left.is_negative_zero())) {
                  self = make_binary(self, self.left.operator, self.left.left, rhs);
                }
              }
            }
            break;
        }
        if (!(parent instanceof AST_UnaryPrefix && parent.operator == "delete")) {
          if (self.left instanceof AST_Number && !self.right.is_constant())
            switch (self.operator) {
              case "+":
                if (self.left.value == 0) {
                  if (self.right.is_boolean(compressor))
                    return make_node(AST_UnaryPrefix, self, {
                      operator: "+",
                      expression: self.right
                    }).optimize(compressor);
                  if (self.right.is_number(compressor) && !self.right.is_negative_zero())
                    return self.right;
                }
                break;
              case "*":
                if (self.left.value == 1) {
                  return self.right.is_number(compressor) ? self.right : make_node(AST_UnaryPrefix, self, {
                    operator: "+",
                    expression: self.right
                  }).optimize(compressor);
                }
                break;
            }
          if (self.right instanceof AST_Number && !self.left.is_constant())
            switch (self.operator) {
              case "+":
                if (self.right.value == 0) {
                  if (self.left.is_boolean(compressor))
                    return make_node(AST_UnaryPrefix, self, {
                      operator: "+",
                      expression: self.left
                    }).optimize(compressor);
                  if (self.left.is_number(compressor) && !self.left.is_negative_zero())
                    return self.left;
                }
                break;
              case "-":
                if (self.right.value == 0) {
                  return self.left.is_number(compressor) ? self.left : make_node(AST_UnaryPrefix, self, {
                    operator: "+",
                    expression: self.left
                  }).optimize(compressor);
                }
                break;
              case "/":
                if (self.right.value == 1) {
                  return self.left.is_number(compressor) ? self.left : make_node(AST_UnaryPrefix, self, {
                    operator: "+",
                    expression: self.left
                  }).optimize(compressor);
                }
                break;
            }
        }
      }
      if (compressor.option("typeofs"))
        switch (self.operator) {
          case "&&":
            mark_locally_defined(self.left, self.right, null);
            break;
          case "||":
            mark_locally_defined(self.left, null, self.right);
            break;
        }
      if (compressor.option("unsafe")) {
        var indexRight = is_indexFn(self.right);
        if (in_bool && indexRight && (self.operator == "==" || self.operator == "!=") && self.left instanceof AST_Number && self.left.value == 0) {
          return (self.operator == "==" ? make_node(AST_UnaryPrefix, self, {
            operator: "!",
            expression: self.right
          }) : self.right).optimize(compressor);
        }
        var indexLeft = is_indexFn(self.left);
        if (compressor.option("comparisons") && is_indexOf_match_pattern()) {
          var node = make_node(AST_UnaryPrefix, self, {
            operator: "!",
            expression: make_node(AST_UnaryPrefix, self, {
              operator: "~",
              expression: indexLeft ? self.left : self.right
            })
          });
          switch (self.operator) {
            case "<":
              if (indexLeft)
                break;
            case "<=":
            case "!=":
              node = make_node(AST_UnaryPrefix, self, {
                operator: "!",
                expression: node
              });
              break;
          }
          return node.optimize(compressor);
        }
      }
      return try_evaluate(compressor, self);
      function is_modify_array(node2) {
        var found = false;
        node2.walk(new TreeWalker(function(node3) {
          if (found)
            return true;
          if (node3 instanceof AST_Assign) {
            if (node3.left instanceof AST_PropAccess)
              return found = true;
          } else if (node3 instanceof AST_Unary) {
            if (unary_side_effects[node3.operator] && node3.expression instanceof AST_PropAccess) {
              return found = true;
            }
          }
        }));
        return found;
      }
      function align(ref, op2) {
        switch (ref) {
          case "-":
            return op2 == "+" ? "-" : "+";
          case "/":
            return op2 == "*" ? "/" : "*";
          default:
            return op2;
        }
      }
      function make_binary(orig, op2, left, right, start, end) {
        if (op2 == "+") {
          if (!left.is_boolean(compressor) && !left.is_number(compressor)) {
            left = make_node(AST_UnaryPrefix, left, {
              operator: "+",
              expression: left
            });
          }
          if (!right.is_boolean(compressor) && !right.is_number(compressor)) {
            right = make_node(AST_UnaryPrefix, right, {
              operator: "+",
              expression: right
            });
          }
        }
        return make_node(AST_Binary, orig, {
          operator: op2,
          left,
          right,
          start,
          end
        });
      }
      function is_indexFn(node2) {
        return node2.TYPE == "Call" && node2.expression instanceof AST_Dot && indexFns[node2.expression.property];
      }
      function is_indexOf_match_pattern() {
        switch (self.operator) {
          case "<=":
            return indexRight && self.left instanceof AST_Number && self.left.value == 0;
          case "<":
            if (indexLeft && self.right instanceof AST_Number && self.right.value == 0)
              return true;
          case "==":
          case "!=":
            if (!indexRight)
              return false;
            return self.left instanceof AST_Number && self.left.value == -1 || self.left instanceof AST_UnaryPrefix && self.left.operator == "-" && self.left.expression instanceof AST_Number && self.left.expression.value == 1;
        }
      }
    });
    OPT(AST_SymbolExport, function(self) {
      return self;
    });
    function recursive_ref(compressor, def, fn) {
      var level = 0, node = compressor.self();
      do {
        if (node === fn)
          return node;
        if (is_lambda(node) && node.name && node.name.definition() === def)
          return node;
      } while (node = compressor.parent(level++));
    }
    function same_scope(def) {
      var scope = def.scope.resolve();
      return all(def.references, function(ref) {
        return scope === ref.scope.resolve();
      });
    }
    OPT(AST_SymbolRef, function(self, compressor) {
      if (!compressor.option("ie") && is_undeclared_ref(self) && !(self.scope.resolve().uses_with && compressor.find_parent(AST_With))) {
        switch (self.name) {
          case "undefined":
            return make_node(AST_Undefined, self).optimize(compressor);
          case "NaN":
            return make_node(AST_NaN, self).optimize(compressor);
          case "Infinity":
            return make_node(AST_Infinity, self).optimize(compressor);
        }
      }
      var parent = compressor.parent();
      if (compressor.option("reduce_vars") && is_lhs(compressor.self(), parent) !== compressor.self()) {
        var def = self.definition();
        var fixed = self.fixed_value();
        var single_use = def.single_use && !(parent instanceof AST_Call && parent.is_expr_pure(compressor));
        if (single_use) {
          if (is_lambda(fixed)) {
            if ((def.scope !== self.scope.resolve() || def.in_loop) && (!compressor.option("reduce_funcs") || def.escaped.depth == 1 || fixed.inlined)) {
              single_use = false;
            } else if (recursive_ref(compressor, def, fixed)) {
              single_use = false;
            } else if (fixed.name && fixed.name.definition() !== def) {
              single_use = false;
            } else if (fixed.parent_scope !== self.scope || is_funarg(def)) {
              single_use = fixed.is_constant_expression(self.scope);
              if (single_use == "f") {
                var scope = self.scope;
                do {
                  if (scope instanceof AST_LambdaDefinition || scope instanceof AST_LambdaExpression) {
                    scope.inlined = true;
                  }
                } while (scope = scope.parent_scope);
              }
            } else if (fixed.name && (fixed.name.name == "await" && is_async(fixed) || fixed.name.name == "yield" && is_generator(fixed))) {
              single_use = false;
            } else if (fixed.has_side_effects(compressor)) {
              single_use = false;
            } else if (compressor.option("ie") && fixed instanceof AST_Class) {
              single_use = false;
            }
            if (single_use)
              fixed.parent_scope = self.scope;
          } else if (!fixed || def.recursive_refs > 0 || !fixed.is_constant_expression() || fixed.drop_side_effect_free(compressor)) {
            single_use = false;
          }
        }
        if (single_use) {
          def.single_use = false;
          fixed._squeezed = true;
          fixed.single_use = true;
          if (fixed instanceof AST_DefClass)
            fixed = to_class_expr(fixed);
          if (fixed instanceof AST_LambdaDefinition)
            fixed = to_func_expr(fixed);
          if (is_lambda(fixed)) {
            var scope = self.scope.resolve();
            fixed.enclosed.forEach(function(def2) {
              if (fixed.variables.has(def2.name))
                return;
              if (scope.var_names()[def2.name])
                return;
              scope.enclosed.push(def2);
              scope.var_names()[def2.name] = true;
            });
          }
          var value;
          if (def.recursive_refs > 0) {
            value = fixed.clone(true);
            var defun_def = value.name.definition();
            var lambda_def = value.variables.get(value.name.name);
            var name = lambda_def && lambda_def.orig[0];
            var def_fn_name, symbol_type;
            if (value instanceof AST_Class) {
              def_fn_name = "def_function";
              symbol_type = AST_SymbolClass;
            } else {
              def_fn_name = "def_variable";
              symbol_type = AST_SymbolLambda;
            }
            if (!(name instanceof symbol_type)) {
              name = make_node(symbol_type, value.name, value.name);
              name.scope = value;
              value.name = name;
              lambda_def = value[def_fn_name](name);
              lambda_def.recursive_refs = def.recursive_refs;
            }
            value.walk(new TreeWalker(function(node) {
              if (node instanceof AST_SymbolDeclaration) {
                if (node !== name) {
                  var def2 = node.definition();
                  def2.orig.push(node);
                  def2.eliminated++;
                }
                return;
              }
              if (!(node instanceof AST_SymbolRef))
                return;
              var def2 = node.definition();
              if (def2 === defun_def) {
                node.thedef = def2 = lambda_def;
              } else {
                def2.single_use = false;
                var fn = node.fixed_value();
                if (is_lambda(fn) && fn.name && fn.name.definition() === def2 && def2.scope === fn.name.scope && fixed.variables.get(fn.name.name) === def2) {
                  fn.name = fn.name.clone();
                  node.thedef = def2 = value.variables.get(fn.name.name) || value[def_fn_name](fn.name);
                }
              }
              def2.references.push(node);
            }));
          } else {
            if (fixed instanceof AST_Scope) {
              compressor.push(fixed);
              value = fixed.optimize(compressor);
              compressor.pop();
            } else {
              value = fixed.optimize(compressor);
            }
            value = value.transform(new TreeTransformer(function(node, descend) {
              if (node instanceof AST_Scope)
                return node;
              node = node.clone();
              descend(node, this);
              return node;
            }));
          }
          def.replaced++;
          return value;
        }
        var local = self.fixed !== def.fixed;
        if (fixed && (local || def.should_replace !== false)) {
          var ev, init;
          if (fixed instanceof AST_This) {
            if (!is_funarg(def) && same_scope(def))
              init = fixed;
          } else if ((ev = fixed.evaluate(compressor, true)) !== fixed && typeof ev != "function" && (ev === null || typeof ev != "object" || compressor.option("unsafe_regexp") && ev instanceof RegExp && !def.cross_loop && same_scope(def))) {
            init = make_node_from_constant(ev, fixed);
          }
          if (init) {
            if (!local && def.should_replace === undefined) {
              var value_length = init.optimize(compressor).print_to_string().length;
              if (!has_symbol_ref(fixed)) {
                value_length = Math.min(value_length, fixed.print_to_string().length);
              }
              var name_length = def.name.length;
              if (compressor.option("unused") && !compressor.exposed(def)) {
                var referenced = def.references.length - def.replaced;
                name_length += (name_length + 2 + value_length) / (referenced - def.assignments);
              }
              var delta = value_length - Math.floor(name_length);
              def.should_replace = delta < compressor.eval_threshold;
            }
            if (local || def.should_replace) {
              var value;
              if (has_symbol_ref(fixed)) {
                value = init.optimize(compressor);
                if (value === init)
                  value = value.clone(true);
              } else {
                value = best_of_expression(init.optimize(compressor), fixed);
                if (value === init || value === fixed)
                  value = value.clone(true);
              }
              def.replaced++;
              return value;
            }
          }
        }
      }
      return self;
      function has_symbol_ref(value2) {
        var found;
        value2.walk(new TreeWalker(function(node) {
          if (node instanceof AST_SymbolRef)
            found = true;
          if (found)
            return true;
        }));
        return found;
      }
    });
    function is_raw_tag(compressor, tag) {
      return compressor.option("unsafe") && tag instanceof AST_Dot && tag.property == "raw" && is_undeclared_ref(tag.expression) && tag.expression.name == "String";
    }
    OPT(AST_Template, function(self, compressor) {
      if (!compressor.option("templates"))
        return self;
      var tag = self.tag;
      if (!tag || is_raw_tag(compressor, tag)) {
        var exprs = self.expressions.slice();
        var strs = self.strings.slice();
        var CHANGED = false;
        for (var i = exprs.length;--i >= 0; ) {
          var node = exprs[i];
          var ev = node.evaluate(compressor);
          if (ev === node)
            continue;
          if (tag && /\r|\\|`/.test(ev))
            continue;
          ev = ("" + ev).replace(/\r|\\|`/g, function(s2) {
            return "\\" + (s2 == "\r" ? "r" : s2);
          });
          if (ev.length > node.print_to_string().length + 3)
            continue;
          var combined = strs[i] + ev + strs[i + 1];
          if (typeof make_node(AST_Template, self, {
            expressions: [],
            strings: [combined],
            tag
          }).evaluate(compressor) != typeof make_node(AST_Template, self, {
            expressions: [node],
            strings: strs.slice(i, i + 2),
            tag
          }).evaluate(compressor))
            continue;
          exprs.splice(i, 1);
          strs.splice(i, 2, combined);
          CHANGED = true;
        }
        if (CHANGED) {
          self.expressions = exprs;
          self.strings = strs;
        }
      }
      return try_evaluate(compressor, self);
    });
    function is_atomic(lhs, self) {
      return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;
    }
    OPT(AST_Undefined, function(self, compressor) {
      if (compressor.option("unsafe_undefined")) {
        var undef = find_scope(compressor).find_variable("undefined");
        if (undef) {
          var ref = make_node(AST_SymbolRef, self, {
            name: "undefined",
            scope: undef.scope,
            thedef: undef
          });
          ref.is_undefined = true;
          return ref;
        }
      }
      var lhs = is_lhs(compressor.self(), compressor.parent());
      if (lhs && is_atomic(lhs, self))
        return self;
      return make_node(AST_UnaryPrefix, self, {
        operator: "void",
        expression: make_node(AST_Number, self, {
          value: 0
        })
      });
    });
    OPT(AST_Infinity, function(self, compressor) {
      var lhs = is_lhs(compressor.self(), compressor.parent());
      if (lhs && is_atomic(lhs, self))
        return self;
      if (compressor.option("keep_infinity") && !lhs && !find_scope(compressor).find_variable("Infinity")) {
        return self;
      }
      return make_node(AST_Binary, self, {
        operator: "/",
        left: make_node(AST_Number, self, {
          value: 1
        }),
        right: make_node(AST_Number, self, {
          value: 0
        })
      });
    });
    OPT(AST_NaN, function(self, compressor) {
      var lhs = is_lhs(compressor.self(), compressor.parent());
      if (lhs && is_atomic(lhs, self))
        return self;
      if (!lhs && !find_scope(compressor).find_variable("NaN"))
        return self;
      return make_node(AST_Binary, self, {
        operator: "/",
        left: make_node(AST_Number, self, {
          value: 0
        }),
        right: make_node(AST_Number, self, {
          value: 0
        })
      });
    });
    function is_reachable(self, defs) {
      var reachable = false;
      var find_ref = new TreeWalker(function(node) {
        if (reachable)
          return true;
        if (node instanceof AST_SymbolRef && member(node.definition(), defs)) {
          return reachable = true;
        }
      });
      var scan_scope = new TreeWalker(function(node) {
        if (reachable)
          return true;
        if (node instanceof AST_Lambda && node !== self) {
          if (!(node.name || is_async(node) || is_generator(node))) {
            var parent = scan_scope.parent();
            if (parent instanceof AST_Call && parent.expression === node)
              return;
          }
          node.walk(find_ref);
          return true;
        }
      });
      self.walk(scan_scope);
      return reachable;
    }
    var ASSIGN_OPS = makePredicate("+ - * / % >> << >>> | ^ &");
    var ASSIGN_OPS_COMMUTATIVE = makePredicate("* | ^ &");
    OPT(AST_Assign, function(self, compressor) {
      if (compressor.option("dead_code")) {
        if (self.left instanceof AST_PropAccess) {
          if (self.operator == "=") {
            if (self.__drop) {
              var exprs = [self.left.expression];
              if (self.left instanceof AST_Sub)
                exprs.push(self.left.property);
              exprs.push(self.right);
              return make_sequence(self, exprs).optimize(compressor);
            }
            if (self.left.equivalent_to(self.right) && !self.left.has_side_effects(compressor)) {
              return self.right;
            }
            var exp = self.left.expression;
            if (exp instanceof AST_Lambda || !compressor.has_directive("use strict") && exp instanceof AST_Constant && !exp.may_throw_on_access(compressor)) {
              return self.left instanceof AST_Dot ? self.right : make_sequence(self, [
                self.left.property,
                self.right
              ]).optimize(compressor);
            }
          }
        } else if (self.left instanceof AST_SymbolRef && can_drop_symbol(self.left, compressor)) {
          var parent;
          if (self.operator == "=" && self.left.equivalent_to(self.right) && !((parent = compressor.parent()) instanceof AST_UnaryPrefix && parent.operator == "delete")) {
            return self.right;
          }
          if (self.left.is_immutable())
            return strip_assignment();
          var def = self.left.definition();
          var scope = def.scope.resolve();
          var local = scope === compressor.find_parent(AST_Lambda);
          var level = 0, node;
          parent = compressor.self();
          if (!(scope.uses_arguments && is_funarg(def)) || compressor.has_directive("use strict"))
            do {
              node = parent;
              parent = compressor.parent(level++);
              if (parent instanceof AST_Assign) {
                var found = false;
                if (parent.left.match_symbol(function(node2) {
                  if (node2 instanceof AST_PropAccess)
                    return true;
                  if (!found && node2 instanceof AST_SymbolRef && node2.definition() === def) {
                    if (in_try(level, parent))
                      return true;
                    found = true;
                  }
                }))
                  break;
                if (!found)
                  continue;
                return strip_assignment(def);
              }
              if (parent instanceof AST_Exit) {
                if (!local)
                  break;
                if (in_try(level, parent))
                  break;
                if (is_reachable(scope, [def]))
                  break;
                return strip_assignment(def);
              }
              if (parent instanceof AST_SimpleStatement) {
                if (!local)
                  break;
                if (is_reachable(scope, [def]))
                  break;
                var stat;
                do {
                  stat = parent;
                  parent = compressor.parent(level++);
                  if (parent === scope && is_last_statement(parent.body, stat))
                    return strip_assignment(def);
                } while (is_tail_block(stat, parent));
                break;
              }
              if (parent instanceof AST_VarDef) {
                if (!(parent.name instanceof AST_SymbolDeclaration))
                  continue;
                if (parent.name.definition() !== def)
                  continue;
                if (in_try(level, parent))
                  break;
                return strip_assignment(def);
              }
            } while (is_tail(node, parent));
        }
      }
      if (compressor.option("sequences")) {
        var seq = self.lift_sequences(compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("assignments")) {
        if (self.operator == "=" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {
          if (self.right.left instanceof AST_SymbolRef && self.right.left.name == self.left.name && ASSIGN_OPS[self.right.operator]) {
            return make_node(AST_Assign, self, {
              operator: self.right.operator + "=",
              left: self.left,
              right: self.right.right
            });
          }
          if (self.right.right instanceof AST_SymbolRef && self.right.right.name == self.left.name && ASSIGN_OPS_COMMUTATIVE[self.right.operator] && !self.right.left.has_side_effects(compressor)) {
            return make_node(AST_Assign, self, {
              operator: self.right.operator + "=",
              left: self.left,
              right: self.right.left
            });
          }
        }
        if ((self.operator == "-=" || self.operator == "+=" && (self.left.is_boolean(compressor) || self.left.is_number(compressor))) && self.right instanceof AST_Number && self.right.value == 1) {
          var op = self.operator.slice(0, -1);
          return make_node(AST_UnaryPrefix, self, {
            operator: op + op,
            expression: self.left
          });
        }
      }
      return try_evaluate(compressor, self);
      function is_tail(node2, parent2) {
        if (parent2 instanceof AST_Binary) {
          return parent2.right === node2 || parent2.right.is_constant_expression(scope);
        }
        if (parent2 instanceof AST_Conditional) {
          return parent2.condition !== node2 || parent2.consequent.is_constant_expression(scope) && parent2.alternative.is_constant_expression(scope);
        }
        if (parent2 instanceof AST_Sequence) {
          var exprs2 = parent2.expressions;
          var stop = exprs2.indexOf(node2);
          if (stop < 0)
            return false;
          for (var i = exprs2.length;--i > stop; ) {
            if (!exprs2[i].is_constant_expression(scope))
              return false;
          }
          return true;
        }
        if (parent2 instanceof AST_UnaryPrefix)
          return true;
      }
      function is_tail_block(stat2, parent2) {
        if (parent2 instanceof AST_BlockStatement)
          return is_last_statement(parent2.body, stat2);
        if (parent2 instanceof AST_Catch)
          return is_last_statement(parent2.body, stat2);
        if (parent2 instanceof AST_Finally)
          return is_last_statement(parent2.body, stat2);
        if (parent2 instanceof AST_If)
          return parent2.body === stat2 || parent2.alternative === stat2;
        if (parent2 instanceof AST_Try)
          return parent2.bfinally ? parent2.bfinally === stat2 : parent2.bcatch === stat2;
      }
      function in_try(level2, node2) {
        var right = self.right;
        self.right = make_node(AST_Null, right);
        var may_throw = node2.may_throw(compressor);
        self.right = right;
        for (var parent2;parent2 = compressor.parent(level2++); node2 = parent2) {
          if (parent2 === scope)
            return false;
          if (parent2 instanceof AST_Try) {
            if (parent2.bfinally && parent2.bfinally !== node2)
              return true;
            if (may_throw && parent2.bcatch && parent2.bcatch !== node2)
              return true;
          }
        }
      }
      function strip_assignment(def2) {
        if (def2)
          def2.fixed = false;
        return (self.operator != "=" ? make_node(AST_Binary, self, {
          operator: self.operator.slice(0, -1),
          left: self.left,
          right: self.right
        }) : maintain_this_binding(compressor, compressor.parent(), self, self.right)).optimize(compressor);
      }
    });
    OPT(AST_Conditional, function(self, compressor) {
      if (compressor.option("sequences") && self.condition instanceof AST_Sequence) {
        var expressions = self.condition.expressions.slice();
        self.condition = expressions.pop();
        expressions.push(self);
        return make_sequence(self, expressions);
      }
      if (!compressor.option("conditionals"))
        return self;
      var condition = self.condition;
      if (compressor.option("booleans") && !condition.has_side_effects(compressor)) {
        mark_duplicate_condition(compressor, condition);
      }
      condition = fuzzy_eval(compressor, condition);
      if (!condition) {
        AST_Node.warn("Condition always false [{file}:{line},{col}]", self.start);
        return make_sequence(self, [self.condition, self.alternative]).optimize(compressor);
      } else if (!(condition instanceof AST_Node)) {
        AST_Node.warn("Condition always true [{file}:{line},{col}]", self.start);
        return make_sequence(self, [self.condition, self.consequent]).optimize(compressor);
      }
      var negated = condition.negate(compressor, first_in_statement(compressor));
      if (best_of(compressor, condition, negated) === negated) {
        self = make_node(AST_Conditional, self, {
          condition: negated,
          consequent: self.alternative,
          alternative: self.consequent
        });
        negated = condition;
        condition = self.condition;
      }
      var consequent = self.consequent;
      var alternative = self.alternative;
      if (repeatable(compressor, condition)) {
        if (condition.equivalent_to(consequent))
          return make_node(AST_Binary, self, {
            operator: "||",
            left: condition,
            right: alternative
          }).optimize(compressor);
        if (condition.equivalent_to(alternative))
          return make_node(AST_Binary, self, {
            operator: "&&",
            left: condition,
            right: consequent
          }).optimize(compressor);
      }
      var seq_tail = consequent.tail_node();
      if (seq_tail instanceof AST_Assign) {
        var is_eq = seq_tail.operator == "=";
        var alt_tail = is_eq ? alternative.tail_node() : alternative;
        if ((is_eq || consequent === seq_tail) && alt_tail instanceof AST_Assign && seq_tail.operator == alt_tail.operator && seq_tail.left.equivalent_to(alt_tail.left) && (is_eq && seq_tail.left instanceof AST_SymbolRef || !condition.has_side_effects(compressor) && can_shift_lhs_of_tail(consequent) && can_shift_lhs_of_tail(alternative))) {
          return make_node(AST_Assign, self, {
            operator: seq_tail.operator,
            left: seq_tail.left,
            right: make_node(AST_Conditional, self, {
              condition,
              consequent: pop_lhs(consequent),
              alternative: pop_lhs(alternative)
            })
          });
        }
      }
      if (consequent.equivalent_to(alternative))
        return make_sequence(self, [
          condition,
          consequent
        ]).optimize(compressor);
      var combined = combine_tail(consequent, alternative, true);
      if (combined)
        return combined;
      var arg_index;
      if (consequent instanceof AST_Call && alternative.TYPE == consequent.TYPE && (arg_index = arg_diff(consequent, alternative)) >= 0 && consequent.expression.equivalent_to(alternative.expression) && !condition.has_side_effects(compressor) && !consequent.expression.has_side_effects(compressor)) {
        var node = consequent.clone();
        var arg = consequent.args[arg_index];
        node.args[arg_index] = arg instanceof AST_Spread ? make_node(AST_Spread, self, {
          expression: make_node(AST_Conditional, self, {
            condition,
            consequent: arg.expression,
            alternative: alternative.args[arg_index].expression
          })
        }) : make_node(AST_Conditional, self, {
          condition,
          consequent: arg,
          alternative: alternative.args[arg_index]
        });
        return node;
      }
      if (consequent instanceof AST_Conditional && consequent.alternative.equivalent_to(alternative)) {
        return make_node(AST_Conditional, self, {
          condition: make_node(AST_Binary, self, {
            left: condition,
            operator: "&&",
            right: consequent.condition
          }),
          consequent: consequent.consequent,
          alternative
        });
      }
      if (consequent instanceof AST_Conditional && consequent.consequent.equivalent_to(alternative)) {
        return make_node(AST_Conditional, self, {
          condition: make_node(AST_Binary, self, {
            left: negated,
            operator: "||",
            right: consequent.condition
          }),
          consequent: alternative,
          alternative: consequent.alternative
        });
      }
      if (alternative instanceof AST_Conditional && consequent.equivalent_to(alternative.consequent)) {
        return make_node(AST_Conditional, self, {
          condition: make_node(AST_Binary, self, {
            left: condition,
            operator: "||",
            right: alternative.condition
          }),
          consequent,
          alternative: alternative.alternative
        });
      }
      if (alternative instanceof AST_Conditional && consequent.equivalent_to(alternative.alternative)) {
        return make_node(AST_Conditional, self, {
          condition: make_node(AST_Binary, self, {
            left: negated,
            operator: "&&",
            right: alternative.condition
          }),
          consequent: alternative.consequent,
          alternative: consequent
        });
      }
      if ((consequent instanceof AST_Sequence || alternative instanceof AST_Sequence) && consequent.tail_node().equivalent_to(alternative.tail_node())) {
        return make_sequence(self, [
          make_node(AST_Conditional, self, {
            condition,
            consequent: pop_seq(consequent),
            alternative: pop_seq(alternative)
          }),
          consequent.tail_node()
        ]).optimize(compressor);
      }
      if (consequent instanceof AST_Binary && consequent.operator == "&&" && consequent.right.equivalent_to(alternative)) {
        return make_node(AST_Binary, self, {
          operator: "&&",
          left: make_node(AST_Binary, self, {
            operator: "||",
            left: negated,
            right: consequent.left
          }),
          right: alternative
        }).optimize(compressor);
      }
      if (consequent instanceof AST_Binary && consequent.operator == "||" && consequent.right.equivalent_to(alternative)) {
        return make_node(AST_Binary, self, {
          operator: "||",
          left: make_node(AST_Binary, self, {
            operator: "&&",
            left: condition,
            right: consequent.left
          }),
          right: alternative
        }).optimize(compressor);
      }
      if (alternative instanceof AST_Binary && alternative.operator == "&&" && alternative.right.equivalent_to(consequent)) {
        return make_node(AST_Binary, self, {
          operator: "&&",
          left: make_node(AST_Binary, self, {
            operator: "||",
            left: condition,
            right: alternative.left
          }),
          right: consequent
        }).optimize(compressor);
      }
      if (alternative instanceof AST_Binary && alternative.operator == "||" && alternative.right.equivalent_to(consequent)) {
        return make_node(AST_Binary, self, {
          operator: "||",
          left: make_node(AST_Binary, self, {
            operator: "&&",
            left: negated,
            right: alternative.left
          }),
          right: consequent
        }).optimize(compressor);
      }
      var in_bool = compressor.option("booleans") && compressor.in_boolean_context();
      if (is_true(consequent)) {
        if (is_false(alternative)) {
          return booleanize(condition);
        }
        return make_node(AST_Binary, self, {
          operator: "||",
          left: booleanize(condition),
          right: alternative
        });
      }
      if (is_false(consequent)) {
        if (is_true(alternative)) {
          return booleanize(condition.negate(compressor));
        }
        return make_node(AST_Binary, self, {
          operator: "&&",
          left: booleanize(condition.negate(compressor)),
          right: alternative
        });
      }
      if (is_true(alternative)) {
        return make_node(AST_Binary, self, {
          operator: "||",
          left: booleanize(condition.negate(compressor)),
          right: consequent
        });
      }
      if (is_false(alternative)) {
        return make_node(AST_Binary, self, {
          operator: "&&",
          left: booleanize(condition),
          right: consequent
        });
      }
      if (compressor.option("typeofs"))
        mark_locally_defined(condition, consequent, alternative);
      return self;
      function booleanize(node2) {
        if (node2.is_boolean(compressor))
          return node2;
        return make_node(AST_UnaryPrefix, node2, {
          operator: "!",
          expression: node2.negate(compressor)
        });
      }
      function is_true(node2) {
        return node2 instanceof AST_True || in_bool && node2 instanceof AST_Constant && node2.value || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && !node2.expression.value;
      }
      function is_false(node2) {
        return node2 instanceof AST_False || in_bool && (node2 instanceof AST_Constant && !node2.value || node2 instanceof AST_UnaryPrefix && node2.operator == "void" && !node2.expression.has_side_effects(compressor)) || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && node2.expression.value;
      }
      function arg_diff(consequent2, alternative2) {
        var a2 = consequent2.args;
        var b5 = alternative2.args;
        var len = a2.length;
        if (len != b5.length)
          return -2;
        for (var i = 0;i < len; i++) {
          if (!a2[i].equivalent_to(b5[i])) {
            if (a2[i] instanceof AST_Spread !== b5[i] instanceof AST_Spread)
              return -3;
            for (var j2 = i + 1;j2 < len; j2++) {
              if (!a2[j2].equivalent_to(b5[j2]))
                return -2;
            }
            return i;
          }
        }
        return -1;
      }
      function is_tail_equivalent(consequent2, alternative2) {
        if (consequent2.TYPE != alternative2.TYPE)
          return;
        if (consequent2.optional != alternative2.optional)
          return;
        if (consequent2 instanceof AST_Call) {
          if (arg_diff(consequent2, alternative2) != -1)
            return;
          return consequent2.TYPE != "Call" || !(consequent2.expression instanceof AST_PropAccess || alternative2.expression instanceof AST_PropAccess) || is_tail_equivalent(consequent2.expression, alternative2.expression);
        }
        if (!(consequent2 instanceof AST_PropAccess))
          return;
        var p2 = consequent2.property;
        var q2 = alternative2.property;
        return (p2 instanceof AST_Node ? p2.equivalent_to(q2) : p2 == q2) && !(consequent2.expression instanceof AST_Super || alternative2.expression instanceof AST_Super);
      }
      function combine_tail(consequent2, alternative2, top) {
        if (!is_tail_equivalent(consequent2, alternative2))
          return !top && make_node(AST_Conditional, self, {
            condition,
            consequent: consequent2,
            alternative: alternative2
          });
        var node2 = consequent2.clone();
        node2.expression = combine_tail(consequent2.expression, alternative2.expression);
        return node2;
      }
      function can_shift_lhs_of_tail(node2) {
        return node2 === node2.tail_node() || all(node2.expressions.slice(0, -1), function(expr) {
          return !expr.has_side_effects(compressor);
        });
      }
      function pop_lhs(node2) {
        if (!(node2 instanceof AST_Sequence))
          return node2.right;
        var exprs = node2.expressions.slice();
        exprs.push(exprs.pop().right);
        return make_sequence(node2, exprs);
      }
      function pop_seq(node2) {
        if (!(node2 instanceof AST_Sequence))
          return make_node(AST_Number, node2, {
            value: 0
          });
        return make_sequence(node2, node2.expressions.slice(0, -1));
      }
    });
    OPT(AST_Boolean, function(self, compressor) {
      if (!compressor.option("booleans"))
        return self;
      if (compressor.in_boolean_context())
        return make_node(AST_Number, self, {
          value: +self.value
        });
      var p2 = compressor.parent();
      if (p2 instanceof AST_Binary && (p2.operator == "==" || p2.operator == "!=")) {
        AST_Node.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
          operator: p2.operator,
          value: self.value,
          file: p2.start.file,
          line: p2.start.line,
          col: p2.start.col
        });
        return make_node(AST_Number, self, {
          value: +self.value
        });
      }
      return make_node(AST_UnaryPrefix, self, {
        operator: "!",
        expression: make_node(AST_Number, self, {
          value: 1 - self.value
        })
      });
    });
    OPT(AST_Spread, function(self, compressor) {
      var exp = self.expression;
      if (compressor.option("spreads") && exp instanceof AST_Array && !(compressor.parent() instanceof AST_Object)) {
        return List.splice(exp.elements.map(function(node) {
          return node instanceof AST_Hole ? make_node(AST_Undefined, node).optimize(compressor) : node;
        }));
      }
      return self;
    });
    function safe_to_flatten(value, compressor) {
      if (!value)
        return false;
      var parent = compressor.parent();
      if (parent.TYPE != "Call")
        return true;
      if (parent.expression !== compressor.self())
        return true;
      if (value instanceof AST_SymbolRef) {
        value = value.fixed_value();
        if (!value)
          return false;
      }
      return value instanceof AST_Lambda && !value.contains_this();
    }
    OPT(AST_Sub, function(self, compressor) {
      var expr = self.expression;
      var prop = self.property;
      var terminated = trim_optional_chain(self, compressor);
      if (terminated)
        return terminated;
      if (compressor.option("properties")) {
        var key = prop.evaluate(compressor);
        if (key !== prop) {
          if (typeof key == "string") {
            if (key == "undefined") {
              key = undefined;
            } else {
              var value = parseFloat(key);
              if (value.toString() == key) {
                key = value;
              }
            }
          }
          prop = self.property = best_of_expression(prop, make_node_from_constant(key, prop).transform(compressor));
          var property = "" + key;
          if (is_identifier_string(property) && property.length <= prop.print_to_string().length + 1) {
            return make_node(AST_Dot, self, {
              optional: self.optional,
              expression: expr,
              property
            }).optimize(compressor);
          }
        }
      }
      var parent = compressor.parent();
      var assigned = is_lhs(compressor.self(), parent);
      var def, fn, fn_parent, index;
      if (compressor.option("arguments") && expr instanceof AST_SymbolRef && is_arguments(def = expr.definition()) && !expr.in_arg && prop instanceof AST_Number && Math.floor(index = prop.value) == index && (fn = def.scope) === find_lambda() && fn.uses_arguments < (assigned ? 2 : 3)) {
        if (parent instanceof AST_UnaryPrefix && parent.operator == "delete") {
          if (!def.deleted)
            def.deleted = [];
          def.deleted[index] = true;
        }
        var argname = fn.argnames[index];
        if (def.deleted && def.deleted[index]) {
          argname = null;
        } else if (argname) {
          var arg_def;
          if (!(argname instanceof AST_SymbolFunarg) || argname.name == "await" || expr.scope.find_variable(argname.name) !== (arg_def = argname.definition())) {
            argname = null;
          } else if (compressor.has_directive("use strict") || fn.name || fn.rest || !(fn_parent instanceof AST_Call && index < fn_parent.args.length && all(fn_parent.args.slice(0, index + 1), function(arg) {
            return !(arg instanceof AST_Spread);
          })) || !all(fn.argnames, function(argname2) {
            return argname2 instanceof AST_SymbolFunarg;
          })) {
            if (has_reassigned() || arg_def.assignments || arg_def.orig.length > 1)
              argname = null;
          }
        } else if ((assigned || !has_reassigned()) && index < fn.argnames.length + 5 && compressor.drop_fargs(fn, fn_parent) && !fn.rest) {
          while (index >= fn.argnames.length) {
            argname = fn.make_var(AST_SymbolFunarg, fn, "argument_" + fn.argnames.length);
            fn.argnames.push(argname);
          }
        }
        if (argname && find_if(function(node) {
          return node.name === argname.name;
        }, fn.argnames) === argname) {
          if (assigned)
            def.reassigned--;
          var sym = make_node(AST_SymbolRef, self, argname);
          sym.reference();
          delete argname.__unused;
          return sym;
        }
      }
      if (assigned)
        return self;
      if (compressor.option("sequences") && parent.TYPE != "Call" && !(parent instanceof AST_ForEnumeration && parent.init === self)) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (key !== prop) {
        var sub = self.flatten_object(property, compressor);
        if (sub) {
          expr = self.expression = sub.expression;
          prop = self.property = sub.property;
        }
      }
      var elements;
      if (compressor.option("properties") && compressor.option("side_effects") && prop instanceof AST_Number && expr instanceof AST_Array && all(elements = expr.elements, function(value2) {
        return !(value2 instanceof AST_Spread);
      })) {
        var index = prop.value;
        var retValue = elements[index];
        if (safe_to_flatten(retValue, compressor)) {
          var is_hole = retValue instanceof AST_Hole;
          var flatten = !is_hole;
          var values = [];
          for (var i = elements.length;--i > index; ) {
            var value = elements[i].drop_side_effect_free(compressor);
            if (value) {
              values.unshift(value);
              if (flatten && value.has_side_effects(compressor))
                flatten = false;
            }
          }
          if (!flatten)
            values.unshift(retValue);
          while (--i >= 0) {
            var value = elements[i].drop_side_effect_free(compressor);
            if (value) {
              values.unshift(value);
            } else if (is_hole) {
              values.unshift(make_node(AST_Hole, elements[i]));
            } else {
              index--;
            }
          }
          if (flatten) {
            values.push(retValue);
            return make_sequence(self, values).optimize(compressor);
          } else
            return make_node(AST_Sub, self, {
              expression: make_node(AST_Array, expr, { elements: values }),
              property: make_node(AST_Number, prop, { value: index })
            });
        }
      }
      return try_evaluate(compressor, self);
      function find_lambda() {
        var i2 = 0, p2;
        while (p2 = compressor.parent(i2++)) {
          if (p2 instanceof AST_Lambda) {
            if (p2 instanceof AST_Accessor)
              return;
            if (is_arrow(p2))
              continue;
            fn_parent = compressor.parent(i2);
            return p2;
          }
        }
      }
      function has_reassigned() {
        return !compressor.option("reduce_vars") || def.reassigned;
      }
    });
    AST_Arrow.DEFMETHOD("contains_super", return_false);
    AST_AsyncArrow.DEFMETHOD("contains_super", return_false);
    AST_Lambda.DEFMETHOD("contains_super", function() {
      var result;
      var self = this;
      self.walk(new TreeWalker(function(node) {
        if (result)
          return true;
        if (node instanceof AST_Super)
          return result = true;
        if (node !== self && node instanceof AST_Scope && !is_arrow(node))
          return true;
      }));
      return result;
    });
    AST_LambdaDefinition.DEFMETHOD("contains_super", return_false);
    AST_Scope.DEFMETHOD("contains_super", return_false);
    AST_Arrow.DEFMETHOD("contains_this", return_false);
    AST_AsyncArrow.DEFMETHOD("contains_this", return_false);
    AST_Node.DEFMETHOD("contains_this", function() {
      var result;
      var self = this;
      self.walk(new TreeWalker(function(node) {
        if (result)
          return true;
        if (node instanceof AST_This)
          return result = true;
        if (node !== self && node instanceof AST_Scope && !is_arrow(node))
          return true;
      }));
      return result;
    });
    function can_hoist_property(prop) {
      return prop instanceof AST_ObjectKeyVal && typeof prop.key == "string" && !(prop instanceof AST_ObjectMethod && prop.value.contains_super());
    }
    AST_PropAccess.DEFMETHOD("flatten_object", function(key, compressor) {
      if (!compressor.option("properties"))
        return;
      if (key === "__proto__")
        return;
      var expr = this.expression;
      if (expr instanceof AST_Object) {
        var props = expr.properties;
        for (var i = props.length;--i >= 0; ) {
          var prop = props[i];
          if (prop.key !== key)
            continue;
          if (!all(props, can_hoist_property))
            break;
          if (!safe_to_flatten(prop.value, compressor))
            break;
          props = props.map(function(prop2) {
            return prop2.value;
          });
          if (prop instanceof AST_ObjectMethod && prop.value instanceof AST_Function && !(compressor.parent() instanceof AST_Call)) {
            if (prop.value.uses_arguments)
              break;
            props[i] = make_node(AST_Arrow, prop.value, prop.value);
          }
          return make_node(AST_Sub, this, {
            expression: make_node(AST_Array, expr, { elements: props }),
            property: make_node(AST_Number, this, { value: i })
          });
        }
      }
    });
    OPT(AST_Dot, function(self, compressor) {
      if (self.property == "arguments" || self.property == "caller") {
        AST_Node.warn("Function.prototype.{prop} not supported [{file}:{line},{col}]", {
          prop: self.property,
          file: self.start.file,
          line: self.start.line,
          col: self.start.col
        });
      }
      var parent = compressor.parent();
      if (is_lhs(compressor.self(), parent))
        return self;
      var terminated = trim_optional_chain(self, compressor);
      if (terminated)
        return terminated;
      if (compressor.option("sequences") && parent.TYPE != "Call" && !(parent instanceof AST_ForEnumeration && parent.init === self)) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("unsafe_proto") && self.expression instanceof AST_Dot && self.expression.property == "prototype") {
        var exp = self.expression.expression;
        if (is_undeclared_ref(exp))
          switch (exp.name) {
            case "Array":
              self.expression = make_node(AST_Array, self.expression, {
                elements: []
              });
              break;
            case "Function":
              self.expression = make_node(AST_Function, self.expression, {
                argnames: [],
                body: []
              }).init_vars(exp.scope);
              break;
            case "Number":
              self.expression = make_node(AST_Number, self.expression, {
                value: 0
              });
              break;
            case "Object":
              self.expression = make_node(AST_Object, self.expression, {
                properties: []
              });
              break;
            case "RegExp":
              self.expression = make_node(AST_RegExp, self.expression, {
                value: /t/
              });
              break;
            case "String":
              self.expression = make_node(AST_String, self.expression, {
                value: ""
              });
              break;
          }
      }
      var sub = self.flatten_object(self.property, compressor);
      if (sub)
        return sub.optimize(compressor);
      return try_evaluate(compressor, self);
    });
    OPT(AST_DestructuredArray, function(self, compressor) {
      if (compressor.option("rests") && self.rest instanceof AST_DestructuredArray) {
        return make_node(AST_DestructuredArray, self, {
          elements: self.elements.concat(self.rest.elements),
          rest: self.rest.rest
        });
      }
      return self;
    });
    OPT(AST_DestructuredKeyVal, function(self, compressor) {
      if (compressor.option("objects")) {
        var key = self.key;
        if (key instanceof AST_Node) {
          key = key.evaluate(compressor);
          if (key !== self.key)
            self.key = "" + key;
        }
      }
      return self;
    });
    OPT(AST_Object, function(self, compressor) {
      if (!compressor.option("objects"))
        return self;
      var changed = false;
      var found = false;
      var generated = false;
      var keep_duplicate = compressor.has_directive("use strict");
      var keys = new Dictionary;
      var values = [];
      self.properties.forEach(function(prop) {
        if (!(prop instanceof AST_Spread))
          return process2(prop);
        found = true;
        var exp = prop.expression;
        if (compressor.option("spreads") && exp instanceof AST_Object && all(exp.properties, function(prop2) {
          if (prop2 instanceof AST_ObjectGetter)
            return false;
          if (prop2 instanceof AST_Spread)
            return false;
          if (prop2.key !== "__proto__")
            return true;
          if (prop2 instanceof AST_ObjectSetter)
            return true;
          return !prop2.value.has_side_effects(compressor);
        })) {
          changed = true;
          exp.properties.forEach(function(prop2) {
            var key = prop2.key;
            var setter = prop2 instanceof AST_ObjectSetter;
            if (key === "__proto__") {
              if (!setter)
                return;
              key = make_node_from_constant(key, prop2);
            }
            process2(setter ? make_node(AST_ObjectKeyVal, prop2, {
              key,
              value: make_node(AST_Undefined, prop2).optimize(compressor)
            }) : prop2);
          });
        } else {
          generated = true;
          flush();
          values.push(prop);
        }
      });
      flush();
      if (!changed)
        return self;
      if (found && generated && values.length == 1) {
        var value = values[0];
        if (value instanceof AST_ObjectProperty && value.key instanceof AST_Number) {
          value.key = "" + value.key.value;
        }
      }
      return make_node(AST_Object, self, { properties: values });
      function flush() {
        keys.each(function(props) {
          if (props.length == 1)
            return values.push(props[0]);
          changed = true;
          var tail = keep_duplicate && !generated && props.pop();
          values.push(props.length == 1 ? props[0] : make_node(AST_ObjectKeyVal, self, {
            key: props[0].key,
            value: make_sequence(self, props.map(function(prop) {
              return prop.value;
            }))
          }));
          if (tail)
            values.push(tail);
        });
        keys = new Dictionary;
      }
      function process2(prop) {
        var key = prop.key;
        if (key instanceof AST_Node) {
          found = true;
          key = key.evaluate(compressor);
          if (key === prop.key || key === "__proto__") {
            generated = true;
          } else {
            key = prop.key = "" + key;
          }
        }
        if (can_hoist_property(prop)) {
          if (prop.value.has_side_effects(compressor))
            flush();
          keys.add(key, prop);
        } else {
          flush();
          values.push(prop);
        }
        if (found && !generated && typeof key == "string" && RE_POSITIVE_INTEGER.test(key)) {
          generated = true;
          if (keys.has(key))
            prop = keys.get(key)[0];
          prop.key = make_node(AST_Number, prop, { value: +key });
        }
      }
    });
    OPT(AST_Return, function(self, compressor) {
      if (compressor.option("side_effects") && self.value && is_undefined(self.value, compressor) && !in_async_generator(compressor.find_parent(AST_Scope))) {
        self.value = null;
      }
      return self;
    });
  })(function(node, optimizer) {
    node.DEFMETHOD("optimize", function(compressor) {
      var self = this;
      if (self._optimized)
        return self;
      if (compressor.has_directive("use asm"))
        return self;
      var opt = optimizer(self, compressor);
      opt._optimized = true;
      return opt;
    });
  });
});

// node_modules/uglify-js/lib/output.js
var exports_output = {};
var is_some_comments, OutputStream2;
var init_output = __esm(() => {
  is_some_comments = function(comment) {
    return comment.type == "comment2" && /@preserve|@license|@cc_on/i.test(comment.value);
  };
  OutputStream2 = function(options) {
    options = defaults(options, {
      annotations: false,
      ascii_only: false,
      beautify: false,
      braces: false,
      comments: false,
      galio: false,
      ie: false,
      indent_level: 4,
      indent_start: 0,
      inline_script: true,
      keep_quoted_props: false,
      max_line_len: false,
      preamble: null,
      preserve_line: false,
      quote_keys: false,
      quote_style: 0,
      semicolons: true,
      shebang: true,
      source_map: null,
      v8: false,
      webkit: false,
      width: 80,
      wrap_iife: false
    }, true);
    var comment_filter = return_false;
    if (options.comments) {
      var comments = options.comments;
      if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
        var regex_pos = options.comments.lastIndexOf("/");
        comments = new RegExp(options.comments.substr(1, regex_pos - 1), options.comments.substr(regex_pos + 1));
      }
      if (comments instanceof RegExp) {
        comment_filter = function(comment) {
          return comment.type != "comment5" && comments.test(comment.value);
        };
      } else if (typeof comments === "function") {
        comment_filter = function(comment) {
          return comment.type != "comment5" && comments(this, comment);
        };
      } else if (comments === "some") {
        comment_filter = is_some_comments;
      } else {
        comment_filter = return_true;
      }
    }
    var current_col = 0;
    var current_line = 1;
    var current_pos = 0;
    var indentation = options.indent_start;
    var last;
    var line_end = 0;
    var line_fixed = true;
    var mappings = options.source_map && [];
    var mapping_name;
    var mapping_token;
    var might_need_space;
    var might_need_semicolon;
    var need_newline_indented = false;
    var need_space = false;
    var newline_insert = -1;
    var stack;
    var OUTPUT;
    function reset() {
      last = "";
      might_need_space = false;
      might_need_semicolon = false;
      stack = [];
      var str = OUTPUT;
      OUTPUT = "";
      return str;
    }
    reset();
    var to_utf8 = options.ascii_only ? function(str, identifier) {
      if (identifier)
        str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(ch) {
          return "\\u{" + (ch.charCodeAt(0) - 55232 << 10 | ch.charCodeAt(1) - 56320).toString(16) + "}";
        });
      return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
        var code = ch.charCodeAt(0).toString(16);
        if (code.length <= 2 && !identifier) {
          while (code.length < 2)
            code = "0" + code;
          return "\\x" + code;
        } else {
          while (code.length < 4)
            code = "0" + code;
          return "\\u" + code;
        }
      });
    } : function(str) {
      var s2 = "";
      for (var i = 0, j2 = 0;i < str.length; i++) {
        var code = str.charCodeAt(i);
        if (is_surrogate_pair_head(code)) {
          if (is_surrogate_pair_tail(str.charCodeAt(i + 1))) {
            i++;
            continue;
          }
        } else if (!is_surrogate_pair_tail(code)) {
          continue;
        }
        s2 += str.slice(j2, i) + "\\u" + code.toString(16);
        j2 = i + 1;
      }
      return j2 == 0 ? str : s2 + str.slice(j2);
    };
    function quote_single(str) {
      return "'" + str.replace(/\x27/g, "\\'") + "'";
    }
    function quote_double(str) {
      return '"' + str.replace(/\x22/g, '\\"') + '"';
    }
    var quote_string = [
      null,
      quote_single,
      quote_double,
      function(str, quote) {
        return quote == "'" ? quote_single(str) : quote_double(str);
      }
    ][options.quote_style] || function(str, quote, dq, sq) {
      return dq > sq ? quote_single(str) : quote_double(str);
    };
    function make_string(str, quote) {
      var dq = 0, sq = 0;
      str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g, function(s2, i) {
        switch (s2) {
          case '"':
            ++dq;
            return '"';
          case "'":
            ++sq;
            return "'";
          case "\\":
            return "\\\\";
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\t":
            return "\\t";
          case "\b":
            return "\\b";
          case "\f":
            return "\\f";
          case "\v":
            return options.ie ? "\\x0B" : "\\v";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          case "\uFEFF":
            return "\\ufeff";
          case "\0":
            return /[0-9]/.test(str.charAt(i + 1)) ? "\\x00" : "\\0";
        }
        return s2;
      });
      return quote_string(to_utf8(str), quote, dq, sq);
    }
    var adjust_mappings = mappings ? function(line, col) {
      mappings.forEach(function(mapping) {
        mapping.line += line;
        mapping.col += col;
      });
    } : noop;
    var flush_mappings = mappings ? function() {
      mappings.forEach(function(mapping) {
        options.source_map.add(mapping.token.file, mapping.line, mapping.col, mapping.token.line, mapping.token.col, !mapping.name && mapping.token.type == "name" ? mapping.token.value : mapping.name);
      });
      mappings = [];
    } : noop;
    function insert_newlines(count) {
      var index = OUTPUT.lastIndexOf("\n");
      if (line_end < index)
        line_end = index;
      var left = OUTPUT.slice(0, line_end);
      var right = OUTPUT.slice(line_end);
      adjust_mappings(count, right.length - current_col);
      current_line += count;
      current_pos += count;
      current_col = right.length;
      OUTPUT = left;
      while (count--)
        OUTPUT += "\n";
      OUTPUT += right;
    }
    var fix_line = options.max_line_len ? function() {
      if (line_fixed) {
        if (current_col > options.max_line_len) {
          AST_Node.warn("Output exceeds {max_line_len} characters", options);
        }
        return;
      }
      if (current_col > options.max_line_len)
        insert_newlines(1);
      line_fixed = true;
      flush_mappings();
    } : noop;
    var requireSemicolonChars = makePredicate("( [ + * / - , .");
    var print = options.beautify || options.comments || options.max_line_len || options.preserve_line || options.shebang || !options.semicolons || options.source_map || options.width ? function(str) {
      var ch = str.charAt(0);
      if (need_newline_indented && ch) {
        need_newline_indented = false;
        if (ch != "\n") {
          print("\n");
          indent();
        }
      }
      if (need_space && ch) {
        need_space = false;
        if (!/[\s;})]/.test(ch)) {
          space();
        }
      }
      newline_insert = -1;
      var prev = last.slice(-1);
      if (might_need_semicolon) {
        might_need_semicolon = false;
        if (prev == ":" && ch == "}" || (!ch || ";}".indexOf(ch) < 0) && prev != ";") {
          if (options.semicolons || requireSemicolonChars[ch]) {
            OUTPUT += ";";
            current_col++;
            current_pos++;
          } else {
            fix_line();
            OUTPUT += "\n";
            current_pos++;
            current_line++;
            current_col = 0;
            if (/^\s+$/.test(str)) {
              might_need_semicolon = true;
            }
          }
          if (!options.beautify)
            might_need_space = false;
        }
      }
      if (might_need_space) {
        if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || ch == "/" && ch == prev || (ch == "+" || ch == "-") && ch == last || str == "--" && last == "!" || str == "in" && prev == "/" || last == "--" && ch == ">") {
          OUTPUT += " ";
          current_col++;
          current_pos++;
        }
        if (prev != "<" || str != "!")
          might_need_space = false;
      }
      if (mapping_token) {
        mappings.push({
          token: mapping_token,
          name: mapping_name,
          line: current_line,
          col: current_col
        });
        mapping_token = false;
        if (line_fixed)
          flush_mappings();
      }
      OUTPUT += str;
      current_pos += str.length;
      var a2 = str.split(/\r?\n/), n = a2.length - 1;
      current_line += n;
      current_col += a2[0].length;
      if (n > 0) {
        fix_line();
        current_col = a2[n].length;
      }
      last = str;
    } : function(str) {
      var ch = str.charAt(0);
      var prev = last.slice(-1);
      if (might_need_semicolon) {
        might_need_semicolon = false;
        if (prev == ":" && ch == "}" || (!ch || ";}".indexOf(ch) < 0) && prev != ";") {
          OUTPUT += ";";
          might_need_space = false;
        }
      }
      if (might_need_space) {
        if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || ch == "/" && ch == prev || (ch == "+" || ch == "-") && ch == last || str == "--" && last == "!" || str == "in" && prev == "/" || last == "--" && ch == ">") {
          OUTPUT += " ";
        }
        if (prev != "<" || str != "!")
          might_need_space = false;
      }
      OUTPUT += str;
      last = str;
    };
    var space = options.beautify ? function() {
      print(" ");
    } : function() {
      might_need_space = true;
    };
    var indent = options.beautify ? function(half) {
      if (need_newline_indented)
        print("\n");
      print(repeat_string(" ", half ? indentation - (options.indent_level >> 1) : indentation));
    } : noop;
    var with_indent = options.beautify ? function(cont) {
      var save_indentation = indentation;
      indentation += options.indent_level;
      cont();
      indentation = save_indentation;
    } : function(cont) {
      cont();
    };
    var may_add_newline = options.max_line_len || options.preserve_line ? function() {
      fix_line();
      line_end = OUTPUT.length;
      line_fixed = false;
    } : noop;
    var newline = options.beautify ? function() {
      if (newline_insert < 0)
        return print("\n");
      if (OUTPUT[newline_insert] != "\n") {
        OUTPUT = OUTPUT.slice(0, newline_insert) + "\n" + OUTPUT.slice(newline_insert);
        current_pos++;
        current_line++;
      }
      newline_insert++;
    } : may_add_newline;
    var semicolon = options.beautify ? function() {
      print(";");
    } : function() {
      might_need_semicolon = true;
    };
    function force_semicolon() {
      if (might_need_semicolon)
        print(";");
      print(";");
    }
    function with_block(cont) {
      print("{");
      newline();
      with_indent(cont);
      indent();
      print("}");
    }
    function with_parens(cont) {
      print("(");
      may_add_newline();
      cont();
      may_add_newline();
      print(")");
    }
    function with_square(cont) {
      print("[");
      may_add_newline();
      cont();
      may_add_newline();
      print("]");
    }
    function comma() {
      may_add_newline();
      print(",");
      may_add_newline();
      space();
    }
    function colon() {
      print(":");
      space();
    }
    var add_mapping = mappings ? function(token, name) {
      mapping_token = token;
      mapping_name = name;
    } : noop;
    function get() {
      if (!line_fixed)
        fix_line();
      return OUTPUT;
    }
    function has_nlb() {
      var index = OUTPUT.lastIndexOf("\n");
      return /^ *$/.test(OUTPUT.slice(index + 1));
    }
    function pad_comment(token, force) {
      if (need_newline_indented)
        return;
      if (token.nlb && (force || !has_nlb())) {
        need_newline_indented = true;
      } else if (force) {
        need_space = true;
      }
    }
    function print_comment(comment) {
      var value = comment.value.replace(/[@#]__PURE__/g, " ");
      if (/^\s*$/.test(value) && !/^\s*$/.test(comment.value))
        return false;
      if (/comment[134]/.test(comment.type)) {
        print("//" + value);
        need_newline_indented = true;
      } else if (comment.type == "comment2") {
        print("/*" + value + "*/");
      }
      return true;
    }
    function should_merge_comments(node, parent) {
      if (parent instanceof AST_Binary)
        return parent.left === node;
      if (parent.TYPE == "Call")
        return parent.expression === node;
      if (parent instanceof AST_Conditional)
        return parent.condition === node;
      if (parent instanceof AST_Dot)
        return parent.expression === node;
      if (parent instanceof AST_Exit)
        return true;
      if (parent instanceof AST_Sequence)
        return parent.expressions[0] === node;
      if (parent instanceof AST_Sub)
        return parent.expression === node;
      if (parent instanceof AST_UnaryPostfix)
        return true;
      if (parent instanceof AST_Yield)
        return true;
    }
    function prepend_comments(node) {
      var self = this;
      var scan;
      if (node instanceof AST_Exit) {
        scan = node.value;
      } else if (node instanceof AST_Yield) {
        scan = node.expression;
      }
      var comments2 = dump(node);
      if (!comments2)
        comments2 = [];
      if (scan) {
        var tw = new TreeWalker(function(node2) {
          if (!should_merge_comments(node2, tw.parent()))
            return true;
          var before = dump(node2);
          if (before)
            comments2 = comments2.concat(before);
        });
        tw.push(node);
        scan.walk(tw);
      }
      if (current_pos == 0) {
        if (comments2.length > 0 && options.shebang && comments2[0].type == "comment5") {
          print("#!" + comments2.shift().value + "\n");
          indent();
        }
        var preamble = options.preamble;
        if (preamble) {
          print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
        }
      }
      comments2 = comments2.filter(comment_filter, node);
      var printed = false;
      comments2.forEach(function(comment, index) {
        pad_comment(comment, index);
        if (print_comment(comment))
          printed = true;
      });
      if (printed)
        pad_comment(node.start, true);
      function dump(node2) {
        var token = node2.start;
        if (!token) {
          if (!scan)
            return;
          node2.start = token = new AST_Token;
        }
        var comments3 = token.comments_before;
        if (!comments3) {
          if (!scan)
            return;
          token.comments_before = comments3 = [];
        }
        if (comments3._dumped === self)
          return;
        comments3._dumped = self;
        return comments3;
      }
    }
    function append_comments(node, tail) {
      var self = this;
      var token = node.end;
      if (!token)
        return;
      var comments2 = token[tail ? "comments_before" : "comments_after"];
      if (!comments2 || comments2._dumped === self)
        return;
      if (!(node instanceof AST_Statement || all(comments2, function(c2) {
        return !/comment[134]/.test(c2.type);
      })))
        return;
      comments2._dumped = self;
      var insert = OUTPUT.length;
      comments2.filter(comment_filter, node).forEach(function(comment, index) {
        pad_comment(comment, index || !tail);
        print_comment(comment);
      });
      if (OUTPUT.length > insert)
        newline_insert = insert;
    }
    return {
      get,
      reset,
      indent,
      should_break: options.width ? function() {
        return current_col - indentation >= options.width;
      } : return_false,
      has_parens: function() {
        return last.slice(-1) == "(";
      },
      newline,
      print,
      space,
      comma,
      colon,
      last: function() {
        return last;
      },
      semicolon,
      force_semicolon,
      to_utf8,
      print_name: function(name) {
        print(to_utf8(name.toString(), true));
      },
      print_string: options.inline_script ? function(str, quote) {
        str = make_string(str, quote).replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2");
        print(str.replace(/\x3c!--/g, "\\x3c!--").replace(/--\x3e/g, "--\\x3e"));
      } : function(str, quote) {
        print(make_string(str, quote));
      },
      with_indent,
      with_block,
      with_parens,
      with_square,
      add_mapping,
      option: function(opt) {
        return options[opt];
      },
      prepend_comments: options.comments || options.shebang ? prepend_comments : noop,
      append_comments: options.comments ? append_comments : noop,
      push_node: function(node) {
        stack.push(node);
      },
      pop_node: options.preserve_line ? function() {
        var node = stack.pop();
        if (node.start && node.start.line > current_line) {
          insert_newlines(node.start.line - current_line);
        }
      } : function() {
        stack.pop();
      },
      parent: function(n) {
        return stack[stack.length - 2 - (n || 0)];
      }
    };
  };
  (function() {
    function DEFPRINT(nodetype, generator) {
      nodetype.DEFMETHOD("_codegen", generator);
    }
    var use_asm = false;
    AST_Node.DEFMETHOD("print", function(stream, force_parens) {
      var self = this;
      stream.push_node(self);
      if (force_parens || self.needs_parens(stream)) {
        stream.with_parens(doit);
      } else {
        doit();
      }
      stream.pop_node();
      function doit() {
        stream.prepend_comments(self);
        self.add_source_map(stream);
        self._codegen(stream);
        stream.append_comments(self);
      }
    });
    var readonly = OutputStream2({
      inline_script: false,
      shebang: false,
      width: false
    });
    AST_Node.DEFMETHOD("print_to_string", function(options) {
      if (options) {
        var stream = OutputStream2(options);
        this.print(stream);
        return stream.get();
      }
      this.print(readonly);
      return readonly.reset();
    });
    function PARENS(nodetype, func) {
      nodetype.DEFMETHOD("needs_parens", func);
    }
    PARENS(AST_Node, return_false);
    function needs_parens_function(output) {
      var p2 = output.parent();
      if (!output.has_parens() && first_in_statement(output, false, true)) {
        return this.name || !(p2 instanceof AST_ExportDefault);
      }
      if (output.option("webkit") && p2 instanceof AST_PropAccess && p2.expression === this)
        return true;
      if (output.option("wrap_iife") && p2 instanceof AST_Call && p2.expression === this)
        return true;
    }
    PARENS(AST_AsyncFunction, needs_parens_function);
    PARENS(AST_AsyncGeneratorFunction, needs_parens_function);
    PARENS(AST_ClassExpression, needs_parens_function);
    PARENS(AST_Function, needs_parens_function);
    PARENS(AST_GeneratorFunction, needs_parens_function);
    function needs_parens_obj(output) {
      return !output.has_parens() && first_in_statement(output, true);
    }
    PARENS(AST_Object, needs_parens_obj);
    function needs_parens_unary(output) {
      var p2 = output.parent();
      if (p2 instanceof AST_Binary)
        return p2.operator == "**" && p2.left === this;
      if (p2 instanceof AST_Call)
        return p2.expression === this;
      if (p2 instanceof AST_Class)
        return true;
      if (p2 instanceof AST_PropAccess)
        return p2.expression === this;
      if (p2 instanceof AST_Template)
        return p2.tag === this;
    }
    PARENS(AST_Await, needs_parens_unary);
    PARENS(AST_Unary, needs_parens_unary);
    PARENS(AST_Sequence, function(output) {
      var p2 = output.parent();
      return p2 instanceof AST_Array || is_arrow(p2) && p2.value === this || p2 instanceof AST_Await || p2 instanceof AST_Binary || p2 instanceof AST_Call || p2 instanceof AST_Class || p2 instanceof AST_ClassProperty || p2 instanceof AST_Conditional || p2 instanceof AST_DefaultValue || p2 instanceof AST_DestructuredKeyVal || p2 instanceof AST_ExportDefault || p2 instanceof AST_ForOf || p2 instanceof AST_ObjectProperty || p2 instanceof AST_PropAccess && p2.expression === this || p2 instanceof AST_Spread || p2 instanceof AST_Template && p2.tag === this || p2 instanceof AST_Unary || p2 instanceof AST_VarDef || p2 instanceof AST_Yield;
    });
    PARENS(AST_Binary, function(output) {
      var p2 = output.parent();
      if (p2 instanceof AST_Await)
        return true;
      if (p2 instanceof AST_Binary) {
        var po = p2.operator, pp = PRECEDENCE[po];
        var so = this.operator, sp = PRECEDENCE[so];
        return pp > sp || po == "??" && (so == "&&" || so == "||") || pp == sp && this === p2[po == "**" ? "left" : "right"];
      }
      if (p2 instanceof AST_Call)
        return p2.expression === this;
      if (p2 instanceof AST_Class)
        return true;
      if (p2 instanceof AST_PropAccess)
        return p2.expression === this;
      if (p2 instanceof AST_Template)
        return p2.tag === this;
      if (p2 instanceof AST_Unary)
        return true;
    });
    function need_chain_parens(node, parent) {
      if (!node.terminal)
        return false;
      if (!(parent instanceof AST_Call || parent instanceof AST_PropAccess))
        return false;
      return parent.expression === node;
    }
    PARENS(AST_PropAccess, function(output) {
      var node = this;
      var p2 = output.parent();
      if (p2 instanceof AST_New && p2.expression === node && root_expr(node).TYPE == "Call")
        return true;
      return need_chain_parens(node, p2);
    });
    PARENS(AST_Call, function(output) {
      var node = this;
      var p2 = output.parent();
      if (p2 instanceof AST_New)
        return p2.expression === node;
      if (output.option("webkit") && node.expression instanceof AST_Function && p2 instanceof AST_PropAccess && p2.expression === node) {
        var g2 = output.parent(1);
        if (g2 instanceof AST_Assign && g2.left === p2)
          return true;
      }
      return need_chain_parens(node, p2);
    });
    PARENS(AST_New, function(output) {
      if (need_constructor_parens(this, output))
        return false;
      var p2 = output.parent();
      if (p2 instanceof AST_Call)
        return p2.expression === this;
      if (p2 instanceof AST_PropAccess)
        return true;
      if (p2 instanceof AST_Template)
        return p2.tag === this;
    });
    PARENS(AST_Number, function(output) {
      if (!output.option("galio"))
        return false;
      var p2 = output.parent();
      return p2 instanceof AST_PropAccess && p2.expression === this && /^0/.test(make_num(this.value));
    });
    function needs_parens_assign_cond(self, output) {
      var p2 = output.parent();
      if (p2 instanceof AST_Await)
        return true;
      if (p2 instanceof AST_Binary)
        return !(p2 instanceof AST_Assign);
      if (p2 instanceof AST_Call)
        return p2.expression === self;
      if (p2 instanceof AST_Class)
        return true;
      if (p2 instanceof AST_Conditional)
        return p2.condition === self;
      if (p2 instanceof AST_PropAccess)
        return p2.expression === self;
      if (p2 instanceof AST_Template)
        return p2.tag === self;
      if (p2 instanceof AST_Unary)
        return true;
    }
    PARENS(AST_Arrow, function(output) {
      return needs_parens_assign_cond(this, output);
    });
    PARENS(AST_Assign, function(output) {
      if (needs_parens_assign_cond(this, output))
        return true;
      if (output.option("v8"))
        return this.left instanceof AST_Destructured;
      if (this.left instanceof AST_DestructuredObject)
        return needs_parens_obj(output);
    });
    PARENS(AST_AsyncArrow, function(output) {
      return needs_parens_assign_cond(this, output);
    });
    PARENS(AST_Conditional, function(output) {
      return needs_parens_assign_cond(this, output);
    });
    PARENS(AST_Yield, function(output) {
      return needs_parens_assign_cond(this, output);
    });
    DEFPRINT(AST_Directive, function(output) {
      var quote = this.quote;
      var value = this.value;
      switch (output.option("quote_style")) {
        case 0:
        case 2:
          if (value.indexOf('"') == -1)
            quote = '"';
          break;
        case 1:
          if (value.indexOf("'") == -1)
            quote = "'";
          break;
      }
      output.print(quote + value + quote);
      output.semicolon();
    });
    DEFPRINT(AST_Debugger, function(output) {
      output.print("debugger");
      output.semicolon();
    });
    function display_body(body, is_toplevel, output, allow_directives) {
      var last = body.length - 1;
      var in_directive = allow_directives;
      var was_asm = use_asm;
      body.forEach(function(stmt, i) {
        if (in_directive) {
          if (stmt instanceof AST_Directive) {
            if (stmt.value == "use asm")
              use_asm = true;
          } else if (!(stmt instanceof AST_EmptyStatement)) {
            if (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String) {
              output.force_semicolon();
            }
            in_directive = false;
          }
        }
        if (stmt instanceof AST_EmptyStatement)
          return;
        output.indent();
        stmt.print(output);
        if (i == last && is_toplevel)
          return;
        output.newline();
        if (is_toplevel)
          output.newline();
      });
      use_asm = was_asm;
    }
    DEFPRINT(AST_Toplevel, function(output) {
      display_body(this.body, true, output, true);
      output.print("");
    });
    DEFPRINT(AST_LabeledStatement, function(output) {
      this.label.print(output);
      output.colon();
      this.body.print(output);
    });
    DEFPRINT(AST_SimpleStatement, function(output) {
      this.body.print(output);
      output.semicolon();
    });
    function print_braced_empty(self, output) {
      output.print("{");
      output.with_indent(function() {
        output.append_comments(self, true);
      });
      output.print("}");
    }
    function print_braced(self, output, allow_directives) {
      if (self.body.length > 0) {
        output.with_block(function() {
          display_body(self.body, false, output, allow_directives);
        });
      } else
        print_braced_empty(self, output);
    }
    DEFPRINT(AST_BlockStatement, function(output) {
      print_braced(this, output);
    });
    DEFPRINT(AST_EmptyStatement, function(output) {
      output.semicolon();
    });
    DEFPRINT(AST_Do, function(output) {
      var self = this;
      output.print("do");
      make_block(self.body, output);
      output.space();
      output.print("while");
      output.space();
      output.with_parens(function() {
        self.condition.print(output);
      });
      output.semicolon();
    });
    DEFPRINT(AST_While, function(output) {
      var self = this;
      output.print("while");
      output.space();
      output.with_parens(function() {
        self.condition.print(output);
      });
      force_statement(self.body, output);
    });
    DEFPRINT(AST_For, function(output) {
      var self = this;
      output.print("for");
      output.space();
      output.with_parens(function() {
        if (self.init) {
          if (self.init instanceof AST_Definitions) {
            self.init.print(output);
          } else {
            parenthesize_for_noin(self.init, output, true);
          }
          output.print(";");
          output.space();
        } else {
          output.print(";");
        }
        if (self.condition) {
          self.condition.print(output);
          output.print(";");
          output.space();
        } else {
          output.print(";");
        }
        if (self.step) {
          self.step.print(output);
        }
      });
      force_statement(self.body, output);
    });
    function print_for_enum(prefix, infix) {
      return function(output) {
        var self = this;
        output.print(prefix);
        output.space();
        output.with_parens(function() {
          self.init.print(output);
          output.space();
          output.print(infix);
          output.space();
          self.object.print(output);
        });
        force_statement(self.body, output);
      };
    }
    DEFPRINT(AST_ForAwaitOf, print_for_enum("for await", "of"));
    DEFPRINT(AST_ForIn, print_for_enum("for", "in"));
    DEFPRINT(AST_ForOf, print_for_enum("for", "of"));
    DEFPRINT(AST_With, function(output) {
      var self = this;
      output.print("with");
      output.space();
      output.with_parens(function() {
        self.expression.print(output);
      });
      force_statement(self.body, output);
    });
    DEFPRINT(AST_ExportDeclaration, function(output) {
      output.print("export");
      output.space();
      this.body.print(output);
    });
    DEFPRINT(AST_ExportDefault, function(output) {
      output.print("export");
      output.space();
      output.print("default");
      output.space();
      var body = this.body;
      body.print(output);
      if (body instanceof AST_ClassExpression) {
        if (!body.name)
          return;
      }
      if (body instanceof AST_DefClass)
        return;
      if (body instanceof AST_LambdaDefinition)
        return;
      if (body instanceof AST_LambdaExpression) {
        if (!body.name && !is_arrow(body))
          return;
      }
      output.semicolon();
    });
    DEFPRINT(AST_ExportForeign, function(output) {
      var self = this;
      output.print("export");
      output.space();
      var len = self.keys.length;
      if (len == 0) {
        print_braced_empty(self, output);
      } else if (self.keys[0] == "*") {
        print_entry(0);
      } else
        output.with_block(function() {
          output.indent();
          print_entry(0);
          for (var i = 1;i < len; i++) {
            output.print(",");
            output.newline();
            output.indent();
            print_entry(i);
          }
          output.newline();
        });
      output.space();
      output.print("from");
      output.space();
      output.print_string(self.path, self.quote);
      output.semicolon();
      function print_entry(index) {
        var alias = self.aliases[index];
        var key = self.keys[index];
        output.print_name(key);
        if (alias != key) {
          output.space();
          output.print("as");
          output.space();
          output.print_name(alias);
        }
      }
    });
    DEFPRINT(AST_ExportReferences, function(output) {
      var self = this;
      output.print("export");
      output.space();
      print_properties(self, output);
      output.semicolon();
    });
    DEFPRINT(AST_Import, function(output) {
      var self = this;
      output.print("import");
      output.space();
      if (self.default)
        self.default.print(output);
      if (self.all) {
        if (self.default)
          output.comma();
        self.all.print(output);
      }
      if (self.properties) {
        if (self.default)
          output.comma();
        print_properties(self, output);
      }
      if (self.all || self.default || self.properties) {
        output.space();
        output.print("from");
        output.space();
      }
      output.print_string(self.path, self.quote);
      output.semicolon();
    });
    function print_funargs(self, output) {
      output.with_parens(function() {
        self.argnames.forEach(function(arg, i) {
          if (i)
            output.comma();
          arg.print(output);
        });
        if (self.rest) {
          if (self.argnames.length)
            output.comma();
          output.print("...");
          self.rest.print(output);
        }
      });
    }
    function print_arrow(self, output) {
      if (self.argnames.length == 1 && self.argnames[0] instanceof AST_SymbolFunarg && !self.rest) {
        self.argnames[0].print(output);
      } else {
        print_funargs(self, output);
      }
      output.space();
      output.print("=>");
      output.space();
      if (self.value) {
        self.value.print(output);
      } else {
        print_braced(self, output, true);
      }
    }
    DEFPRINT(AST_Arrow, function(output) {
      print_arrow(this, output);
    });
    DEFPRINT(AST_AsyncArrow, function(output) {
      output.print("async");
      output.space();
      print_arrow(this, output);
    });
    function print_lambda(self, output) {
      if (self.name) {
        output.space();
        self.name.print(output);
      }
      print_funargs(self, output);
      output.space();
      print_braced(self, output, true);
    }
    DEFPRINT(AST_Lambda, function(output) {
      output.print("function");
      print_lambda(this, output);
    });
    function print_async(output) {
      output.print("async");
      output.space();
      output.print("function");
      print_lambda(this, output);
    }
    DEFPRINT(AST_AsyncDefun, print_async);
    DEFPRINT(AST_AsyncFunction, print_async);
    function print_async_generator(output) {
      output.print("async");
      output.space();
      output.print("function*");
      print_lambda(this, output);
    }
    DEFPRINT(AST_AsyncGeneratorDefun, print_async_generator);
    DEFPRINT(AST_AsyncGeneratorFunction, print_async_generator);
    function print_generator(output) {
      output.print("function*");
      print_lambda(this, output);
    }
    DEFPRINT(AST_GeneratorDefun, print_generator);
    DEFPRINT(AST_GeneratorFunction, print_generator);
    DEFPRINT(AST_Class, function(output) {
      var self = this;
      output.print("class");
      if (self.name) {
        output.space();
        self.name.print(output);
      }
      if (self.extends) {
        output.space();
        output.print("extends");
        output.space();
        self.extends.print(output);
      }
      output.space();
      print_properties(self, output, true);
    });
    DEFPRINT(AST_ClassField, function(output) {
      var self = this;
      if (self.static) {
        output.print("static");
        output.space();
      }
      print_property_key(self, output);
      if (self.value) {
        output.space();
        output.print("=");
        output.space();
        self.value.print(output);
      }
      output.semicolon();
    });
    DEFPRINT(AST_ClassGetter, print_accessor("get"));
    DEFPRINT(AST_ClassSetter, print_accessor("set"));
    function print_method(self, output) {
      var fn = self.value;
      if (is_async(fn)) {
        output.print("async");
        output.space();
      }
      if (is_generator(fn))
        output.print("*");
      print_property_key(self, output);
      print_lambda(self.value, output);
    }
    DEFPRINT(AST_ClassMethod, function(output) {
      var self = this;
      if (self.static) {
        output.print("static");
        output.space();
      }
      print_method(self, output);
    });
    function print_jump(kind, prop) {
      return function(output) {
        output.print(kind);
        var target = this[prop];
        if (target) {
          output.space();
          target.print(output);
        }
        output.semicolon();
      };
    }
    DEFPRINT(AST_Return, print_jump("return", "value"));
    DEFPRINT(AST_Throw, print_jump("throw", "value"));
    DEFPRINT(AST_Break, print_jump("break", "label"));
    DEFPRINT(AST_Continue, print_jump("continue", "label"));
    function make_then(self, output) {
      var b5 = self.body;
      if (output.option("braces") && !(b5 instanceof AST_Const || b5 instanceof AST_Let) || output.option("ie") && b5 instanceof AST_Do)
        return make_block(b5, output);
      if (!b5)
        return output.force_semicolon();
      while (true) {
        if (b5 instanceof AST_If) {
          if (!b5.alternative) {
            make_block(self.body, output);
            return;
          }
          b5 = b5.alternative;
        } else if (b5 instanceof AST_StatementWithBody) {
          b5 = b5.body;
        } else
          break;
      }
      force_statement(self.body, output);
    }
    DEFPRINT(AST_If, function(output) {
      var self = this;
      output.print("if");
      output.space();
      output.with_parens(function() {
        self.condition.print(output);
      });
      if (self.alternative) {
        make_then(self, output);
        output.space();
        output.print("else");
        if (self.alternative instanceof AST_If) {
          output.space();
          self.alternative.print(output);
        } else {
          force_statement(self.alternative, output);
        }
      } else {
        force_statement(self.body, output);
      }
    });
    DEFPRINT(AST_Switch, function(output) {
      var self = this;
      output.print("switch");
      output.space();
      output.with_parens(function() {
        self.expression.print(output);
      });
      output.space();
      var last = self.body.length - 1;
      if (last < 0)
        print_braced_empty(self, output);
      else
        output.with_block(function() {
          self.body.forEach(function(branch, i) {
            output.indent(true);
            branch.print(output);
            if (i < last && branch.body.length > 0)
              output.newline();
          });
        });
    });
    function print_branch_body(self, output) {
      output.newline();
      self.body.forEach(function(stmt) {
        output.indent();
        stmt.print(output);
        output.newline();
      });
    }
    DEFPRINT(AST_Default, function(output) {
      output.print("default:");
      print_branch_body(this, output);
    });
    DEFPRINT(AST_Case, function(output) {
      var self = this;
      output.print("case");
      output.space();
      self.expression.print(output);
      output.print(":");
      print_branch_body(self, output);
    });
    DEFPRINT(AST_Try, function(output) {
      var self = this;
      output.print("try");
      output.space();
      print_braced(self, output);
      if (self.bcatch) {
        output.space();
        self.bcatch.print(output);
      }
      if (self.bfinally) {
        output.space();
        self.bfinally.print(output);
      }
    });
    DEFPRINT(AST_Catch, function(output) {
      var self = this;
      output.print("catch");
      if (self.argname) {
        output.space();
        output.with_parens(function() {
          self.argname.print(output);
        });
      }
      output.space();
      print_braced(self, output);
    });
    DEFPRINT(AST_Finally, function(output) {
      output.print("finally");
      output.space();
      print_braced(this, output);
    });
    function print_definitinos(type) {
      return function(output) {
        var self = this;
        output.print(type);
        output.space();
        self.definitions.forEach(function(def, i) {
          if (i)
            output.comma();
          def.print(output);
        });
        var p2 = output.parent();
        if (!(p2 instanceof AST_IterationStatement && p2.init === self))
          output.semicolon();
      };
    }
    DEFPRINT(AST_Const, print_definitinos("const"));
    DEFPRINT(AST_Let, print_definitinos("let"));
    DEFPRINT(AST_Var, print_definitinos("var"));
    function parenthesize_for_noin(node, output, noin) {
      var parens = false;
      if (noin)
        node.walk(new TreeWalker(function(node2) {
          if (parens)
            return true;
          if (node2 instanceof AST_Binary && node2.operator == "in")
            return parens = true;
          if (node2 instanceof AST_Scope && !(is_arrow(node2) && node2.value))
            return true;
        }));
      node.print(output, parens);
    }
    DEFPRINT(AST_VarDef, function(output) {
      var self = this;
      self.name.print(output);
      if (self.value) {
        output.space();
        output.print("=");
        output.space();
        var p2 = output.parent(1);
        var noin = p2 instanceof AST_For || p2 instanceof AST_ForEnumeration;
        parenthesize_for_noin(self.value, output, noin);
      }
    });
    DEFPRINT(AST_DefaultValue, function(output) {
      var self = this;
      self.name.print(output);
      output.space();
      output.print("=");
      output.space();
      self.value.print(output);
    });
    function print_annotation(self, output) {
      if (!output.option("annotations"))
        return;
      if (!self.pure)
        return;
      var level = 0, parent = self, node;
      do {
        node = parent;
        parent = output.parent(level++);
        if (parent instanceof AST_Call && parent.expression === node)
          return;
      } while (parent instanceof AST_PropAccess && parent.expression === node);
      output.print(typeof self.pure == "string" ? "/*" + self.pure + "*/" : "/*@__PURE__*/");
    }
    function print_call_args(self, output) {
      if (self.expression instanceof AST_Call || self.expression instanceof AST_Lambda) {
        output.add_mapping(self.start);
      }
      output.with_parens(function() {
        self.args.forEach(function(expr, i) {
          if (i)
            output.comma();
          expr.print(output);
        });
      });
    }
    DEFPRINT(AST_Call, function(output) {
      var self = this;
      print_annotation(self, output);
      self.expression.print(output);
      if (self.optional)
        output.print("?.");
      print_call_args(self, output);
    });
    DEFPRINT(AST_New, function(output) {
      var self = this;
      print_annotation(self, output);
      output.print("new");
      output.space();
      self.expression.print(output);
      if (need_constructor_parens(self, output))
        print_call_args(self, output);
    });
    DEFPRINT(AST_Sequence, function(output) {
      this.expressions.forEach(function(node, index) {
        if (index > 0) {
          output.comma();
          if (output.should_break()) {
            output.newline();
            output.indent();
          }
        }
        node.print(output);
      });
    });
    DEFPRINT(AST_Dot, function(output) {
      var self = this;
      var expr = self.expression;
      expr.print(output);
      var prop = self.property;
      if (output.option("ie") && RESERVED_WORDS[prop]) {
        output.print(self.optional ? "?.[" : "[");
        output.add_mapping(self.end);
        output.print_string(prop);
        output.print("]");
      } else {
        if (expr instanceof AST_Number && !/[ex.)]/i.test(output.last()))
          output.print(".");
        output.print(self.optional ? "?." : ".");
        output.add_mapping(self.end);
        output.print_name(prop);
      }
    });
    DEFPRINT(AST_Sub, function(output) {
      var self = this;
      self.expression.print(output);
      output.print(self.optional ? "?.[" : "[");
      self.property.print(output);
      output.print("]");
    });
    DEFPRINT(AST_Spread, function(output) {
      output.print("...");
      this.expression.print(output);
    });
    DEFPRINT(AST_UnaryPrefix, function(output) {
      var op = this.operator;
      var exp = this.expression;
      output.print(op);
      if (/^[a-z]/i.test(op) || /[+-]$/.test(op) && exp instanceof AST_UnaryPrefix && /^[+-]/.test(exp.operator)) {
        output.space();
      }
      exp.print(output);
    });
    DEFPRINT(AST_UnaryPostfix, function(output) {
      this.expression.print(output);
      output.print(this.operator);
    });
    DEFPRINT(AST_Binary, function(output) {
      var self = this;
      self.left.print(output);
      output.space();
      output.print(self.operator);
      output.space();
      self.right.print(output);
    });
    DEFPRINT(AST_Conditional, function(output) {
      var self = this;
      self.condition.print(output);
      output.space();
      output.print("?");
      output.space();
      self.consequent.print(output);
      output.space();
      output.colon();
      self.alternative.print(output);
    });
    DEFPRINT(AST_Await, function(output) {
      output.print("await");
      output.space();
      this.expression.print(output);
    });
    DEFPRINT(AST_Yield, function(output) {
      output.print(this.nested ? "yield*" : "yield");
      if (this.expression) {
        output.space();
        this.expression.print(output);
      }
    });
    DEFPRINT(AST_Array, function(output) {
      var a2 = this.elements, len = a2.length;
      output.with_square(len > 0 ? function() {
        output.space();
        a2.forEach(function(exp, i) {
          if (i)
            output.comma();
          exp.print(output);
          if (i === len - 1 && exp instanceof AST_Hole)
            output.comma();
        });
        output.space();
      } : noop);
    });
    DEFPRINT(AST_DestructuredArray, function(output) {
      var a2 = this.elements, len = a2.length, rest = this.rest;
      output.with_square(len || rest ? function() {
        output.space();
        a2.forEach(function(exp, i) {
          if (i)
            output.comma();
          exp.print(output);
        });
        if (rest) {
          if (len)
            output.comma();
          output.print("...");
          rest.print(output);
        } else if (a2[len - 1] instanceof AST_Hole) {
          output.comma();
        }
        output.space();
      } : noop);
    });
    DEFPRINT(AST_DestructuredKeyVal, function(output) {
      var self = this;
      var key = print_property_key(self, output);
      var value = self.value;
      if (key) {
        if (value instanceof AST_DefaultValue) {
          if (value.name instanceof AST_Symbol && key == get_symbol_name(value.name)) {
            output.space();
            output.print("=");
            output.space();
            value.value.print(output);
            return;
          }
        } else if (value instanceof AST_Symbol) {
          if (key == get_symbol_name(value))
            return;
        }
      }
      output.colon();
      value.print(output);
    });
    DEFPRINT(AST_DestructuredObject, function(output) {
      var props = this.properties, len = props.length, rest = this.rest;
      if (len || rest)
        output.with_block(function() {
          props.forEach(function(prop, i) {
            if (i) {
              output.print(",");
              output.newline();
            }
            output.indent();
            prop.print(output);
          });
          if (rest) {
            if (len) {
              output.print(",");
              output.newline();
            }
            output.indent();
            output.print("...");
            rest.print(output);
          }
          output.newline();
        });
      else
        print_braced_empty(this, output);
    });
    function print_properties(self, output, no_comma) {
      var props = self.properties;
      if (props.length > 0)
        output.with_block(function() {
          props.forEach(function(prop, i) {
            if (i) {
              if (!no_comma)
                output.print(",");
              output.newline();
            }
            output.indent();
            prop.print(output);
          });
          output.newline();
        });
      else
        print_braced_empty(self, output);
    }
    DEFPRINT(AST_Object, function(output) {
      print_properties(this, output);
    });
    function print_property_key(self, output) {
      var key = self.key;
      if (key instanceof AST_Node)
        return output.with_square(function() {
          key.print(output);
        });
      var quote = self.start && self.start.quote;
      if (output.option("quote_keys") || quote && output.option("keep_quoted_props")) {
        output.print_string(key, quote);
      } else if ("" + +key == key && key >= 0) {
        output.print(make_num(key));
      } else if (self.private) {
        output.print_name(key);
      } else if (RESERVED_WORDS[key] ? !output.option("ie") : is_identifier_string(key)) {
        output.print_name(key);
        return key;
      } else {
        output.print_string(key, quote);
      }
    }
    DEFPRINT(AST_ObjectKeyVal, function(output) {
      var self = this;
      print_property_key(self, output);
      output.colon();
      self.value.print(output);
    });
    DEFPRINT(AST_ObjectMethod, function(output) {
      print_method(this, output);
    });
    function print_accessor(type) {
      return function(output) {
        var self = this;
        if (self.static) {
          output.print("static");
          output.space();
        }
        output.print(type);
        output.space();
        print_property_key(self, output);
        print_lambda(self.value, output);
      };
    }
    DEFPRINT(AST_ObjectGetter, print_accessor("get"));
    DEFPRINT(AST_ObjectSetter, print_accessor("set"));
    function get_symbol_name(sym) {
      var def = sym.definition();
      return def && def.mangled_name || sym.name;
    }
    DEFPRINT(AST_Symbol, function(output) {
      output.print_name(get_symbol_name(this));
    });
    DEFPRINT(AST_SymbolExport, function(output) {
      var self = this;
      var name = get_symbol_name(self);
      output.print_name(name);
      var alias = self.alias;
      if (alias != name) {
        output.space();
        output.print("as");
        output.space();
        output.print_name(alias);
      }
    });
    DEFPRINT(AST_SymbolImport, function(output) {
      var self = this;
      var name = get_symbol_name(self);
      var key = self.key;
      if (key && key != name) {
        output.print_name(key);
        output.space();
        output.print("as");
        output.space();
      }
      output.print_name(name);
    });
    DEFPRINT(AST_Hole, noop);
    DEFPRINT(AST_Template, function(output) {
      var self = this;
      if (self.tag)
        self.tag.print(output);
      output.print("`");
      for (var i = 0;i < self.expressions.length; i++) {
        output.print(self.strings[i]);
        output.print("${");
        self.expressions[i].print(output);
        output.print("}");
      }
      output.print(self.strings[i]);
      output.print("`");
    });
    DEFPRINT(AST_Constant, function(output) {
      output.print("" + this.value);
    });
    DEFPRINT(AST_String, function(output) {
      output.print_string(this.value, this.quote);
    });
    DEFPRINT(AST_Number, function(output) {
      var start = this.start;
      if (use_asm && start && start.raw != null) {
        output.print(start.raw);
      } else {
        output.print(make_num(this.value));
      }
    });
    DEFPRINT(AST_RegExp, function(output) {
      var regexp = this.value;
      var str = regexp.toString();
      var end = str.lastIndexOf("/");
      if (regexp.raw_source) {
        str = "/" + regexp.raw_source + str.slice(end);
      } else if (end == 1) {
        str = "/(?:)" + str.slice(end);
      } else if (str.indexOf("/", 1) < end) {
        str = "/" + str.slice(1, end).replace(/\\\\|[^/]?\//g, function(match) {
          return match[0] == "\\" ? match : match.slice(0, -1) + "\\/";
        }) + str.slice(end);
      }
      output.print(output.to_utf8(str).replace(/\\(?:\0(?![0-9])|[^\0])/g, function(match) {
        switch (match[1]) {
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\t":
            return "\t";
          case "\b":
            return "\b";
          case "\f":
            return "\f";
          case "\0":
            return "\0";
          case "\v":
            return "\v";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            return match;
        }
      }).replace(/[\n\r\u2028\u2029]/g, function(c2) {
        switch (c2) {
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
        }
      }));
      var p2 = output.parent();
      if (p2 instanceof AST_Binary && /^in/.test(p2.operator) && p2.left === this)
        output.print(" ");
    });
    function force_statement(stat, output) {
      if (output.option("braces") && !(stat instanceof AST_Const || stat instanceof AST_Let)) {
        make_block(stat, output);
      } else if (stat instanceof AST_EmptyStatement) {
        output.force_semicolon();
      } else {
        output.space();
        stat.print(output);
      }
    }
    function need_constructor_parens(self, output) {
      if (self.args.length > 0)
        return true;
      return output.option("beautify");
    }
    function best_of(a2) {
      var best = a2[0], len = best.length;
      for (var i = 1;i < a2.length; ++i) {
        if (a2[i].length < len) {
          best = a2[i];
          len = best.length;
        }
      }
      return best;
    }
    function make_num(num) {
      var str = num.toString(10).replace(/^0\./, ".").replace("e+", "e");
      var candidates = [str];
      if (Math.floor(num) === num) {
        if (num < 0) {
          candidates.push("-0x" + (-num).toString(16).toLowerCase());
        } else {
          candidates.push("0x" + num.toString(16).toLowerCase());
        }
      }
      var match, len, digits;
      if (match = /^\.0+/.exec(str)) {
        len = match[0].length;
        digits = str.slice(len);
        candidates.push(digits + "e-" + (digits.length + len - 1));
      } else if (match = /0+$/.exec(str)) {
        len = match[0].length;
        candidates.push(str.slice(0, -len) + "e" + len);
      } else if (match = /^(\d)\.(\d+)e(-?\d+)$/.exec(str)) {
        candidates.push(match[1] + match[2] + "e" + (match[3] - match[2].length));
      }
      return best_of(candidates);
    }
    function make_block(stmt, output) {
      output.space();
      if (stmt instanceof AST_EmptyStatement) {
        print_braced_empty(stmt, output);
      } else if (stmt instanceof AST_BlockStatement) {
        stmt.print(output);
      } else
        output.with_block(function() {
          output.indent();
          stmt.print(output);
          output.newline();
        });
    }
    function DEFMAP(nodetype, generator) {
      nodetype.forEach(function(nodetype2) {
        nodetype2.DEFMETHOD("add_source_map", generator);
      });
    }
    DEFMAP([
      AST_Node,
      AST_LabeledStatement
    ], noop);
    DEFMAP([
      AST_Array,
      AST_BlockStatement,
      AST_Catch,
      AST_Constant,
      AST_Debugger,
      AST_Definitions,
      AST_Destructured,
      AST_Finally,
      AST_Jump,
      AST_Lambda,
      AST_New,
      AST_Object,
      AST_StatementWithBody,
      AST_Symbol,
      AST_Switch,
      AST_SwitchBranch,
      AST_Try
    ], function(output) {
      output.add_mapping(this.start);
    });
    DEFMAP([
      AST_ClassProperty,
      AST_DestructuredKeyVal,
      AST_ObjectProperty
    ], function(output) {
      if (typeof this.key == "string")
        output.add_mapping(this.start, this.key);
    });
  })();
});

// node_modules/uglify-js/lib/sourcemap.js
var exports_sourcemap = {};
var vlq_char, vlq_bits;
var init_sourcemap = __esm(() => {
  vlq_char = characters("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  vlq_bits = vlq_char.reduce(function(map, ch, bits) {
    map[ch] = bits;
    return map;
  }, Object.create(null));
});

// node_modules/uglify-js/lib/mozilla-ast.js
var require_mozilla_ast = __commonJS((exports) => {
  (function() {
    var MOZ_TO_ME = {
      Program: function(M3) {
        return new AST_Toplevel({
          start: my_start_token(M3),
          end: my_end_token(M3),
          body: normalize_directives(M3.body.map(from_moz))
        });
      },
      ArrowFunctionExpression: function(M3) {
        var argnames = [], rest = null;
        M3.params.forEach(function(param) {
          if (param.type == "RestElement") {
            rest = from_moz(param.argument);
          } else {
            argnames.push(from_moz(param));
          }
        });
        var fn = new (M3.async ? AST_AsyncArrow : AST_Arrow)({
          start: my_start_token(M3),
          end: my_end_token(M3),
          argnames,
          rest
        });
        var node = from_moz(M3.body);
        if (node instanceof AST_BlockStatement) {
          fn.body = normalize_directives(node.body);
          fn.value = null;
        } else {
          fn.body = [];
          fn.value = node;
        }
        return fn;
      },
      FunctionDeclaration: function(M3) {
        var ctor;
        if (M3.async) {
          ctor = M3.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;
        } else {
          ctor = M3.generator ? AST_GeneratorDefun : AST_Defun;
        }
        var argnames = [], rest = null;
        M3.params.forEach(function(param) {
          if (param.type == "RestElement") {
            rest = from_moz(param.argument);
          } else {
            argnames.push(from_moz(param));
          }
        });
        return new ctor({
          start: my_start_token(M3),
          end: my_end_token(M3),
          name: from_moz(M3.id),
          argnames,
          rest,
          body: normalize_directives(from_moz(M3.body).body)
        });
      },
      FunctionExpression: function(M3) {
        var ctor;
        if (M3.async) {
          ctor = M3.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;
        } else {
          ctor = M3.generator ? AST_GeneratorFunction : AST_Function;
        }
        var argnames = [], rest = null;
        M3.params.forEach(function(param) {
          if (param.type == "RestElement") {
            rest = from_moz(param.argument);
          } else {
            argnames.push(from_moz(param));
          }
        });
        return new ctor({
          start: my_start_token(M3),
          end: my_end_token(M3),
          name: from_moz(M3.id),
          argnames,
          rest,
          body: normalize_directives(from_moz(M3.body).body)
        });
      },
      ClassDeclaration: function(M3) {
        return new AST_DefClass({
          start: my_start_token(M3),
          end: my_end_token(M3),
          name: from_moz(M3.id),
          extends: from_moz(M3.superClass),
          properties: M3.body.body.map(from_moz)
        });
      },
      ClassExpression: function(M3) {
        return new AST_ClassExpression({
          start: my_start_token(M3),
          end: my_end_token(M3),
          name: from_moz(M3.id),
          extends: from_moz(M3.superClass),
          properties: M3.body.body.map(from_moz)
        });
      },
      MethodDefinition: function(M3) {
        var key = M3.key, internal = false;
        if (M3.computed) {
          key = from_moz(key);
        } else if (key.type == "PrivateIdentifier") {
          internal = true;
          key = "#" + key.name;
        } else {
          key = read_name(key);
        }
        var ctor = AST_ClassMethod, value = from_moz(M3.value);
        switch (M3.kind) {
          case "get":
            ctor = AST_ClassGetter;
            value = new AST_Accessor(value);
            break;
          case "set":
            ctor = AST_ClassSetter;
            value = new AST_Accessor(value);
            break;
        }
        return new ctor({
          start: my_start_token(M3),
          end: my_end_token(M3),
          key,
          private: internal,
          static: M3.static,
          value
        });
      },
      PropertyDefinition: function(M3) {
        var key = M3.key, internal = false;
        if (M3.computed) {
          key = from_moz(key);
        } else if (key.type == "PrivateIdentifier") {
          internal = true;
          key = "#" + key.name;
        } else {
          key = read_name(key);
        }
        return new AST_ClassField({
          start: my_start_token(M3),
          end: my_end_token(M3),
          key,
          private: internal,
          static: M3.static,
          value: from_moz(M3.value)
        });
      },
      ForOfStatement: function(M3) {
        return new (M3.await ? AST_ForAwaitOf : AST_ForOf)({
          start: my_start_token(M3),
          end: my_end_token(M3),
          init: from_moz(M3.left),
          object: from_moz(M3.right),
          body: from_moz(M3.body)
        });
      },
      TryStatement: function(M3) {
        var handlers = M3.handlers || [M3.handler];
        if (handlers.length > 1 || M3.guardedHandlers && M3.guardedHandlers.length) {
          throw new Error("Multiple catch clauses are not supported.");
        }
        return new AST_Try({
          start: my_start_token(M3),
          end: my_end_token(M3),
          body: from_moz(M3.block).body,
          bcatch: from_moz(handlers[0]),
          bfinally: M3.finalizer ? new AST_Finally(from_moz(M3.finalizer)) : null
        });
      },
      Property: function(M3) {
        var key = M3.computed ? from_moz(M3.key) : read_name(M3.key);
        var args = {
          start: my_start_token(M3),
          end: my_end_token(M3),
          key,
          value: from_moz(M3.value)
        };
        if (M3.kind == "init")
          return new (M3.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);
        args.value = new AST_Accessor(args.value);
        if (M3.kind == "get")
          return new AST_ObjectGetter(args);
        if (M3.kind == "set")
          return new AST_ObjectSetter(args);
      },
      ArrayExpression: function(M3) {
        return new AST_Array({
          start: my_start_token(M3),
          end: my_end_token(M3),
          elements: M3.elements.map(function(elem) {
            return elem === null ? new AST_Hole : from_moz(elem);
          })
        });
      },
      ArrayPattern: function(M3) {
        var elements = [], rest = null;
        M3.elements.forEach(function(el) {
          if (el === null) {
            elements.push(new AST_Hole);
          } else if (el.type == "RestElement") {
            rest = from_moz(el.argument);
          } else {
            elements.push(from_moz(el));
          }
        });
        return new AST_DestructuredArray({
          start: my_start_token(M3),
          end: my_end_token(M3),
          elements,
          rest
        });
      },
      ObjectPattern: function(M3) {
        var props = [], rest = null;
        M3.properties.forEach(function(prop) {
          if (prop.type == "RestElement") {
            rest = from_moz(prop.argument);
          } else {
            props.push(new AST_DestructuredKeyVal(from_moz(prop)));
          }
        });
        return new AST_DestructuredObject({
          start: my_start_token(M3),
          end: my_end_token(M3),
          properties: props,
          rest
        });
      },
      MemberExpression: function(M3) {
        return new (M3.computed ? AST_Sub : AST_Dot)({
          start: my_start_token(M3),
          end: my_end_token(M3),
          optional: M3.optional,
          expression: from_moz(M3.object),
          property: M3.computed ? from_moz(M3.property) : M3.property.name
        });
      },
      MetaProperty: function(M3) {
        var expr = from_moz(M3.meta);
        var prop = read_name(M3.property);
        if (expr.name == "new" && prop == "target")
          return new AST_NewTarget({
            start: my_start_token(M3),
            end: my_end_token(M3),
            name: "new.target"
          });
        return new AST_Dot({
          start: my_start_token(M3),
          end: my_end_token(M3),
          expression: expr,
          property: prop
        });
      },
      SwitchCase: function(M3) {
        return new (M3.test ? AST_Case : AST_Default)({
          start: my_start_token(M3),
          end: my_end_token(M3),
          expression: from_moz(M3.test),
          body: M3.consequent.map(from_moz)
        });
      },
      ExportAllDeclaration: function(M3) {
        var alias = M3.exported ? read_name(M3.exported) : "*";
        return new AST_ExportForeign({
          start: my_start_token(M3),
          end: my_end_token(M3),
          aliases: [alias],
          keys: ["*"],
          path: M3.source.value
        });
      },
      ExportDefaultDeclaration: function(M3) {
        var decl = from_moz(M3.declaration);
        if (!decl.name)
          switch (decl.CTOR) {
            case AST_AsyncDefun:
              decl = new AST_AsyncFunction(decl);
              break;
            case AST_AsyncGeneratorDefun:
              decl = new AST_AsyncGeneratorFunction(decl);
              break;
            case AST_DefClass:
              decl = new AST_ClassExpression(decl);
              break;
            case AST_Defun:
              decl = new AST_Function(decl);
              break;
            case AST_GeneratorDefun:
              decl = new AST_GeneratorFunction(decl);
              break;
          }
        return new AST_ExportDefault({
          start: my_start_token(M3),
          end: my_end_token(M3),
          body: decl
        });
      },
      ExportNamedDeclaration: function(M3) {
        if (M3.declaration)
          return new AST_ExportDeclaration({
            start: my_start_token(M3),
            end: my_end_token(M3),
            body: from_moz(M3.declaration)
          });
        if (M3.source) {
          var aliases = [], keys = [];
          M3.specifiers.forEach(function(prop) {
            aliases.push(read_name(prop.exported));
            keys.push(read_name(prop.local));
          });
          return new AST_ExportForeign({
            start: my_start_token(M3),
            end: my_end_token(M3),
            aliases,
            keys,
            path: M3.source.value
          });
        }
        return new AST_ExportReferences({
          start: my_start_token(M3),
          end: my_end_token(M3),
          properties: M3.specifiers.map(function(prop) {
            var sym = new AST_SymbolExport(from_moz(prop.local));
            sym.alias = read_name(prop.exported);
            return sym;
          })
        });
      },
      ImportDeclaration: function(M3) {
        var all2 = null, def = null, props = null;
        M3.specifiers.forEach(function(prop) {
          var sym = new AST_SymbolImport(from_moz(prop.local));
          switch (prop.type) {
            case "ImportDefaultSpecifier":
              def = sym;
              def.key = "";
              break;
            case "ImportNamespaceSpecifier":
              all2 = sym;
              all2.key = "*";
              break;
            default:
              sym.key = prop.imported.name || syn.name;
              if (!props)
                props = [];
              props.push(sym);
              break;
          }
        });
        return new AST_Import({
          start: my_start_token(M3),
          end: my_end_token(M3),
          all: all2,
          default: def,
          properties: props,
          path: M3.source.value
        });
      },
      ImportExpression: function(M3) {
        var start = my_start_token(M3);
        var arg = from_moz(M3.source);
        return new AST_Call({
          start,
          end: my_end_token(M3),
          expression: new AST_SymbolRef({
            start,
            end: arg.start,
            name: "import"
          }),
          args: [arg]
        });
      },
      VariableDeclaration: function(M3) {
        return new ({
          const: AST_Const,
          let: AST_Let
        }[M3.kind] || AST_Var)({
          start: my_start_token(M3),
          end: my_end_token(M3),
          definitions: M3.declarations.map(from_moz)
        });
      },
      Literal: function(M3) {
        var args = {
          start: my_start_token(M3),
          end: my_end_token(M3)
        };
        if (M3.bigint) {
          args.value = M3.bigint.toLowerCase() + "n";
          return new AST_BigInt(args);
        }
        var val = M3.value;
        if (val === null)
          return new AST_Null(args);
        var rx = M3.regex;
        if (rx && rx.pattern) {
          args.value = new RegExp(rx.pattern, rx.flags);
          args.value.raw_source = rx.pattern;
          return new AST_RegExp(args);
        } else if (rx) {
          args.value = M3.regex && M3.raw ? M3.raw : val;
          return new AST_RegExp(args);
        }
        switch (typeof val) {
          case "string":
            args.value = val;
            return new AST_String(args);
          case "number":
            if (isNaN(val))
              return new AST_NaN(args);
            var negate, node;
            if (isFinite(val)) {
              negate = 1 / val < 0;
              args.value = negate ? -val : val;
              node = new AST_Number(args);
            } else {
              negate = val < 0;
              node = new AST_Infinity(args);
            }
            return negate ? new AST_UnaryPrefix({
              start: args.start,
              end: args.end,
              operator: "-",
              expression: node
            }) : node;
          case "boolean":
            return new (val ? AST_True : AST_False)(args);
        }
      },
      TemplateLiteral: function(M3) {
        return new AST_Template({
          start: my_start_token(M3),
          end: my_end_token(M3),
          expressions: M3.expressions.map(from_moz),
          strings: M3.quasis.map(function(el) {
            return el.value.raw;
          })
        });
      },
      TaggedTemplateExpression: function(M3) {
        var tmpl = from_moz(M3.quasi);
        tmpl.start = my_start_token(M3);
        tmpl.end = my_end_token(M3);
        tmpl.tag = from_moz(M3.tag);
        return tmpl;
      },
      Identifier: function(M3) {
        var p2, level = FROM_MOZ_STACK.length - 1;
        do {
          p2 = FROM_MOZ_STACK[--level];
        } while (p2.type == "ArrayPattern" || p2.type == "AssignmentPattern" && p2.left === FROM_MOZ_STACK[level + 1] || p2.type == "ObjectPattern" || p2.type == "Property" && p2.value === FROM_MOZ_STACK[level + 1] || p2.type == "VariableDeclarator" && p2.id === FROM_MOZ_STACK[level + 1]);
        var ctor = AST_SymbolRef;
        switch (p2.type) {
          case "ArrowFunctionExpression":
            if (p2.body !== FROM_MOZ_STACK[level + 1])
              ctor = AST_SymbolFunarg;
            break;
          case "BreakStatement":
          case "ContinueStatement":
            ctor = AST_LabelRef;
            break;
          case "CatchClause":
            ctor = AST_SymbolCatch;
            break;
          case "ClassDeclaration":
            if (p2.id === FROM_MOZ_STACK[level + 1])
              ctor = AST_SymbolDefClass;
            break;
          case "ClassExpression":
            if (p2.id === FROM_MOZ_STACK[level + 1])
              ctor = AST_SymbolClass;
            break;
          case "FunctionDeclaration":
            ctor = p2.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;
            break;
          case "FunctionExpression":
            ctor = p2.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;
            break;
          case "LabeledStatement":
            ctor = AST_Label;
            break;
          case "VariableDeclaration":
            ctor = {
              const: AST_SymbolConst,
              let: AST_SymbolLet
            }[p2.kind] || AST_SymbolVar;
            break;
        }
        return new ctor({
          start: my_start_token(M3),
          end: my_end_token(M3),
          name: M3.name
        });
      },
      Super: function(M3) {
        return new AST_Super({
          start: my_start_token(M3),
          end: my_end_token(M3),
          name: "super"
        });
      },
      ThisExpression: function(M3) {
        return new AST_This({
          start: my_start_token(M3),
          end: my_end_token(M3),
          name: "this"
        });
      },
      ParenthesizedExpression: function(M3) {
        var node = from_moz(M3.expression);
        if (!node.start.parens)
          node.start.parens = [];
        node.start.parens.push(my_start_token(M3));
        if (!node.end.parens)
          node.end.parens = [];
        node.end.parens.push(my_end_token(M3));
        return node;
      },
      ChainExpression: function(M3) {
        var node = from_moz(M3.expression);
        node.terminal = true;
        return node;
      }
    };
    MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M3) {
      var prefix = "prefix" in M3 ? M3.prefix : M3.type == "UnaryExpression" ? true : false;
      return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
        start: my_start_token(M3),
        end: my_end_token(M3),
        operator: M3.operator,
        expression: from_moz(M3.argument)
      });
    };
    map("EmptyStatement", AST_EmptyStatement);
    map("ExpressionStatement", AST_SimpleStatement, "expression>body");
    map("BlockStatement", AST_BlockStatement, "body@body");
    map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
    map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
    map("BreakStatement", AST_Break, "label>label");
    map("ContinueStatement", AST_Continue, "label>label");
    map("WithStatement", AST_With, "object>expression, body>body");
    map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
    map("ReturnStatement", AST_Return, "argument>value");
    map("ThrowStatement", AST_Throw, "argument>value");
    map("WhileStatement", AST_While, "test>condition, body>body");
    map("DoWhileStatement", AST_Do, "test>condition, body>body");
    map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
    map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
    map("DebuggerStatement", AST_Debugger);
    map("VariableDeclarator", AST_VarDef, "id>name, init>value");
    map("CatchClause", AST_Catch, "param>argname, body%body");
    map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
    map("AssignmentPattern", AST_DefaultValue, "left>name, right>value");
    map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
    map("NewExpression", AST_New, "callee>expression, arguments@args, pure=pure");
    map("CallExpression", AST_Call, "callee>expression, arguments@args, optional=optional, pure=pure");
    map("SequenceExpression", AST_Sequence, "expressions@expressions");
    map("SpreadElement", AST_Spread, "argument>expression");
    map("ObjectExpression", AST_Object, "properties@properties");
    map("AwaitExpression", AST_Await, "argument>expression");
    map("YieldExpression", AST_Yield, "argument>expression, delegate=nested");
    def_to_moz(AST_Toplevel, function To_Moz_Program(M3) {
      return to_moz_scope("Program", M3);
    });
    def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M3) {
      var params = M3.argnames.map(to_moz);
      if (M3.rest)
        params.push({
          type: "RestElement",
          argument: to_moz(M3.rest)
        });
      return {
        type: "FunctionDeclaration",
        id: to_moz(M3.name),
        async: is_async(M3),
        generator: is_generator(M3),
        params,
        body: to_moz_scope("BlockStatement", M3)
      };
    });
    def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M3) {
      var params = M3.argnames.map(to_moz);
      if (M3.rest)
        params.push({
          type: "RestElement",
          argument: to_moz(M3.rest)
        });
      if (is_arrow(M3))
        return {
          type: "ArrowFunctionExpression",
          async: is_async(M3),
          params,
          body: M3.value ? to_moz(M3.value) : to_moz_scope("BlockStatement", M3)
        };
      return {
        type: "FunctionExpression",
        id: to_moz(M3.name),
        async: is_async(M3),
        generator: is_generator(M3),
        params,
        body: to_moz_scope("BlockStatement", M3)
      };
    });
    def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M3) {
      return {
        type: "ClassDeclaration",
        id: to_moz(M3.name),
        superClass: to_moz(M3.extends),
        body: {
          type: "ClassBody",
          body: M3.properties.map(to_moz)
        }
      };
    });
    def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M3) {
      return {
        type: "ClassExpression",
        id: to_moz(M3.name),
        superClass: to_moz(M3.extends),
        body: {
          type: "ClassBody",
          body: M3.properties.map(to_moz)
        }
      };
    });
    function To_Moz_MethodDefinition(kind) {
      return function(M3) {
        var computed = M3.key instanceof AST_Node;
        var key = computed ? to_moz(M3.key) : M3.private ? {
          type: "PrivateIdentifier",
          name: M3.key.slice(1)
        } : {
          type: "Literal",
          value: M3.key
        };
        return {
          type: "MethodDefinition",
          kind,
          computed,
          key,
          static: M3.static,
          value: to_moz(M3.value)
        };
      };
    }
    def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition("get"));
    def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition("set"));
    def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition("method"));
    def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M3) {
      var computed = M3.key instanceof AST_Node;
      var key = computed ? to_moz(M3.key) : M3.private ? {
        type: "PrivateIdentifier",
        name: M3.key.slice(1)
      } : {
        type: "Literal",
        value: M3.key
      };
      return {
        type: "PropertyDefinition",
        computed,
        key,
        static: M3.static,
        value: to_moz(M3.value)
      };
    });
    function To_Moz_ForOfStatement(is_await) {
      return function(M3) {
        return {
          type: "ForOfStatement",
          await: is_await,
          left: to_moz(M3.init),
          right: to_moz(M3.object),
          body: to_moz(M3.body)
        };
      };
    }
    def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));
    def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));
    def_to_moz(AST_Directive, function To_Moz_Directive(M3) {
      return {
        type: "ExpressionStatement",
        expression: set_moz_loc(M3, {
          type: "Literal",
          value: M3.value
        })
      };
    });
    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M3) {
      return {
        type: "SwitchCase",
        test: to_moz(M3.expression),
        consequent: M3.body.map(to_moz)
      };
    });
    def_to_moz(AST_Try, function To_Moz_TryStatement(M3) {
      return {
        type: "TryStatement",
        block: to_moz_block(M3),
        handler: to_moz(M3.bcatch),
        guardedHandlers: [],
        finalizer: to_moz(M3.bfinally)
      };
    });
    def_to_moz(AST_Catch, function To_Moz_CatchClause(M3) {
      return {
        type: "CatchClause",
        param: to_moz(M3.argname),
        guard: null,
        body: to_moz_block(M3)
      };
    });
    def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M3) {
      return {
        type: "ExportNamedDeclaration",
        declaration: to_moz(M3.body)
      };
    });
    def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M3) {
      return {
        type: "ExportDefaultDeclaration",
        declaration: to_moz(M3.body)
      };
    });
    def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M3) {
      if (M3.keys[0] == "*")
        return {
          type: "ExportAllDeclaration",
          exported: M3.aliases[0] == "*" ? null : {
            type: "Identifier",
            name: M3.aliases[0]
          },
          source: {
            type: "Literal",
            value: M3.path
          }
        };
      var specifiers = [];
      for (var i = 0;i < M3.aliases.length; i++) {
        specifiers.push({
          type: "ExportSpecifier",
          exported: {
            type: "Identifier",
            name: M3.aliases[i]
          },
          local: {
            type: "Identifier",
            name: M3.keys[i]
          }
        });
      }
      return {
        type: "ExportNamedDeclaration",
        specifiers,
        source: {
          type: "Literal",
          value: M3.path
        }
      };
    });
    def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M3) {
      return {
        type: "ExportNamedDeclaration",
        specifiers: M3.properties.map(function(prop) {
          return {
            type: "ExportSpecifier",
            local: to_moz(prop),
            exported: {
              type: "Identifier",
              name: prop.alias
            }
          };
        })
      };
    });
    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M3) {
      var specifiers = M3.properties ? M3.properties.map(function(prop) {
        return {
          type: "ImportSpecifier",
          local: to_moz(prop),
          imported: {
            type: "Identifier",
            name: prop.key
          }
        };
      }) : [];
      if (M3.all)
        specifiers.unshift({
          type: "ImportNamespaceSpecifier",
          local: to_moz(M3.all)
        });
      if (M3.default)
        specifiers.unshift({
          type: "ImportDefaultSpecifier",
          local: to_moz(M3.default)
        });
      return {
        type: "ImportDeclaration",
        specifiers,
        source: {
          type: "Literal",
          value: M3.path
        }
      };
    });
    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M3) {
      return {
        type: "VariableDeclaration",
        kind: M3.TYPE.toLowerCase(),
        declarations: M3.definitions.map(to_moz)
      };
    });
    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M3) {
      var computed = M3 instanceof AST_Sub;
      var expr = {
        type: "MemberExpression",
        object: to_moz(M3.expression),
        computed,
        optional: M3.optional,
        property: computed ? to_moz(M3.property) : {
          type: "Identifier",
          name: M3.property
        }
      };
      return M3.terminal ? {
        type: "ChainExpression",
        expression: expr
      } : expr;
    });
    def_to_moz(AST_Unary, function To_Moz_Unary(M3) {
      return {
        type: M3.operator == "++" || M3.operator == "--" ? "UpdateExpression" : "UnaryExpression",
        operator: M3.operator,
        prefix: M3 instanceof AST_UnaryPrefix,
        argument: to_moz(M3.expression)
      };
    });
    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M3) {
      return {
        type: M3.operator == "&&" || M3.operator == "||" ? "LogicalExpression" : "BinaryExpression",
        left: to_moz(M3.left),
        operator: M3.operator,
        right: to_moz(M3.right)
      };
    });
    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M3) {
      return {
        type: "ArrayExpression",
        elements: M3.elements.map(to_moz)
      };
    });
    def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M3) {
      var elements = M3.elements.map(to_moz);
      if (M3.rest)
        elements.push({
          type: "RestElement",
          argument: to_moz(M3.rest)
        });
      return {
        type: "ArrayPattern",
        elements
      };
    });
    def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M3) {
      var computed = M3.key instanceof AST_Node;
      var key = computed ? to_moz(M3.key) : {
        type: "Literal",
        value: M3.key
      };
      return {
        type: "Property",
        kind: "init",
        computed,
        key,
        value: to_moz(M3.value)
      };
    });
    def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M3) {
      var props = M3.properties.map(to_moz);
      if (M3.rest)
        props.push({
          type: "RestElement",
          argument: to_moz(M3.rest)
        });
      return {
        type: "ObjectPattern",
        properties: props
      };
    });
    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M3) {
      var computed = M3.key instanceof AST_Node;
      var key = computed ? to_moz(M3.key) : {
        type: "Literal",
        value: M3.key
      };
      var kind;
      if (M3 instanceof AST_ObjectKeyVal) {
        kind = "init";
      } else if (M3 instanceof AST_ObjectGetter) {
        kind = "get";
      } else if (M3 instanceof AST_ObjectSetter) {
        kind = "set";
      }
      return {
        type: "Property",
        kind,
        computed,
        method: M3 instanceof AST_ObjectMethod,
        key,
        value: to_moz(M3.value)
      };
    });
    def_to_moz(AST_Symbol, function To_Moz_Identifier(M3) {
      var def = M3.definition();
      return {
        type: "Identifier",
        name: def && def.mangled_name || M3.name
      };
    });
    def_to_moz(AST_Super, function To_Moz_Super() {
      return { type: "Super" };
    });
    def_to_moz(AST_This, function To_Moz_ThisExpression() {
      return { type: "ThisExpression" };
    });
    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {
      return {
        type: "MetaProperty",
        meta: {
          type: "Identifier",
          name: "new"
        },
        property: {
          type: "Identifier",
          name: "target"
        }
      };
    });
    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M3) {
      var flags = M3.value.toString().match(/[gimuy]*$/)[0];
      var value = "/" + M3.value.raw_source + "/" + flags;
      return {
        type: "Literal",
        value,
        raw: value,
        regex: {
          pattern: M3.value.raw_source,
          flags
        }
      };
    });
    def_to_moz(AST_BigInt, function To_Moz_BigInt(M3) {
      var value = M3.value;
      return {
        type: "Literal",
        bigint: value.slice(0, -1),
        raw: value
      };
    });
    function To_Moz_Literal(M3) {
      var value = M3.value;
      if (typeof value === "number" && (value < 0 || value === 0 && 1 / value < 0)) {
        return {
          type: "UnaryExpression",
          operator: "-",
          prefix: true,
          argument: {
            type: "Literal",
            value: -value,
            raw: M3.start.raw
          }
        };
      }
      return {
        type: "Literal",
        value,
        raw: M3.start.raw
      };
    }
    def_to_moz(AST_Boolean, To_Moz_Literal);
    def_to_moz(AST_Constant, To_Moz_Literal);
    def_to_moz(AST_Null, To_Moz_Literal);
    def_to_moz(AST_Atom, function To_Moz_Atom(M3) {
      return {
        type: "Identifier",
        name: String(M3.value)
      };
    });
    def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M3) {
      var last = M3.strings.length - 1;
      var tmpl = {
        type: "TemplateLiteral",
        expressions: M3.expressions.map(to_moz),
        quasis: M3.strings.map(function(str, index) {
          return {
            type: "TemplateElement",
            tail: index == last,
            value: { raw: str }
          };
        })
      };
      if (!M3.tag)
        return tmpl;
      return {
        type: "TaggedTemplateExpression",
        tag: to_moz(M3.tag),
        quasi: tmpl
      };
    });
    AST_Block.DEFMETHOD("to_mozilla_ast", AST_BlockStatement.prototype.to_mozilla_ast);
    AST_Hole.DEFMETHOD("to_mozilla_ast", return_null);
    AST_Node.DEFMETHOD("to_mozilla_ast", function() {
      throw new Error("Cannot convert AST_" + this.TYPE);
    });
    function normalize_directives(body) {
      for (var i = 0;i < body.length; i++) {
        var stat = body[i];
        if (!(stat instanceof AST_SimpleStatement))
          break;
        var node = stat.body;
        if (!(node instanceof AST_String))
          break;
        if (stat.start.pos !== node.start.pos)
          break;
        body[i] = new AST_Directive(node);
      }
      return body;
    }
    function raw_token(moznode) {
      if (moznode.type == "Literal") {
        return moznode.raw != null ? moznode.raw : moznode.value + "";
      }
    }
    function my_start_token(moznode) {
      var loc = moznode.loc, start = loc && loc.start;
      var range = moznode.range;
      return new AST_Token({
        file: loc && loc.source,
        line: start && start.line,
        col: start && start.column,
        pos: range ? range[0] : moznode.start,
        endline: start && start.line,
        endcol: start && start.column,
        endpos: range ? range[0] : moznode.start,
        raw: raw_token(moznode)
      });
    }
    function my_end_token(moznode) {
      var loc = moznode.loc, end = loc && loc.end;
      var range = moznode.range;
      return new AST_Token({
        file: loc && loc.source,
        line: end && end.line,
        col: end && end.column,
        pos: range ? range[1] : moznode.end,
        endline: end && end.line,
        endcol: end && end.column,
        endpos: range ? range[1] : moznode.end,
        raw: raw_token(moznode)
      });
    }
    function read_name(M3) {
      return "" + M3[M3.type == "Identifier" ? "name" : "value"];
    }
    function map(moztype, mytype, propmap) {
      var moz_to_me = [
        "start: my_start_token(M)",
        "end: my_end_token(M)"
      ];
      var me_to_moz = [
        "type: " + JSON.stringify(moztype)
      ];
      if (propmap)
        propmap.split(/\s*,\s*/).forEach(function(prop) {
          var m4 = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
          if (!m4)
            throw new Error("Can't understand property map: " + prop);
          var moz = m4[1], how = m4[2], my = m4[3];
          switch (how) {
            case "@":
              moz_to_me.push(my + ": M." + moz + ".map(from_moz)");
              me_to_moz.push(moz + ": M." + my + ".map(to_moz)");
              break;
            case ">":
              moz_to_me.push(my + ": from_moz(M." + moz + ")");
              me_to_moz.push(moz + ": to_moz(M." + my + ")");
              break;
            case "=":
              moz_to_me.push(my + ": M." + moz);
              me_to_moz.push(moz + ": M." + my);
              break;
            case "%":
              moz_to_me.push(my + ": from_moz(M." + moz + ").body");
              me_to_moz.push(moz + ": to_moz_block(M)");
              break;
            default:
              throw new Error("Can't understand operator in propmap: " + prop);
          }
        });
      MOZ_TO_ME[moztype] = new Function("U2", "my_start_token", "my_end_token", "from_moz", [
        "return function From_Moz_" + moztype + "(M) {",
        "    return new U2.AST_" + mytype.TYPE + "({",
        moz_to_me.join(",\n"),
        "    });",
        "};"
      ].join("\n"))(exports, my_start_token, my_end_token, from_moz);
      def_to_moz(mytype, new Function("to_moz", "to_moz_block", "to_moz_scope", [
        "return function To_Moz_" + moztype + "(M) {",
        "    return {",
        me_to_moz.join(",\n"),
        "    };",
        "};"
      ].join("\n"))(to_moz, to_moz_block, to_moz_scope));
    }
    var FROM_MOZ_STACK = null;
    function from_moz(moz) {
      FROM_MOZ_STACK.push(moz);
      var node = null;
      if (moz) {
        if (!HOP(MOZ_TO_ME, moz.type))
          throw new Error("Unsupported type: " + moz.type);
        node = MOZ_TO_ME[moz.type](moz);
      }
      FROM_MOZ_STACK.pop();
      return node;
    }
    AST_Node.from_mozilla_ast = function(node) {
      var save_stack = FROM_MOZ_STACK;
      FROM_MOZ_STACK = [];
      var ast = from_moz(node);
      FROM_MOZ_STACK = save_stack;
      ast.walk(new TreeWalker(function(node2) {
        if (node2 instanceof AST_LabelRef) {
          for (var level = 0, parent;parent = this.parent(level); level++) {
            if (parent instanceof AST_Scope)
              break;
            if (parent instanceof AST_LabeledStatement && parent.label.name == node2.name) {
              node2.thedef = parent.label;
              break;
            }
          }
          if (!node2.thedef) {
            var s2 = node2.start;
            js_error("Undefined label " + node2.name, s2.file, s2.line, s2.col, s2.pos);
          }
        }
      }));
      return ast;
    };
    function set_moz_loc(mynode, moznode) {
      var start = mynode.start;
      var end = mynode.end;
      if (start.pos != null && end.endpos != null) {
        moznode.range = [start.pos, end.endpos];
      }
      if (start.line) {
        moznode.loc = {
          start: { line: start.line, column: start.col },
          end: end.endline ? { line: end.endline, column: end.endcol } : null
        };
        if (start.file) {
          moznode.loc.source = start.file;
        }
      }
      return moznode;
    }
    function def_to_moz(mytype, handler) {
      mytype.DEFMETHOD("to_mozilla_ast", function() {
        return set_moz_loc(this, handler(this));
      });
    }
    function to_moz(node) {
      return node != null ? node.to_mozilla_ast() : null;
    }
    function to_moz_block(node) {
      return {
        type: "BlockStatement",
        body: node.body.map(to_moz)
      };
    }
    function to_moz_scope(type, node) {
      var body = node.body.map(to_moz);
      if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {
        body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));
      }
      return {
        type,
        body
      };
    }
  })();
});

// node_modules/uglify-js/lib/propmangle.js
var exports_propmangle = {};
var builtins;
var init_propmangle = __esm(() => {
  builtins = function() {
    var names = [];
    [
      "null",
      "true",
      "false",
      "Infinity",
      "-Infinity",
      "undefined"
    ].forEach(add);
    [
      Array,
      Boolean,
      Date,
      Error,
      Function,
      Math,
      Number,
      Object,
      RegExp,
      String
    ].forEach(function(ctor) {
      Object.getOwnPropertyNames(ctor).map(add);
      if (ctor.prototype) {
        Object.getOwnPropertyNames(new ctor).map(add);
        Object.getOwnPropertyNames(ctor.prototype).map(add);
      }
    });
    return makePredicate(names);
    function add(name) {
      names.push(name);
    }
  }();
});

// node_modules/uglify-js/lib/minify.js
var exports_minify = {};
var to_ascii, to_base64;
var init_minify = __esm(() => {
  if (typeof Buffer == "undefined") {
    to_ascii = atob;
    to_base64 = btoa;
  } else if (typeof Buffer.alloc == "undefined") {
    to_ascii = function(b64) {
      return new Buffer(b64, "base64").toString();
    };
    to_base64 = function(str) {
      return new Buffer(str).toString("base64");
    };
  } else {
    to_ascii = function(b64) {
      return Buffer.from(b64, "base64").toString();
    };
    to_base64 = function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
});

// node_modules/uglify-js/tools/exports.js
var require_exports = __commonJS((exports) => {
  exports.Dictionary = Dictionary;
  exports.is_statement = is_statement;
  exports.List = List;
  exports.minify = minify;
  exports.parse = parse;
  exports.push_uniq = push_uniq;
  exports.TreeTransformer = TreeTransformer;
  exports.TreeWalker = TreeWalker;
});

// node_modules/uglify-js/tools/node.js
var require_node = __commonJS((exports) => {
  var to_comment = function(value) {
    if (typeof value != "string")
      value = JSON.stringify(value, function(key, value2) {
        return typeof value2 == "function" ? "<[ " + value2 + " ]>" : value2;
      }, 2);
    return "// " + value.replace(/\n/g, "\n// ");
  };
  var describe_ast = function() {
    var out = OutputStream({ beautify: true });
    doitem(AST_Node);
    return out.get() + "\n";
    function doitem(ctor) {
      out.print("AST_" + ctor.TYPE);
      var props = ctor.SELF_PROPS.filter(function(prop) {
        return !/^\$/.test(prop);
      });
      if (props.length > 0) {
        out.space();
        out.with_parens(function() {
          props.forEach(function(prop, i) {
            if (i)
              out.space();
            out.print(prop);
          });
        });
      }
      if (ctor.documentation) {
        out.space();
        out.print_string(ctor.documentation);
      }
      if (ctor.SUBCLASSES.length > 0) {
        out.space();
        out.with_block(function() {
          ctor.SUBCLASSES.sort(function(a2, b5) {
            return a2.TYPE < b5.TYPE ? -1 : 1;
          }).forEach(function(ctor2, i) {
            out.indent();
            doitem(ctor2);
            out.newline();
          });
        });
      }
    }
  };
  var infer_options = function(options) {
    var result = exports.minify("", options);
    return result.error && result.error.defs;
  };
  var fs = (()=>({}));
  exports.FILES = [
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/utils.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/ast.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/transform.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/parse.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/scope.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/compress.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/output.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/sourcemap.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/mozilla-ast.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/propmangle.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/lib/minify.js",
    "/Users/francisarant/Documents/projects/ProgrammingProjects/2024/02_February/html-minifier/node_modules/uglify-js/tools/exports.js"
  ];
  new Function("exports", function() {
    var code = exports.FILES.map(function(file) {
      return fs.readFileSync(file, "utf8");
    });
    code.push("exports.describe_ast = " + describe_ast.toString());
    return code.join("\n\n");
  }())(exports);
  if (+process.env["UGLIFY_BUG_REPORT"]) {
    var $minify = function(files, options) {
      if (typeof options == "undefined")
        options = "<<undefined>>";
      var code = [
        "// UGLIFY_BUG_REPORT",
        to_comment(options)
      ];
      if (typeof files == "string") {
        code.push("");
        code.push("//-------------------------------------------------------------");
        code.push("// INPUT CODE", files);
      } else
        for (var name in files) {
          code.push("");
          code.push("//-------------------------------------------------------------");
          code.push(to_comment(name), files[name]);
        }
      if (options.sourceMap && options.sourceMap.url) {
        code.push("");
        code.push("//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiJ9");
      }
      var result = { code: code.join("\n") };
      if (options.sourceMap)
        result.map = '{"version":3,"sources":[],"names":[],"mappings":""}';
      return result;
    };

    export { $minify as minify };
  }
  exports.default_options = function() {
    var defs = infer_options({ 0: 0 });
    Object.keys(defs).forEach(function(component) {
      var options = {};
      options[component] = { 0: 0 };
      if (options = infer_options(options)) {
        defs[component] = options;
      }
    });
    return defs;
  };
});

// src/htmlminifier.js
var trimWhitespace = function(str) {
  return str && str.replace(/^[ \n\r\t\f]+/, "").replace(/[ \n\r\t\f]+$/, "");
};
var collapseWhitespaceAll = function(str) {
  return str && str.replace(/[ \n\r\t\f\xA0]+/g, function(spaces) {
    return spaces === "\t" ? "\t" : spaces.replace(/(^|\xA0+)[^\xA0]+/g, "$1 ");
  });
};
var collapseWhitespace = function(str, options, trimLeft, trimRight, collapseAll) {
  var lineBreakBefore = "", lineBreakAfter = "";
  if (options.preserveLineBreaks) {
    str = str.replace(/^[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*/, function() {
      lineBreakBefore = "\n";
      return "";
    }).replace(/[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*$/, function() {
      lineBreakAfter = "\n";
      return "";
    });
  }
  if (trimLeft) {
    str = str.replace(/^[ \n\r\t\f\xA0]+/, function(spaces) {
      var conservative = !lineBreakBefore && options.conservativeCollapse;
      if (conservative && spaces === "\t") {
        return "\t";
      }
      return spaces.replace(/^[^\xA0]+/, "").replace(/(\xA0+)[^\xA0]+/g, "$1 ") || (conservative ? " " : "");
    });
  }
  if (trimRight) {
    str = str.replace(/[ \n\r\t\f\xA0]+$/, function(spaces) {
      var conservative = !lineBreakAfter && options.conservativeCollapse;
      if (conservative && spaces === "\t") {
        return "\t";
      }
      return spaces.replace(/[^\xA0]+(\xA0+)/g, " $1").replace(/[^\xA0]+$/, "") || (conservative ? " " : "");
    });
  }
  if (collapseAll) {
    str = collapseWhitespaceAll(str);
  }
  return lineBreakBefore + str + lineBreakAfter;
};
var collapseWhitespaceSmart = function(str, prevTag, nextTag, options) {
  var trimLeft = prevTag && !selfClosingInlineTags(prevTag);
  if (trimLeft && !options.collapseInlineTagWhitespace) {
    trimLeft = prevTag.charAt(0) === "/" ? !inlineTags(prevTag.slice(1)) : !inlineTextTags(prevTag);
  }
  var trimRight = nextTag && !selfClosingInlineTags(nextTag);
  if (trimRight && !options.collapseInlineTagWhitespace) {
    trimRight = nextTag.charAt(0) === "/" ? !inlineTextTags(nextTag.slice(1)) : !inlineTags(nextTag);
  }
  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);
};
var isConditionalComment = function(text) {
  return /^\[if\s[^\]]+]|\[endif]$/.test(text);
};
var isIgnoredComment = function(text, options) {
  for (var i = 0, len = options.ignoreCustomComments.length;i < len; i++) {
    if (options.ignoreCustomComments[i].test(text)) {
      return true;
    }
  }
  return false;
};
var isEventAttribute = function(attrName, options) {
  var patterns = options.customEventAttributes;
  if (patterns) {
    for (var i = patterns.length;i--; ) {
      if (patterns[i].test(attrName)) {
        return true;
      }
    }
    return false;
  }
  return /^on[a-z]{3,}$/.test(attrName);
};
var canRemoveAttributeQuotes = function(value) {
  return /^[^ \t\n\f\r"'`=<>]+$/.test(value);
};
var attributesInclude = function(attributes, attribute) {
  for (var i = attributes.length;i--; ) {
    if (attributes[i].name.toLowerCase() === attribute) {
      return true;
    }
  }
  return false;
};
var isAttributeRedundant = function(tag, attrName, attrValue, attrs) {
  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : "";
  return tag === "script" && attrName === "language" && attrValue === "javascript" || tag === "form" && attrName === "method" && attrValue === "get" || tag === "input" && attrName === "type" && attrValue === "text" || tag === "script" && attrName === "charset" && !attributesInclude(attrs, "src") || tag === "a" && attrName === "name" && attributesInclude(attrs, "id") || tag === "area" && attrName === "shape" && attrValue === "rect";
};
var isScriptTypeAttribute = function(attrValue) {
  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();
  return attrValue === "" || executableScriptsMimetypes(attrValue);
};
var isExecutableScript = function(tag, attrs) {
  if (tag !== "script") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    var attrName = attrs[i].name.toLowerCase();
    if (attrName === "type") {
      return isScriptTypeAttribute(attrs[i].value);
    }
  }
  return true;
};
var isStyleLinkTypeAttribute = function(attrValue) {
  attrValue = trimWhitespace(attrValue).toLowerCase();
  return attrValue === "" || attrValue === "text/css";
};
var isStyleSheet = function(tag, attrs) {
  if (tag !== "style") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    var attrName = attrs[i].name.toLowerCase();
    if (attrName === "type") {
      return isStyleLinkTypeAttribute(attrs[i].value);
    }
  }
  return true;
};
var isBooleanAttribute = function(attrName, attrValue) {
  return isSimpleBoolean(attrName) || attrName === "draggable" && !isBooleanValue(attrValue);
};
var isUriTypeAttribute = function(attrName, tag) {
  return /^(?:a|area|link|base)$/.test(tag) && attrName === "href" || tag === "img" && /^(?:src|longdesc|usemap)$/.test(attrName) || tag === "object" && /^(?:classid|codebase|data|usemap)$/.test(attrName) || tag === "q" && attrName === "cite" || tag === "blockquote" && attrName === "cite" || (tag === "ins" || tag === "del") && attrName === "cite" || tag === "form" && attrName === "action" || tag === "input" && (attrName === "src" || attrName === "usemap") || tag === "head" && attrName === "profile" || tag === "script" && (attrName === "src" || attrName === "for");
};
var isNumberTypeAttribute = function(attrName, tag) {
  return /^(?:a|area|object|button)$/.test(tag) && attrName === "tabindex" || tag === "input" && (attrName === "maxlength" || attrName === "tabindex") || tag === "select" && (attrName === "size" || attrName === "tabindex") || tag === "textarea" && /^(?:rows|cols|tabindex)$/.test(attrName) || tag === "colgroup" && attrName === "span" || tag === "col" && attrName === "span" || (tag === "th" || tag === "td") && (attrName === "rowspan" || attrName === "colspan");
};
var isLinkType = function(tag, attrs, value) {
  if (tag !== "link") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    if (attrs[i].name === "rel" && attrs[i].value === value) {
      return true;
    }
  }
};
var isMediaQuery = function(tag, attrs, attrName) {
  return attrName === "media" && (isLinkType(tag, attrs, "stylesheet") || isStyleSheet(tag, attrs));
};
var isSrcset = function(attrName, tag) {
  return attrName === "srcset" && srcsetTags(tag);
};
var cleanAttributeValue = function(tag, attrName, attrValue, options, attrs) {
  if (isEventAttribute(attrName, options)) {
    attrValue = trimWhitespace(attrValue).replace(/^javascript:\s*/i, "");
    return options.minifyJS(attrValue, true);
  } else if (attrName === "class") {
    attrValue = trimWhitespace(attrValue);
    if (options.sortClassName) {
      attrValue = options.sortClassName(attrValue);
    } else {
      attrValue = collapseWhitespaceAll(attrValue);
    }
    return attrValue;
  } else if (isUriTypeAttribute(attrName, tag)) {
    attrValue = trimWhitespace(attrValue);
    return isLinkType(tag, attrs, "canonical") ? attrValue : options.minifyURLs(attrValue);
  } else if (isNumberTypeAttribute(attrName, tag)) {
    return trimWhitespace(attrValue);
  } else if (attrName === "style") {
    attrValue = trimWhitespace(attrValue);
    if (attrValue) {
      if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {
        attrValue = attrValue.replace(/\s*;$/, ";");
      }
      attrValue = options.minifyCSS(attrValue, "inline");
    }
    return attrValue;
  } else if (isSrcset(attrName, tag)) {
    attrValue = trimWhitespace(attrValue).split(/\s+,\s*|\s*,\s+/).map(function(candidate) {
      var url = candidate;
      var descriptor = "";
      var match = candidate.match(/\s+([1-9][0-9]*w|[0-9]+(?:\.[0-9]+)?x)$/);
      if (match) {
        url = url.slice(0, -match[0].length);
        var num = +match[1].slice(0, -1);
        var suffix = match[1].slice(-1);
        if (num !== 1 || suffix !== "x") {
          descriptor = " " + num + suffix;
        }
      }
      return options.minifyURLs(url) + descriptor;
    }).join(", ");
  } else if (isMetaViewport(tag, attrs) && attrName === "content") {
    attrValue = attrValue.replace(/\s+/g, "").replace(/[0-9]+\.[0-9]+/g, function(numString) {
      return (+numString).toString();
    });
  } else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === "content") {
    return collapseWhitespaceAll(attrValue);
  } else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {
    attrValue = attrValue.replace(/\n+|\r+|\s{2,}/g, "");
  } else if (tag === "script" && attrName === "type") {
    attrValue = trimWhitespace(attrValue.replace(/\s*;\s*/g, ";"));
  } else if (isMediaQuery(tag, attrs, attrName)) {
    attrValue = trimWhitespace(attrValue);
    return options.minifyCSS(attrValue, "media");
  }
  return attrValue;
};
var isMetaViewport = function(tag, attrs) {
  if (tag !== "meta") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    if (attrs[i].name === "name" && attrs[i].value === "viewport") {
      return true;
    }
  }
};
var isContentSecurityPolicy = function(tag, attrs) {
  if (tag !== "meta") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    if (attrs[i].name.toLowerCase() === "http-equiv" && attrs[i].value.toLowerCase() === "content-security-policy") {
      return true;
    }
  }
};
var ignoreCSS = function(id) {
  return "/* clean-css ignore:start */" + id + "/* clean-css ignore:end */";
};
var wrapCSS = function(text, type) {
  switch (type) {
    case "inline":
      return "*{" + text + "}";
    case "media":
      return "@media " + text + "{a{top:0}}";
    default:
      return text;
  }
};
var unwrapCSS = function(text, type) {
  var matches;
  switch (type) {
    case "inline":
      matches = text.match(/^\*\{([\s\S]*)\}$/);
      break;
    case "media":
      matches = text.match(/^@media ([\s\S]*?)\s*{[\s\S]*}$/);
      break;
  }
  return matches ? matches[1] : text;
};
var cleanConditionalComment = function(comment, options) {
  return options.processConditionalComments ? comment.replace(/^(\[if\s[^\]]+]>)([\s\S]*?)(<!\[endif])$/, function(match, prefix, text, suffix) {
    return prefix + minify2(text, options, true) + suffix;
  }) : comment;
};
var processScript = function(text, options, currentAttrs) {
  for (var i = 0, len = currentAttrs.length;i < len; i++) {
    if (currentAttrs[i].name.toLowerCase() === "type" && options.processScripts.indexOf(currentAttrs[i].value) > -1) {
      return minify2(text, options);
    }
  }
  return text;
};
var canRemoveParentTag = function(optionalStartTag, tag) {
  switch (optionalStartTag) {
    case "html":
    case "head":
      return true;
    case "body":
      return !headerTags(tag);
    case "colgroup":
      return tag === "col";
    case "tbody":
      return tag === "tr";
  }
  return false;
};
var isStartTagMandatory = function(optionalEndTag, tag) {
  switch (tag) {
    case "colgroup":
      return optionalEndTag === "colgroup";
    case "tbody":
      return tableSectionTags(optionalEndTag);
  }
  return false;
};
var canRemovePrecedingTag = function(optionalEndTag, tag) {
  switch (optionalEndTag) {
    case "html":
    case "head":
    case "body":
    case "colgroup":
    case "caption":
      return true;
    case "li":
    case "optgroup":
    case "tr":
      return tag === optionalEndTag;
    case "dt":
    case "dd":
      return descriptionTags(tag);
    case "p":
      return pBlockTags(tag);
    case "rb":
    case "rt":
    case "rp":
      return rubyTags(tag);
    case "rtc":
      return rtcTag(tag);
    case "option":
      return optionTag(tag);
    case "thead":
    case "tbody":
      return tableContentTags(tag);
    case "tfoot":
      return tag === "tbody";
    case "td":
    case "th":
      return cellTags(tag);
  }
  return false;
};
var canDeleteEmptyAttribute = function(tag, attrName, attrValue, options) {
  var isValueEmpty = !attrValue || /^\s*$/.test(attrValue);
  if (!isValueEmpty) {
    return false;
  }
  if (typeof options.removeEmptyAttributes === "function") {
    return options.removeEmptyAttributes(attrName, tag);
  }
  return tag === "input" && attrName === "value" || reEmptyAttribute.test(attrName);
};
var hasAttrName = function(name, attrs) {
  for (var i = attrs.length - 1;i >= 0; i--) {
    if (attrs[i].name === name) {
      return true;
    }
  }
  return false;
};
var canRemoveElement = function(tag, attrs) {
  switch (tag) {
    case "textarea":
      return false;
    case "audio":
    case "script":
    case "video":
      if (hasAttrName("src", attrs)) {
        return false;
      }
      break;
    case "iframe":
      if (hasAttrName("src", attrs) || hasAttrName("srcdoc", attrs)) {
        return false;
      }
      break;
    case "object":
      if (hasAttrName("data", attrs)) {
        return false;
      }
      break;
    case "applet":
      if (hasAttrName("code", attrs)) {
        return false;
      }
      break;
  }
  return true;
};
var canCollapseWhitespace = function(tag) {
  return !/^(?:script|style|pre|textarea)$/.test(tag);
};
var canTrimWhitespace = function(tag) {
  return !/^(?:pre|textarea)$/.test(tag);
};
var normalizeAttr = function(attr, attrs, tag, options) {
  var attrName = options.name(attr.name), attrValue = attr.value;
  if (options.decodeEntities && attrValue) {
    attrValue = decode(attrValue, { isAttributeValue: true });
  }
  if (options.removeRedundantAttributes && isAttributeRedundant(tag, attrName, attrValue, attrs) || options.removeScriptTypeAttributes && tag === "script" && attrName === "type" && isScriptTypeAttribute(attrValue) || options.removeStyleLinkTypeAttributes && (tag === "style" || tag === "link") && attrName === "type" && isStyleLinkTypeAttribute(attrValue)) {
    return;
  }
  if (attrValue) {
    attrValue = cleanAttributeValue(tag, attrName, attrValue, options, attrs);
  }
  if (options.removeEmptyAttributes && canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {
    return;
  }
  if (options.decodeEntities && attrValue) {
    attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, "&amp;$1");
  }
  return {
    attr,
    name: attrName,
    value: attrValue
  };
};
var buildAttr = function(normalized, hasUnarySlash, options, isLast, uidAttr) {
  var { name: attrName, value: attrValue, attr } = normalized, attrQuote = attr.quote, attrFragment, emittedAttrValue;
  if (typeof attrValue !== "undefined" && (!options.removeAttributeQuotes || ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {
    if (!options.preventAttributesEscaping) {
      if (typeof options.quoteCharacter === "undefined") {
        var apos = (attrValue.match(/'/g) || []).length;
        var quot = (attrValue.match(/"/g) || []).length;
        attrQuote = apos < quot ? "\'" : '"';
      } else {
        attrQuote = options.quoteCharacter === "\'" ? "\'" : '"';
      }
      if (attrQuote === '"') {
        attrValue = attrValue.replace(/"/g, "&#34;");
      } else {
        attrValue = attrValue.replace(/'/g, "&#39;");
      }
    }
    emittedAttrValue = attrQuote + attrValue + attrQuote;
    if (!isLast && !options.removeTagWhitespace) {
      emittedAttrValue += " ";
    }
  } else if (isLast && !hasUnarySlash && !/\/$/.test(attrValue)) {
    emittedAttrValue = attrValue;
  } else {
    emittedAttrValue = attrValue + " ";
  }
  if (typeof attrValue === "undefined" || options.collapseBooleanAttributes && isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase())) {
    attrFragment = attrName;
    if (!isLast) {
      attrFragment += " ";
    }
  } else {
    attrFragment = attrName + attr.customAssign + emittedAttrValue;
  }
  return attr.customOpen + attrFragment + attr.customClose;
};
var identity = function(value) {
  return value;
};
var processOptions = function(values) {
  var options = {
    name: function(name) {
      return name.toLowerCase();
    },
    canCollapseWhitespace,
    canTrimWhitespace,
    html5: true,
    ignoreCustomComments: [/^!/],
    ignoreCustomFragments: [
      /<%[\s\S]*?%>/,
      /<\?[\s\S]*?\?>/
    ],
    includeAutoGeneratedTags: true,
    log: identity,
    minifyCSS: identity,
    minifyJS: identity,
    minifyURLs: identity
  };
  Object.keys(values).forEach(function(key) {
    var value = values[key];
    if (key === "caseSensitive") {
      if (value) {
        options.name = identity;
      }
    } else if (key === "log") {
      if (typeof value === "function") {
        options.log = value;
      }
    } else if (key === "minifyCSS" && typeof value !== "function") {
      if (!value) {
        return;
      }
      if (typeof value !== "object") {
        value = {};
      }
      options.minifyCSS = function(text, type) {
        text = text.replace(/(url\s*\(\s*)("|'|)(.*?)\2(\s*\))/ig, function(match, prefix, quote, url, suffix) {
          return prefix + quote + options.minifyURLs(url) + quote + suffix;
        });
        var cleanCssOutput = new CleanCSS(value).minify(wrapCSS(text, type));
        if (cleanCssOutput.errors.length > 0) {
          cleanCssOutput.errors.forEach(options.log);
          return text;
        }
        return unwrapCSS(cleanCssOutput.styles, type);
      };
    } else if (key === "minifyJS" && typeof value !== "function") {
      if (!value) {
        return;
      }
      if (typeof value !== "object") {
        value = {};
      }
      (value.parse || (value.parse = {})).bare_returns = false;
      options.minifyJS = function(text, inline) {
        var start = text.match(/^\s*<!--.*/);
        var code = start ? text.slice(start[0].length).replace(/\n\s*-->\s*$/, "") : text;
        value.parse.bare_returns = inline;
        var result = UglifyJS.minify(code, value);
        if (result.error) {
          options.log(result.error);
          return text;
        }
        return result.code.replace(/;$/, "");
      };
    } else if (key === "minifyURLs" && typeof value !== "function") {
      if (!value) {
        return;
      }
      if (typeof value === "string") {
        value = { site: value };
      } else if (typeof value !== "object") {
        value = {};
      }
      options.minifyURLs = function(text) {
        try {
          return RelateUrl.relate(text, value);
        } catch (err) {
          options.log(err);
          return text;
        }
      };
    } else {
      options[key] = value;
    }
  });
  return options;
};
var uniqueId = function(value) {
  var id;
  do {
    id = Math.random().toString(36).replace(/^0\.[0-9]*/, "");
  } while (~value.indexOf(id));
  return id;
};
var createSortFns = function(value, options, uidIgnore, uidAttr) {
  var attrChains = options.sortAttributes && Object.create(null);
  var classChain = options.sortClassName && new TokenChain;
  function attrNames(attrs) {
    return attrs.map(function(attr) {
      return options.name(attr.name);
    });
  }
  function shouldSkipUID(token, uid) {
    return !uid || token.indexOf(uid) === -1;
  }
  function shouldSkipUIDs(token) {
    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);
  }
  function scan(input) {
    var currentTag, currentType;
    new HTMLParser(input, {
      start: function(tag2, attrs) {
        if (attrChains) {
          if (!attrChains[tag2]) {
            attrChains[tag2] = new TokenChain;
          }
          attrChains[tag2].add(attrNames(attrs).filter(shouldSkipUIDs));
        }
        for (var i = 0, len = attrs.length;i < len; i++) {
          var attr = attrs[i];
          if (classChain && attr.value && options.name(attr.name) === "class") {
            classChain.add(trimWhitespace(attr.value).split(/[ \t\n\f\r]+/).filter(shouldSkipUIDs));
          } else if (options.processScripts && attr.name.toLowerCase() === "type") {
            currentTag = tag2;
            currentType = attr.value;
          }
        }
      },
      end: function() {
        currentTag = "";
      },
      chars: function(text) {
        if (options.processScripts && specialContentTags(currentTag) && options.processScripts.indexOf(currentType) > -1) {
          scan(text);
        }
      }
    });
  }
  var log = options.log;
  options.log = identity;
  options.sortAttributes = false;
  options.sortClassName = false;
  scan(minify2(value, options));
  options.log = log;
  if (attrChains) {
    var attrSorters = Object.create(null);
    for (var tag in attrChains) {
      attrSorters[tag] = attrChains[tag].createSorter();
    }
    options.sortAttributes = function(tag2, attrs) {
      var sorter2 = attrSorters[tag2];
      if (sorter2) {
        var attrMap = Object.create(null);
        var names = attrNames(attrs);
        names.forEach(function(name, index) {
          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);
        });
        sorter2.sort(names).forEach(function(name, index) {
          attrs[index] = attrMap[name].shift();
        });
      }
    };
  }
  if (classChain) {
    var sorter = classChain.createSorter();
    options.sortClassName = function(value2) {
      return sorter.sort(value2.split(/[ \n\f\r]+/)).join(" ");
    };
  }
};
var minify2 = function(value, options, partialMarkup) {
  if (options.collapseWhitespace) {
    value = collapseWhitespace(value, options, true, true);
  }
  var buffer = [], charsPrevTag, currentChars = "", hasChars, currentTag = "", currentAttrs = [], stackNoTrimWhitespace = [], stackNoCollapseWhitespace = [], optionalStartTag = "", optionalEndTag = "", ignoredMarkupChunks = [], ignoredCustomMarkupChunks = [], uidIgnore, uidAttr, uidPattern;
  value = value.replace(/<!-- htmlmin:ignore -->([\s\S]*?)<!-- htmlmin:ignore -->/g, function(match, group1) {
    if (!uidIgnore) {
      uidIgnore = uniqueId(value);
      var pattern = new RegExp("^" + uidIgnore + "([0-9]+)$");
      if (options.ignoreCustomComments) {
        options.ignoreCustomComments = options.ignoreCustomComments.slice();
      } else {
        options.ignoreCustomComments = [];
      }
      options.ignoreCustomComments.push(pattern);
    }
    var token = "<!--" + uidIgnore + ignoredMarkupChunks.length + "-->";
    ignoredMarkupChunks.push(group1);
    return token;
  });
  var customFragments = options.ignoreCustomFragments.map(function(re) {
    return re.source;
  });
  if (customFragments.length) {
    var reCustomIgnore = new RegExp("\\s*(?:" + customFragments.join("|") + ")+\\s*", "g");
    value = value.replace(reCustomIgnore, function(match) {
      if (!uidAttr) {
        uidAttr = uniqueId(value);
        uidPattern = new RegExp("(\\s*)" + uidAttr + "([0-9]+)" + uidAttr + "(\\s*)", "g");
        if (options.minifyCSS) {
          options.minifyCSS = function(fn) {
            return function(text, type) {
              text = text.replace(uidPattern, function(match2, prefix, index) {
                var chunks = ignoredCustomMarkupChunks[+index];
                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
              });
              var ids = [];
              new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function(warning) {
                var match2 = uidPattern.exec(warning);
                if (match2) {
                  var id = uidAttr + match2[2] + uidAttr;
                  text = text.replace(id, ignoreCSS(id));
                  ids.push(id);
                }
              });
              text = fn(text, type);
              ids.forEach(function(id) {
                text = text.replace(ignoreCSS(id), id);
              });
              return text;
            };
          }(options.minifyCSS);
        }
        if (options.minifyJS) {
          options.minifyJS = function(fn) {
            return function(text, type) {
              return fn(text.replace(uidPattern, function(match2, prefix, index) {
                var chunks = ignoredCustomMarkupChunks[+index];
                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
              }), type);
            };
          }(options.minifyJS);
        }
      }
      var token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;
      ignoredCustomMarkupChunks.push(/^(\s*)[\s\S]*?(\s*)$/.exec(match));
      return "\t" + token + "\t";
    });
  }
  if (options.sortAttributes && typeof options.sortAttributes !== "function" || options.sortClassName && typeof options.sortClassName !== "function") {
    createSortFns(value, options, uidIgnore, uidAttr);
  }
  function _canCollapseWhitespace(tag, attrs) {
    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);
  }
  function _canTrimWhitespace(tag, attrs) {
    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);
  }
  function removeStartTag() {
    var index = buffer.length - 1;
    while (index > 0 && !/^<[^/!]/.test(buffer[index])) {
      index--;
    }
    buffer.length = Math.max(0, index);
  }
  function removeEndTag() {
    var index = buffer.length - 1;
    while (index > 0 && !/^<\//.test(buffer[index])) {
      index--;
    }
    buffer.length = Math.max(0, index);
  }
  function trimTrailingWhitespace(index, nextTag) {
    for (var endTag = null;index >= 0 && _canTrimWhitespace(endTag); index--) {
      var str = buffer[index];
      var match = str.match(/^<\/([\w:-]+)>$/);
      if (match) {
        endTag = match[1];
      } else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {
        break;
      }
    }
  }
  function squashTrailingWhitespace(nextTag) {
    var charsIndex = buffer.length - 1;
    if (buffer.length > 1) {
      var item = buffer[buffer.length - 1];
      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {
        charsIndex--;
      }
    }
    trimTrailingWhitespace(charsIndex, nextTag);
  }
  new HTMLParser(value, {
    partialMarkup,
    continueOnParseError: options.continueOnParseError,
    customAttrAssign: options.customAttrAssign,
    customAttrSurround: options.customAttrSurround,
    html5: options.html5,
    start: function(tag, attrs, unary, unarySlash, autoGenerated) {
      if (tag.toLowerCase() === "svg") {
        options = Object.create(options);
        options.caseSensitive = true;
        options.keepClosingSlash = true;
        options.name = identity;
      }
      tag = options.name(tag);
      currentTag = tag;
      charsPrevTag = tag;
      if (!inlineTextTags(tag)) {
        currentChars = "";
      }
      hasChars = false;
      currentAttrs = attrs;
      var optional = options.removeOptionalTags;
      if (optional) {
        var htmlTag = htmlTags(tag);
        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {
          removeStartTag();
        }
        optionalStartTag = "";
        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {
          removeEndTag();
          optional = !isStartTagMandatory(optionalEndTag, tag);
        }
        optionalEndTag = "";
      }
      if (options.collapseWhitespace) {
        if (!stackNoTrimWhitespace.length) {
          squashTrailingWhitespace(tag);
        }
        if (!unary) {
          if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {
            stackNoTrimWhitespace.push(tag);
          }
          if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {
            stackNoCollapseWhitespace.push(tag);
          }
        }
      }
      var openTag = "<" + tag;
      var hasUnarySlash = unarySlash && options.keepClosingSlash;
      buffer.push(openTag);
      if (options.sortAttributes) {
        options.sortAttributes(tag, attrs);
      }
      var parts = [];
      for (var i = attrs.length, isLast = true;--i >= 0; ) {
        var normalized = normalizeAttr(attrs[i], attrs, tag, options);
        if (normalized) {
          parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));
          isLast = false;
        }
      }
      if (parts.length > 0) {
        buffer.push(" ");
        buffer.push.apply(buffer, parts);
      } else if (optional && optionalStartTags(tag)) {
        optionalStartTag = tag;
      }
      buffer.push(buffer.pop() + (hasUnarySlash ? "/" : "") + ">");
      if (autoGenerated && !options.includeAutoGeneratedTags) {
        removeStartTag();
        optionalStartTag = "";
      }
    },
    end: function(tag, attrs, autoGenerated) {
      if (tag.toLowerCase() === "svg") {
        options = Object.getPrototypeOf(options);
      }
      tag = options.name(tag);
      if (options.collapseWhitespace) {
        if (stackNoTrimWhitespace.length) {
          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {
            stackNoTrimWhitespace.pop();
          }
        } else {
          squashTrailingWhitespace("/" + tag);
        }
        if (stackNoCollapseWhitespace.length && tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {
          stackNoCollapseWhitespace.pop();
        }
      }
      var isElementEmpty = false;
      if (tag === currentTag) {
        currentTag = "";
        isElementEmpty = !hasChars;
      }
      if (options.removeOptionalTags) {
        if (isElementEmpty && topLevelTags(optionalStartTag)) {
          removeStartTag();
        }
        optionalStartTag = "";
        if (htmlTags(tag) && optionalEndTag && !trailingTags(optionalEndTag) && (optionalEndTag !== "p" || !pInlineTags(tag))) {
          removeEndTag();
        }
        optionalEndTag = optionalEndTags(tag) ? tag : "";
      }
      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {
        removeStartTag();
        optionalStartTag = "";
        optionalEndTag = "";
      } else {
        if (autoGenerated && !options.includeAutoGeneratedTags) {
          optionalEndTag = "";
        } else {
          buffer.push("</" + tag + ">");
        }
        charsPrevTag = "/" + tag;
        if (!inlineTags(tag)) {
          currentChars = "";
        } else if (isElementEmpty) {
          currentChars += "|";
        }
      }
    },
    chars: function(text, prevTag, nextTag) {
      prevTag = prevTag === "" ? "comment" : prevTag;
      nextTag = nextTag === "" ? "comment" : nextTag;
      if (options.decodeEntities && text && !specialContentTags(currentTag)) {
        text = decode(text);
      }
      if (options.collapseWhitespace) {
        if (!stackNoTrimWhitespace.length) {
          if (prevTag === "comment") {
            var prevComment = buffer[buffer.length - 1];
            if (prevComment.indexOf(uidIgnore) === -1) {
              if (!prevComment) {
                prevTag = charsPrevTag;
              }
              if (buffer.length > 1 && (!prevComment || !options.conservativeCollapse && / $/.test(currentChars))) {
                var charsIndex = buffer.length - 2;
                buffer[charsIndex] = buffer[charsIndex].replace(/\s+$/, function(trailingSpaces) {
                  text = trailingSpaces + text;
                  return "";
                });
              }
            }
          }
          if (prevTag) {
            if (prevTag === "/nobr" || prevTag === "wbr") {
              if (/^\s/.test(text)) {
                var tagIndex = buffer.length - 1;
                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf("<" + prevTag) !== 0) {
                  tagIndex--;
                }
                trimTrailingWhitespace(tagIndex - 1, "br");
              }
            } else if (inlineTextTags(prevTag.charAt(0) === "/" ? prevTag.slice(1) : prevTag)) {
              text = collapseWhitespace(text, options, /(?:^|\s)$/.test(currentChars));
            }
          }
          if (prevTag || nextTag) {
            text = collapseWhitespaceSmart(text, prevTag, nextTag, options);
          } else {
            text = collapseWhitespace(text, options, true, true);
          }
          if (!text && /\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === "/") {
            trimTrailingWhitespace(buffer.length - 1, nextTag);
          }
        }
        if (!stackNoCollapseWhitespace.length && nextTag !== "html" && !(prevTag && nextTag)) {
          text = collapseWhitespace(text, options, false, false, true);
        }
      }
      if (options.processScripts && specialContentTags(currentTag)) {
        text = processScript(text, options, currentAttrs);
      }
      if (isExecutableScript(currentTag, currentAttrs)) {
        text = options.minifyJS(text);
      }
      if (isStyleSheet(currentTag, currentAttrs)) {
        text = options.minifyCSS(text);
      }
      if (options.removeOptionalTags && text) {
        if (optionalStartTag === "html" || optionalStartTag === "body" && !/^\s/.test(text)) {
          removeStartTag();
        }
        optionalStartTag = "";
        if (compactTags(optionalEndTag) || looseTags(optionalEndTag) && !/^\s/.test(text)) {
          removeEndTag();
        }
        optionalEndTag = "";
      }
      charsPrevTag = /^\s*$/.test(text) ? prevTag : "comment";
      if (options.decodeEntities && text && !specialContentTags(currentTag)) {
        text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, "&amp$1").replace(/</g, "&lt;");
      }
      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {
        text = text.replace(uidPattern, function(match, prefix, index) {
          return ignoredCustomMarkupChunks[+index][0];
        });
      }
      currentChars += text;
      if (text) {
        hasChars = true;
      }
      buffer.push(text);
    },
    comment: function(text, nonStandard) {
      var prefix = nonStandard ? "<!" : "<!--";
      var suffix = nonStandard ? ">" : "-->";
      if (isConditionalComment(text)) {
        text = prefix + cleanConditionalComment(text, options) + suffix;
      } else if (options.removeComments) {
        if (isIgnoredComment(text, options)) {
          text = "<!--" + text + "-->";
        } else {
          text = "";
        }
      } else {
        text = prefix + text + suffix;
      }
      if (options.removeOptionalTags && text) {
        optionalStartTag = "";
        optionalEndTag = "";
      }
      buffer.push(text);
    },
    doctype: function(doctype) {
      buffer.push(options.useShortDoctype ? "<!doctype" + (options.removeTagWhitespace ? "" : " ") + "html>" : collapseWhitespaceAll(doctype));
    }
  });
  if (options.removeOptionalTags) {
    if (topLevelTags(optionalStartTag)) {
      removeStartTag();
    }
    if (optionalEndTag && !trailingTags(optionalEndTag)) {
      removeEndTag();
    }
  }
  if (options.collapseWhitespace) {
    squashTrailingWhitespace("br");
  }
  return joinResultSegments(buffer, options, uidPattern ? function(str) {
    return str.replace(uidPattern, function(match, prefix, index, suffix) {
      var chunk = ignoredCustomMarkupChunks[+index][0];
      if (options.collapseWhitespace) {
        if (prefix !== "\t") {
          chunk = prefix + chunk;
        }
        if (suffix !== "\t") {
          chunk += suffix;
        }
        return collapseWhitespace(chunk, {
          preserveLineBreaks: options.preserveLineBreaks,
          conservativeCollapse: !options.trimCustomFragments
        }, /^[ \n\r\t\f]/.test(chunk), /[ \n\r\t\f]$/.test(chunk));
      }
      return chunk;
    });
  } : identity, uidIgnore ? function(str) {
    return str.replace(new RegExp("<!--" + uidIgnore + "([0-9]+)-->", "g"), function(match, index) {
      return ignoredMarkupChunks[+index];
    });
  } : identity);
};
var joinResultSegments = function(results, options, restoreCustom, restoreIgnore) {
  var str;
  var maxLineLength = options.maxLineLength;
  if (maxLineLength) {
    var line = "", lines = [];
    while (results.length) {
      var len = line.length;
      var end = results[0].indexOf("\n");
      if (end < 0) {
        line += restoreIgnore(restoreCustom(results.shift()));
      } else {
        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));
        results[0] = results[0].slice(end + 1);
      }
      if (len > 0 && line.length > maxLineLength) {
        lines.push(line.slice(0, len));
        line = line.slice(len);
      } else if (end >= 0) {
        lines.push(line);
        line = "";
      }
    }
    if (line) {
      lines.push(line);
    }
    str = lines.join("\n");
  } else {
    str = restoreIgnore(restoreCustom(results.join("")));
  }
  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;
};
var CleanCSS = require_clean();
var decode = require_he().decode;
var HTMLParser = require_htmlparser().HTMLParser;
var RelateUrl = require_lib();
var TokenChain = require_tokenchain();
var UglifyJS = require_node();
var utils = require_utils();
var createMapFromString = utils.createMapFromString;
var inlineTags = createMapFromString("a,abbr,acronym,b,bdi,bdo,big,button,cite,code,del,dfn,em,font,i,ins,kbd,label,mark,math,nobr,object,q,rp,rt,rtc,ruby,s,samp,select,small,span,strike,strong,sub,sup,svg,textarea,time,tt,u,var");
var inlineTextTags = createMapFromString("a,abbr,acronym,b,big,del,em,font,i,ins,kbd,mark,nobr,rp,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var");
var selfClosingInlineTags = createMapFromString("comment,img,input,wbr");
var executableScriptsMimetypes = utils.createMap([
  "text/javascript",
  "text/ecmascript",
  "text/jscript",
  "application/javascript",
  "application/x-javascript",
  "application/ecmascript"
]);
var isSimpleBoolean = createMapFromString("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
var isBooleanValue = createMapFromString("true,false");
var srcsetTags = createMapFromString("img,source");
var optionalStartTags = createMapFromString("html,head,body,colgroup,tbody");
var optionalEndTags = createMapFromString("html,head,body,li,dt,dd,p,rb,rt,rtc,rp,optgroup,option,colgroup,caption,thead,tbody,tfoot,tr,td,th");
var headerTags = createMapFromString("meta,link,script,style,template,noscript");
var descriptionTags = createMapFromString("dt,dd");
var pBlockTags = createMapFromString("address,article,aside,blockquote,details,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,main,menu,nav,ol,p,pre,section,table,ul");
var pInlineTags = createMapFromString("a,audio,del,ins,map,noscript,video");
var rubyTags = createMapFromString("rb,rt,rtc,rp");
var rtcTag = createMapFromString("rb,rtc,rp");
var optionTag = createMapFromString("option,optgroup");
var tableContentTags = createMapFromString("tbody,tfoot");
var tableSectionTags = createMapFromString("thead,tbody,tfoot");
var cellTags = createMapFromString("td,th");
var topLevelTags = createMapFromString("html,head,body");
var compactTags = createMapFromString("html,body");
var looseTags = createMapFromString("head,colgroup,caption");
var trailingTags = createMapFromString("dt,thead");
var htmlTags = createMapFromString("a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,dir,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,listing,main,map,mark,marquee,menu,menuitem,meta,meter,multicol,nav,nobr,noembed,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,plaintext,pre,progress,q,rb,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,spacer,span,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp");
var reEmptyAttribute = new RegExp("^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(?:down|up|over|move|out)|key(?:press|down|up)))$");
var specialContentTags = createMapFromString("script,style");
var $minify = function(value, options) {
  var start = Date.now();
  options = processOptions(options || {});
  var result = minify2(value, options);
  options.log("minified in: " + (Date.now() - start) + "ms");
  return result;
};
export {
  $minify as minify
};
